[
{
  "id": "2002-21",
  "edicao": 2002,
  "numero": 21,
  "enunciado": "Uma característica de uma arquitetura RISC é:",
  "alternativas": [
    "a) Uma arquitetura de alto risco pois o mercado de hardware evolui muito rapidamente",
    "b) Possui um grande conjunto de instruções complexas",
    "c) A arquitetura é constituída de milhares de processadores",
    "d) Possui um pequeno conjunto de instruções simples",
    "e) O processador é formado por válvulas e transistores"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Arquitetura e Organização de Computadores",
  "subarea": "Arquiteturas RISC e CISC",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - arquitetura e organizacao de computadores - arquiteturas risc e cisc"
},

{
  "id": "2002-22",
  "edicao": 2002,
  "numero": 22,
  "enunciado": "Na Álgebra Booleana",
  "alternativas": [
    "a) Os dígitos são octais, de 0 a 7",
    "b) Os dígitos são binários 0 e 1",
    "c) Há dez valores motivados pelos dez dedos do ser humano",
    "d) Os dígitos são alfanuméricos que podem ser representados por um byte",
    "e) Os dígitos são hexadecimais de 0 a 15"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Circuitos Digitais",
  "subarea": "Sistemas de Numeração e Códigos",
  "gabarito": "B",
  "atributo_rag": "fundamentos da computacao - circuitos digitais - sistemas de numeracao e codigos"
},

{
  "id": "2002-24",
  "edicao": 2002,
  "numero": 24,
  "enunciado": "Considere o projeto de um circuito digital que implementa uma função $f$ com três variáveis de entrada e satisfazendo as seguintes propriedades:\n$$\nf(x,y,z)= \\begin{cases}\n1 & \\text{se $x \\neq y$} \\\\\n0 & \\text{caso contrário}\n\\end{cases}\n$$\nQual das seguintes expressões representa corretamente a função $f$?",
  "alternativas": [
    "a) $x + \\overline{y}z$",
    "b) $\\overline{xyz} + x\\overline{y}z$",
    "c) $\\overline{x}y + x\\overline{y}$",
    "d) $xy + \\overline{y}z + \\overline{z}$",
    "e) $\\overline{x}z + xy + \\overline{yz}$"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Circuitos Digitais",
  "subarea": "Projeto de Circuitos Combinatórios",
  "gabarito": "C",
  "atributo_rag": "fundamentos da computacao - circuitos digitais - projeto de circuitos combinatorios"
},

{
  "id": "2002-26",
  "edicao": 2002,
  "numero": 26,
  "enunciado": "Sobre a hierarquia de Chomsky podemos afirmar que:",
  "alternativas": [
    "a) Uma linguagem que é recursivamente enumerável não pode ser uma linguagem regular",
    "b) As linguagens livres de contexto e as linguagens sensíveis a contexto se excluem",
    "c) Uma linguagem que não é regular é livre de contexto",
    "d) As linguagens reconhecidas por autômatos a pilha são as linguagens regulares",
    "e) Há linguagens que não são nem livres de contexto nem sensíveis a contexto"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens Formais, Autômatos e Computabilidade",
  "subarea": "Hierarquia de Chomsky",
  "gabarito": "E",
  "atributo_rag": "fundamentos da computacao - linguagens formais, automatos e computabilidade - hierarquia de chomsky"
},

{
  "id": "2002-27",
  "edicao": 2002,
  "numero": 27,
  "enunciado": "Suponha que $T$ seja uma árvore AVL inicialmente vazia, e considere a inserção dos elementos $10, 20, 30, 5, 15, 2$ em $T$, nesta ordem. Qual das sequências abaixo corresponde a um percurso de $T$ em pré-ordem:",
  "alternativas": [
    "a) $10,5,2,20,15,30$",
    "b) $20,10,5,2,15,30$",
    "c) $2,5,10, 15, 20,30$",
    "d) $30,20,15,10, 5,2$",
    "e) $15,10,5,2,20,30$"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Algoritmos e Estrutura de Dados",
  "subarea": "Árvores e suas Generalizações: Árvores Binárias, Árvores de Busca e Árvores Balanceadas",
  "gabarito": "A",
  "atributo_rag": "fundamentos da computacao - algoritmos e estrutura de dados - arvores e suas generalizacoes: arvores binarias, arvores de busca e arvores balanceadas"
},

{
  "id": "2002-28",
  "edicao": 2002,
  "numero": 28,
  "enunciado": "Considere uma tabela de espalhamento (tabela de *hash*) com quatro posições numeradas 0, 1, 2 e 3. Se a sequência de quadrados perfeitos 1, 4, 9, ..., $i^2$, ... for armazenada nessa tabela segundo a função $f(x) = x \\mod 4$, como se dará a distribuição dos elementos pelas posições da tabela, à medida que o número de entradas cresce?",
  "alternativas": [
    "a) Cada posição da tabela receberá aproximadamente o mesmo número de elementos",
    "b) Três posições da tabela receberão, cada uma, aproximadamente um terço dos elementos",
    "c) Uma única posição da tabela receberá todos os elementos, e as demais posições permanecerão vazias",
    "d) Todas as posições da tabela receberão elementos, mas as duas primeiras receberão, cada uma, o dobro das outras",
    "e) As duas primeiras posições da tabela receberão, cada uma, aproximadamente a metade dos elementos, e as demais posições permanecerão vazias"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Algoritmos e Estrutura de Dados",
  "subarea": "Tabelas Hash",
  "gabarito": "E",
  "atributo_rag": "fundamentos da computacao - algoritmos e estrutura de dados - tabelas hash"
},

{
  "id": "2002-29",
  "edicao": 2002,
  "numero": 29,
  "enunciado": "Qual das seguintes afirmações sobre crescimento assintótico de funções não é verdadeira:",
  "alternativas": [
    "a) $2n^2 + 3n + 1 = O(n^2)$",
    "b) Se $f(n) = O(g(n))$ então $g(n) = O(F(n))$",
    "c) $\\log n^2 = O(\\log n)$",
    "d) Se $f(n) = O(g(n))$ e $g(n) = O(h(n))$ então $F(n) = O(h(n))$",
    "e) $2^{n + 1} = O(2^n)$"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Análise de Algoritmos",
  "subarea": "Notação “Big O”, “Little o”, “Omega” e “Theta”",
  "gabarito": "B",
  "atributo_rag": "fundamentos da computacao - analise de algoritmos - notacao “big o”, “little o”, “omega” e “theta”"
},

{
  "id": "2002-30",
  "edicao": 2002,
  "numero": 30,
  "enunciado": "Considere um problema em que são dados 5 objetos com os seguintes pesos e valores:\n$$\n\\begin{align*}\n\\text{pesos: } & (W_1, W_2, W_3, W_4, W_5) = (6, 10, 9, 5, 12) \\\\\n\\text{valores: } & (P_1, P_2, P_3, P_4, P_5) = (8, 5, 10, 15, 7)\n\\end{align*}\n$$\nAlém disso, é dada uma mochila que suporta até 30 unidades de peso, para transportar os objetos. O objetivo do problema é preencher a mochila de tal forma que o valor total dos objetos a serem transportados seja o maior possível, mas sem exceder o limite de peso suportado pela mochila. Assuma que é permitido colocar fração de um objeto na mochila. Qual das seguintes alternativas corresponde ao valor máximo obtido no preenchimento da mochila:",
  "alternativas": [
    "a) 12.2",
    "b) 21.5",
    "c) 30.34",
    "d) 38.83",
    "e) 43.1"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Algoritmos e Estrutura de Dados",
  "subarea": "Técnicas de Projeto de Algoritmos: Método da Força Bruta, Pesquisa Exaustiva, Algoritmo Guloso, Dividir e Conquistar, “Backtracking” e Heurísticas",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - algoritmos e estrutura de dados - tecnicas de projeto de algoritmos: metodo da forca bruta, pesquisa exaustiva, algoritmo guloso, dividir e conquistar, “backtracking” e heuristicas"
},

{
  "id": "2002-31",
  "edicao": 2002,
  "numero": 31,
  "enunciado": "Considere o algoritmo da busca sequencial de um elemento em um conjunto com $n$ elementos. A expressão que representa o tempo médio de execução desse algoritmo para uma busca bem sucedida é:",
  "alternativas": [
    "a) $n^2$",
    "b) $n(n + 1)/2$",
    "c) $\\log_2 n$",
    "d) $(n + 1)/2$",
    "e) $n \\log n$"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Análise de Algoritmos",
  "subarea": "Análise de Algoritmos Iterativos e Recursivos",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - analise de algoritmos - analise de algoritmos iterativos e recursivos"
},

{
  "id": "2002-32",
  "edicao": 2002,
  "numero": 32,
  "enunciado": "Quais dos algoritmos de ordenação abaixo possuem tempo no pior caso e tempo médio de execução proporcional a $O(n \\log n)$.",
  "alternativas": [
    "a) Bubble sort e Quick sort",
    "b) Quicksort e merge sort",
    "c) Merge sort e bubble sort",
    "d) Heap sort e selection sort",
    "e) Merge sort e heap sort"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Análise de Algoritmos",
  "subarea": "Medidas de Complexidade, Análise Assintótica de Limites de Complexidade, Técnicas de Prova de Cotas Inferiores",
  "gabarito": "E",
  "atributo_rag": "fundamentos da computacao - analise de algoritmos - medidas de complexidade, analise assintotica de limites de complexidade, tecnicas de prova de cotas inferiores"
},

{
  "id": "2002-33",
  "edicao": 2002,
  "numero": 33,
  "enunciado": "Professor Mac Sperto propôs o seguinte algoritmo de ordenação, chamado de Super Merge, similar ao merge sort: divida o vetor em 4 partes do mesmo tamanho (ao invés de 2, como é feito no merge sort). Ordene recursivamente cada uma das partes e depois intercale-as por um procedimento semelhante ao procedimento de intercalação do merge sort. Qual das alternativas abaixo é verdadeira?",
  "alternativas": [
    "a) Super Merge não está correto. Não é possível ordenar quebrando o vetor em 4 partes",
    "b) Super Merge está correto, mas consome tempo O(*merge sort*)",
    "c) Super Merge está correto, mas consome tempo maior que O(*merge sort*)",
    "d) Super Merge está correto, mas consome tempo menor que O(*merge sort*)",
    "e) Nenhuma das afirmações acima está correta"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Algoritmos e Estrutura de Dados",
  "subarea": "Algoritmos para Pesquisa e Ordenação",
  "gabarito": "B",
  "atributo_rag": "fundamentos da computacao - algoritmos e estrutura de dados - algoritmos para pesquisa e ordenacao"
},

{
  "id": "2002-34",
  "edicao": 2002,
  "numero": 34,
  "enunciado": "No que diz respeito as vantagens da arquitetura de micro-núcleo para sistemas operacionais em relação a arquiteturas de núcleo monolítico, quais das seguintes afirmações são verdadeiras? \\\nI - A arquitetura de micro-núcleo facilita a depuração do SO. \\\nII - A arquitetura de micro-núcleo permite um número menor de mudanças de contexto. \\\nIII - A arquitetura de micro-núcleo facilita a reconfiguração de serviços do SO pois a maioria deles reside em espaço de usuário.",
  "alternativas": [
    "a) Apenas I",
    "b) Il e III",
    "c) I e III",
    "d) I e II",
    "e) Todas são verdadeiras"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Sistemas Operacionais",
  "subarea": "Gerência de Processos/Processador",
  "gabarito": "C",
  "atributo_rag": "fundamentos da computacao - sistemas operacionais - gerencia de processos/processador"
},

{
  "id": "2002-35",
  "edicao": 2002,
  "numero": 35,
  "enunciado": "Considere um sistema distribuído onde cada nó precisa obter um bloqueio (*lock*) antes de acessar qualquer serviço no sistema. Qual das estratégias a seguir não seria eficaz para evitar impasses (*deadlocks*)?",
  "alternativas": [
    "a) Associar prioridades aos nós e criar filas de prioridades para cada serviço",
    "b) Numerar os serviços e exigir que cada nó solicite os bloqueios dos serviços em ordem crescente",
    "c) Instalar um serviço de detecção de impasses no sistema distribuído e reiniciar os nós que atinjam um impasse",
    "d) Fazer com que cada nó reinicie sua execução se um pedido de bloqueio não é concedido após um longo tempo de espera O pedido de bloqueio é re-enviado após um tempo aleatório",
    "e) Forçar cada nó a obter todos os bloqueios de que necessita no início de sua execução e reiniciar a execução se algum bloqueio não é concedido"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Sistemas Operacionais",
  "subarea": "Comunicação, Concorrência e Sincronização de Processos",
  "gabarito": "A",
  "atributo_rag": "fundamentos da computacao - sistemas operacionais - comunicacao, concorrencia e sincronizacao de processos"
},

{
  "id": "2002-36",
  "edicao": 2002,
  "numero": 36,
  "enunciado": "Uma árvore binária é declarada em C como\n```\ntypedef struct no *apontador;\nstruct no {\n         int valor;\n         apontador esq, dir;\n          };\n```\nonde `esq` e `dir` representam ligações para os filhos esquerdo e direito de um nó da árvore, respectivamente. Qual das seguintes alternativas é uma implementação correta da operação que inverte as posições dos filhos esquerdo e direito de um nó `p` da árvore, onde `t` é um apontador auxiliar.",
  "alternativas": [
    "a)\n```\nt = p;\np->esq = p->dir;\np->dir = p->esq\n```",
    "b) \n```\np->dir = t;\np->esq = p->dir;\np->dir = t\n```",
    "c) \n```\np->esq = p->dir;\nt = p->esq;\np->dir = t\n```",
    "d)\n```\nt = p->dir;\np->esq = p->dir;\np->dir = t\n```",
    "e) \n```\nt = p->dir;\np->dir = p->esq;\np->esq = t\n```"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Algoritmos e Estrutura de Dados",
  "subarea": "Árvores e suas Generalizações: Árvores Binárias, Árvores de Busca e Árvores Balanceadas",
  "gabarito": "E",
  "atributo_rag": "fundamentos da computacao - algoritmos e estrutura de dados - arvores e suas generalizacoes: arvores binarias, arvores de busca e arvores balanceadas"
},

{
  "id": "2002-37",
  "edicao": 2002,
  "numero": 37,
  "enunciado": "No programa abaixo, escrito em Pascal, os parâmetros do procedimento `vr` são passados por valor.\n```\nprogram teste;\nvar x,y: integer;\n\n  procedure vr(u,v: integer);\n  begin\n    u:=2*u;\n    x:=u+v;\n    u:=u-l;\n  end;\n\nbegin\n  x:=4;\n  y:=2;\n  vr(x,y);\n  writeln(x);\nend.\n```\nO valor de `x` impresso na última linha do programa é:",
  "alternativas": [
    "a) 4",
    "b) 5",
    "c) 7",
    "d) 8",
    "e) 10"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens de Programação",
  "subarea": "Paradigmas de Linguagens de Programação",
  "gabarito": "E",
  "atributo_rag": "fundamentos da computacao - linguagens de programacao - paradigmas de linguagens de programacao"
},

{
  "id": "2002-38",
  "edicao": 2002,
  "numero": 38,
  "enunciado": "A função abaixo computa a soma dos $n$ primeiros números inteiros não negativos:\n```\nfunction sum(n: integer) : integer;\nbegin\n  if n=0 then sum:=0\n  else --------------\nend;\n```\nA parte que falta para completar a condição else é:",
  "alternativas": [
    "a) `while n<>0 sum:=sum + sum(n+1)`",
    "b) `sum:=n + sum(n)`",
    "c) `sum:=(n-1) + sum(n-1)`",
    "d) `sum:=n + sum(n-1)`",
    "e) `sum:=(n-1) + sum(n)`"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Algoritmos e Estrutura de Dados",
  "subarea": "Recursividade: Conceito e Implementação",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - algoritmos e estrutura de dados - recursividade: conceito e implementacao"
},

{
  "id": "2002-39",
  "edicao": 2002,
  "numero": 39,
  "enunciado": "O menor número possível de arestas em um grafo conexo com $n$ vértices é:",
  "alternativas": [
    "a) $1$",
    "b) $n/2$",
    "c) $n-1$",
    "d) $n$",
    "e) $n^2$"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Teoria dos Grafos",
  "subarea": "Grafos orientados e não-orientados",
  "gabarito": "C",
  "atributo_rag": "fundamentos da computacao - teoria dos grafos - grafos orientados e nao-orientados"
},

{
  "id": "2002-40",
  "edicao": 2002,
  "numero": 40,
  "enunciado": "Considere um grafo $G$ satisfazendo as seguintes propriedades:\n- $G$ é conexo\n- Se removermos qualquer aresta de $G$, o grafo obtido é desconexo.\n\nEntão é correto afirmar que o grafo $G$ é:",
  "alternativas": [
    "a) Um circuito",
    "b) Não bipartido",
    "c) Uma árvore",
    "d) Hamiltoniano",
    "e) Euleriano"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Teoria dos Grafos",
  "subarea": "Conectividade",
  "gabarito": "C",
  "atributo_rag": "fundamentos da computacao - teoria dos grafos - conectividade"
},

{
  "id": "2003-23",
  "edicao": 2003,
  "numero": 23,
  "enunciado": "Para que serve a segmentação de um processador (*pipelining*)?",
  "alternativas": [
    "a) permitir a execução de mais de uma instrução por ciclo de relógio",
    "b) aumentar a velocidade do relógio",
    "c) simplificar o conjunto de instruções",
    "d) reduzir o número de instruções estáticas nos programas",
    "e) simplificar a implementação do processador"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Arquitetura e Organização de Computadores",
  "subarea": "Pipeline",
  "gabarito": "A",
  "atributo_rag": "fundamentos da computacao - arquitetura e organizacao de computadores - pipeline"
},

{
  "id": "2003-24",
  "edicao": 2003,
  "numero": 24,
  "enunciado": "A interposição de um circuito de memória cache entre o processador e a memória principal (RAM)",
  "alternativas": [
    "a) aumenta o tráfego de instruções e /ou dados no barramento de memória",
    "b) aumenta o tráfego de instruções e/ou dados entre memória e disco",
    "c) diminui o tráfego de instruções e/ou dados no barramento de memória",
    "d) diminui o tráfego de instruções e/ou dados entre memória e disco",
    "e) permite acessos concorrentes à memória RAM"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Arquitetura e Organização de Computadores",
  "subarea": "Organização de Memória",
  "gabarito": "C",
  "atributo_rag": "fundamentos da computacao - arquitetura e organizacao de computadores - organizacao de memoria"
},

{
  "id": "2003-25",
  "edicao": 2003,
  "numero": 25,
  "enunciado": "São vantagens da utilização de *threads* no espaço do usuário, exceto:",
  "alternativas": [
    "a) Nenhuma modificação é necessária no *kernel*.",
    "b) O sistema operacional escalona a *thread*.",
    "c) O escalonamento pode ser específico para a aplicação.",
    "d) A criação e o gerenciamento das *threads* são mais eficientes.",
    "e) Maior portabilidade da aplicação."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Sistemas Operacionais",
  "subarea": "Comunicação, Concorrência e Sincronização de Processos",
  "gabarito": "B",
  "atributo_rag": "fundamentos da computacao - sistemas operacionais - comunicacao, concorrencia e sincronizacao de processos"
},

{
  "id": "2003-26",
  "edicao": 2003,
  "numero": 26,
  "enunciado": "Considere o seguinte código para implementar exclusão mútua entre dois processos $i$ e $j$:\n```\nProcesso Pi\n  do\n    while (turn != i) ; // entrada da seção crítica\n          seção crítica\n    turn = j;           // saída da seção crítica\n          código restante\n  while (1);\n```\nEm relação ao código acima, todas as afirmativas estão corretas, exceto:",
  "alternativas": [
    "a) A implementação garante exclusão mútua.",
    "b) A implementação garante progresso.",
    "c) Os processos fazem espera ativa.",
    "d) Exige alternância estrita.",
    "e) Um processo bloqueia o outro mesmo não estando na seção crítica."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Sistemas Operacionais",
  "subarea": "Comunicação, Concorrência e Sincronização de Processos",
  "gabarito": "B",
  "atributo_rag": "fundamentos da computacao - sistemas operacionais - comunicacao, concorrencia e sincronizacao de processos"
},

{
  "id": "2003-27",
  "edicao": 2003,
  "numero": 27,
  "enunciado": "Uma gramática G é definida por:\n$$\nG = (\\{x, y, z\\}, \\{S, W, X, Y, Z\\}, P, S)\n$$\nna qual os membros de $P$ são:\n$$\n\\begin{align*}\n& S \\rightarrow WZ \\\\\n& W \\rightarrow X \\mid Y \\\\\n& X \\rightarrow x \\mid xX \\\\\n& Y \\rightarrow y \\mid yY \\\\\n& Z \\rightarrow z \\mid zZ \\\\\n\\end{align*}\n$$\nQual das expressões regulares abaixo corresponde a esta gramática?",
  "alternativas": [
    "a) $(xx^* \\mid yy^*)zz^*$",
    "b) $xx^* \\mid yy^* \\mid zz^*$",
    "c) $xx^*(yy^* \\mid zz^*)$",
    "d) $(xx \\mid yy)^*zz^*$",
    "e) $xx^*yy^*zz^*$"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens Formais, Autômatos e Computabilidade",
  "subarea": "Linguagens Regulares, Livres-de-Contexto e Sensíveis-ao-Contexto",
  "gabarito": "A",
  "atributo_rag": "fundamentos da computacao - linguagens formais, automatos e computabilidade - linguagens regulares, livres-de-contexto e sensiveis-ao-contexto"
},

{
  "id": "2003-28",
  "edicao": 2003,
  "numero": 28,
  "enunciado": "Considere o seguinte trecho de programa:\n```\n1. i:= 1;\n2. while i <=n do\n   begin\n3. sum:= sum + a[i];\n4. i:=i+ 1;\n   end;\n```\n\nConsidere que: \n - $I$ representa a inicialização da variável `i:= 1` na linha 1; \n - $T$ representa o teste da linha 2; \n - $A$ representa os comandos da linha 3; \n - $P$ representa o incremento na linha 4.\n\nQual é a expressão regular que representa todas as sequências de passos possíveis de serem executados por este trecho de programa?",
  "alternativas": [
    "a) $I(TAP)^+$",
    "b) $I(TAP)^*$",
    "c) $IT^+A^*P^*$",
    "d) $IT(APT)^*$",
    "e) $IT(APT)^+$"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens Formais, Autômatos e Computabilidade",
  "subarea": "Linguagens Regulares, Livres-de-Contexto e Sensíveis-ao-Contexto",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - linguagens formais, automatos e computabilidade - linguagens regulares, livres-de-contexto e sensiveis-ao-contexto"
},

{
  "id": "2003-29",
  "edicao": 2003,
  "numero": 29,
  "enunciado": "Um compilador detecta:",
  "alternativas": [
    "a) erros que podem ocorrer durante a execução do programa",
    "b) erros nos resultados gerados pelo programa",
    "c) erros de sintaxe do programa",
    "d) erros aritméticos",
    "e) todos os erros citados acima"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens de Programação",
  "subarea": "Verificação e Inferência de Tipos",
  "gabarito": "C",
  "atributo_rag": "fundamentos da computacao - linguagens de programacao - verificacao e inferencia de tipos"
},

{
  "id": "2003-30",
  "edicao": 2003,
  "numero": 30,
  "enunciado": "Em uma lista circular duplamente encadeada com $n$ elementos, o espaço ocupado apenas pelos apontadores é (assuma que um apontador ocupa $p$ bytes):",
  "alternativas": [
    "a) $np$",
    "b) $2np$",
    "c) $4np$",
    "d) $6np$",
    "e) $(np)^2$"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Algoritmos e Estrutura de Dados",
  "subarea": "Estruturas de Dados Lineares e suas Generalizações: Listas Ordenadas, Listas Encadeadas, Pilhas e Filas",
  "gabarito": "B",
  "atributo_rag": "fundamentos da computacao - algoritmos e estrutura de dados - estruturas de dados lineares e suas generalizacoes: listas ordenadas, listas encadeadas, pilhas e filas"
},

{
  "id": "2003-31",
  "edicao": 2003,
  "numero": 31,
  "enunciado": "Considere $n$ chaves armazenadas\n\n(I) de maneira arbitrária numa lista encadeada simples, \\\n(II) de maneira arbitrária numa lista encadeada dupla. \\\nConsidere também as mesmas chaves \\\n(III) armazenadas de maneira ordenada numa lista encadeada simples, \\\n(IV) armazenadas de maneira ordenada numa lista encadeada dupla. \n\nQual das alternativas preenche a seguinte tabela com a complexidade de busca no pior caso, em cada uma das situações I, II, III e IV descritas acima?\n<table>\n  <thead>\n    <tr>\n      <th rowspan=\"2\">Ligação</th>\n      <th colspan=\"2\">Chaves</th>\n    </tr>\n    <tr>\n      <th>arbitrária</th>\n      <th>ordenada</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>simples</td>\n      <td></td>\n      <td></td>\n    </tr>\n    <tr>\n      <td>dupla</td>\n      <td></td>\n      <td></td>\n    </tr>\n  </tbody>\n</table>",
  "alternativas": [
    "a) \n|$\\Theta(n)$|$\\Theta(n)$|\n|-|-|\n|$\\Theta(n)$|$\\Theta(n)$|",
    "b)\n|$\\Theta(n)$|$\\Theta(n)$|\n|-|-|\n|$\\Theta(2)$|$\\Theta(2)$|",
    "c)\n|$\\Theta(n \\log n)$|$\\Theta(n)$|\n|-|-|\n|$\\Theta(n \\log n)$|$\\Theta(n)$|",
    "d)\n|$\\Theta(n)$|$\\Theta(\\log n)$|\n|-|-|\n|$\\Theta(n)$|$\\Theta(\\log n)$|",
    "e)\n|$\\Theta(n)$|$\\Theta(1)$|\n|-|-|\n|$\\Theta(n)$|$\\Theta(1)$|"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Algoritmos e Estrutura de Dados",
  "subarea": "Estruturas de Dados Lineares e suas Generalizações: Listas Ordenadas, Listas Encadeadas, Pilhas e Filas",
  "gabarito": "A",
  "atributo_rag": "fundamentos da computacao - algoritmos e estrutura de dados - estruturas de dados lineares e suas generalizacoes: listas ordenadas, listas encadeadas, pilhas e filas"
},

{
  "id": "2003-32",
  "edicao": 2003,
  "numero": 32,
  "enunciado": "Em um *heap* com $n$ vértices existem:",
  "alternativas": [
    "a) exatamente $\\lfloor n/5 \\rfloor$ folhas",
    "b) aproximadamente $\\log n$ folhas",
    "c) não mais que $\\lfloor n/5 \\rfloor$ folhas",
    "d) exatamente $\\lceil n/2 \\rceil$ folhas",
    "e) não menos que $2n/3$ folhas"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Algoritmos e Estrutura de Dados",
  "subarea": "Árvores e suas Generalizações: Árvores Binárias, Árvores de Busca e Árvores Balanceadas",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - algoritmos e estrutura de dados - arvores e suas generalizacoes: arvores binarias, arvores de busca e arvores balanceadas"
},

{
  "id": "2003-33",
  "edicao": 2003,
  "numero": 33,
  "enunciado": "Considere as seguintes afirmativas: \\\nI. O modelo matemático de uma lista é a sequência linear de itens, cuja principal propriedade estrutural é a posição relativa dos elementos dentro da sequência. \\\nII. A fila e a pilha são consideradas casos especiais da lista. \\\nIII. Numa fila a inserção e a retirada são feitas no mesmo extremo. \\\nIV. Numa lista a inserção e a retirada podem ser feitas em qualquer posição. \\\nV. Numa pilha apenas a inserção pode ser feita em qualquer posição. \\\nQuais são as afirmativas verdadeiras?",
  "alternativas": [
    "a) somente I e III",
    "b) somente II, III e IV",
    "c) somente I, II e IV",
    "d) somente II, IV e V",
    "e) todas"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Algoritmos e Estrutura de Dados",
  "subarea": "Estruturas de Dados Lineares e suas Generalizações: Listas Ordenadas, Listas Encadeadas, Pilhas e Filas",
  "gabarito": "C",
  "atributo_rag": "fundamentos da computacao - algoritmos e estrutura de dados - estruturas de dados lineares e suas generalizacoes: listas ordenadas, listas encadeadas, pilhas e filas"
},

{
  "id": "2003-34",
  "edicao": 2003,
  "numero": 34,
  "enunciado": "A função abaixo, escrita na linguagem C, quando executada para $n = 5$, faz quantas chamadas recursivas (excluindo a primeira chamada da função)?\n```\nint fat (int n)\n{\n    if (n == 1) return n;\n    else return (n*fat(n-1));\n}\n```",
  "alternativas": [
    "a) 6",
    "b) 5",
    "c) 4",
    "d) 1",
    "e) 0"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Algoritmos e Estrutura de Dados",
  "subarea": "Recursividade: Conceito e Implementação",
  "gabarito": "C",
  "atributo_rag": "fundamentos da computacao - algoritmos e estrutura de dados - recursividade: conceito e implementacao"
},

{
  "id": "2003-35",
  "edicao": 2003,
  "numero": 35,
  "enunciado": "Qual é a opção que descreve a tarefa executada pelo seguinte algoritmo escrito em Pascal?\n```\nprocedure fazalgo (var x, var y)\nbegin\n  x := x + y;\n  y := x - y;\n  x := x - y;\nend\n```",
  "alternativas": [
    "a) divide `x` por `y` utilizando a subtração e retorna o resultado em `x`",
    "b) divide `y` por `x` utilizando a subtração e retorna o resultado em `x`",
    "c) troca os valores de `x` e `y`",
    "d) calcula o mínimo múltiplo comum entre `x` e `y` e retorna o valor em `x`",
    "e) não altera os valores de `x` e `y`"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Algoritmos e Estrutura de Dados",
  "subarea": "Modularidade e Abstração",
  "gabarito": "C",
  "atributo_rag": "fundamentos da computacao - algoritmos e estrutura de dados - modularidade e abstracao"
},

{
  "id": "2003-36",
  "edicao": 2003,
  "numero": 36,
  "enunciado": "Para que faixa de valores da variável $x$ o seguinte segmento de código imprime a letra `C`?\n```\nif (x <= 200)\n    if (x < 100)\n        if (x < 0) printf(\"A\")\n        else printf(\"B\")\n    else printf(\"C\")\nelse printf(\"D\")\n```",
  "alternativas": [
    "a) $0 < x < 100$",
    "b) $x <= 100$",
    "c) $100 <= x <= 200$",
    "d) $x > 200$",
    "e) $100 < x <= 200$"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Técnicas de Programação",
  "subarea": "Comandos de uma Linguagem de programação",
  "gabarito": "C",
  "atributo_rag": "fundamentos da computacao - tecnicas de programacao - comandos de uma linguagem de programacao"
},

{
  "id": "2003-37",
  "edicao": 2003,
  "numero": 37,
  "enunciado": "Qual é o número mínimo de comparações necessário para encontrar o menor elemento de um conjunto qualquer não ordenado de $n$ elementos?",
  "alternativas": [
    "a) $1$",
    "b) $n-1$",
    "c) $n$",
    "d) $n+1$",
    "e) $n \\log n$"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Análise de Algoritmos",
  "subarea": "Medidas de Complexidade, Análise Assintótica de Limites de Complexidade, Técnicas de Prova de Cotas Inferiores",
  "gabarito": "B",
  "atributo_rag": "fundamentos da computacao - analise de algoritmos - medidas de complexidade, analise assintotica de limites de complexidade, tecnicas de prova de cotas inferiores"
},

{
  "id": "2003-38",
  "edicao": 2003,
  "numero": 38,
  "enunciado": "Dentre os algoritmos de ordenação citados abaixo, qual é o que executa mais rápido para uma grande variedade de entrada de dados?",
  "alternativas": [
    "a) bolha",
    "b) shellsort",
    "c) mergesort",
    "d) quicksort",
    "e) heapsort"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Análise de Algoritmos",
  "subarea": "Medidas Empíricas de Performance",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - analise de algoritmos - medidas empiricas de performance"
},

{
  "id": "2003-39",
  "edicao": 2003,
  "numero": 39,
  "enunciado": "Quais das seguintes igualdades são verdadeiras? \\\nI. $n^2 = \\cal{O}(n^3)$ \\\nII. $2 * n + 1= \\cal{O}(n^2)$ \\\nIII. $n^3 = \\cal{O}(n^2)$ \\\nIV. $3 * n + 5 * n \\log n = \\cal{O}(n)$ \\\nV. $\\log n + n = \\cal{O}(n)$",
  "alternativas": [
    "a) somente I e II",
    "b) somente II, III e IV",
    "c) somente III, IV e V",
    "d) somente I, II e V",
    "e) somente I, III e IV"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Técnicas de Programação",
  "subarea": "Metodologia de desenvolvimento de programas",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - tecnicas de programacao - metodologia de desenvolvimento de programas"
},

{
  "id": "2004-21",
  "edicao": 2004,
  "numero": 21,
  "enunciado": "Seja $\\Sigma = \\{a, b\\}$. Uma expressão regular denotando a linguagem $L = \\{w \\in \\Sigma^*$ tal que toda ocorrência de “$a$” em $w$ é imediatamente seguida de “$b$”$\\}$ é:",
  "alternativas": [
    "a) $(a^*b)^*$",
    "b) $(b + ab)^*$",
    "c) $a^*b$",
    "d) $b + (ab)^*$",
    "e) $(ab)^*$"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens Formais, Autômatos e Computabilidade",
  "subarea": "Linguagens Regulares, Livres-de-Contexto e Sensíveis-ao-Contexto",
  "gabarito": "B",
  "atributo_rag": "fundamentos da computacao - linguagens formais, automatos e computabilidade - linguagens regulares, livres-de-contexto e sensiveis-ao-contexto"
},

{
  "id": "2004-22",
  "edicao": 2004,
  "numero": 22,
  "enunciado": "Quanto vale $k$ no fim da execução do seguinte trecho de código?\n```\nk = 0;\nfor (i=1; i <= n; i++)\n    for(j = i; j <= n; j++)\n        k = k + 1;\n```",
  "alternativas": [
    "a) $n - 1$",
    "b) $n$",
    "c) $(n^2 - n)/2$",
    "d) $n(n + 1)/2$",
    "e) $n^3$"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Análise de Algoritmos",
  "subarea": "Análise de Algoritmos Iterativos e Recursivos",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - analise de algoritmos - analise de algoritmos iterativos e recursivos"
},

{
  "id": "2004-23",
  "edicao": 2004,
  "numero": 23,
  "enunciado": "O programa abaixo, quando executado para $A(1, 2)$, faz quantas chamadas recursivas (excluindo a primeira chamada da função)?\n```\nint A (int m, int n) {\n    if (m == 0) return n + 1;\n    else if (n == 0) return A (m - 1, 1);\n    else return A (m - 1, A (m, n - 1));\n    }\n```",
  "alternativas": [
    "a) 6",
    "b) 5",
    "c) 4",
    "d) 3",
    "e) 2"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Algoritmos e Estrutura de Dados",
  "subarea": "Recursividade: Conceito e Implementação",
  "gabarito": "B",
  "atributo_rag": "fundamentos da computacao - algoritmos e estrutura de dados - recursividade: conceito e implementacao"
},

{
  "id": "2004-24",
  "edicao": 2004,
  "numero": 24,
  "enunciado": "Considere as seguintes estruturas de dados:\n\n(I) Tabela hash \\\n(II) Fila \\\n(III) Árvore de pesquisa \\\n(IV) Pilha\n\nQual ou quais das estruturas acima requer mais do que tempo médio constante para inserção de um elemento?",
  "alternativas": [
    "a) Somente (I)",
    "b) Somente (II)",
    "c) Somente (III)",
    "d) Somente (IV)",
    "e) Todas."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Algoritmos e Estrutura de Dados",
  "subarea": "Tipos de Dados Básicos e Estruturados",
  "gabarito": "C",
  "atributo_rag": "fundamentos da computacao - algoritmos e estrutura de dados - tipos de dados basicos e estruturados"
},

{
  "id": "2004-25",
  "edicao": 2004,
  "numero": 25,
  "enunciado": "Considere as seguintes afirmativas sobre o algoritmo de pesquisa binária:\n\nI. a entrada deve estar ordenada \\\nII. uma pesquisa com sucesso é feita em tempo logarítmico na média \\\nIII. uma pesquisa sem sucesso é feita em tempo logarítmico na média \\\nIV. o pior caso de qualquer busca é logarítmico\n\nAs afirmativas corretas são:",
  "alternativas": [
    "a) Somente I e II.",
    "b) Somente I, II e III.",
    "c) Somente II e III.",
    "d) Somente III e IV.",
    "e) Todas as afirmativas estão corretas."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Algoritmos e Estrutura de Dados",
  "subarea": "Algoritmos para Pesquisa e Ordenação",
  "gabarito": "E",
  "atributo_rag": "fundamentos da computacao - algoritmos e estrutura de dados - algoritmos para pesquisa e ordenacao"
},

{
  "id": "2004-26",
  "edicao": 2004,
  "numero": 26,
  "enunciado": "Em sistemas de memória virtual de paginação sob demanda, qual seria o critério ideal para substituição de páginas?",
  "alternativas": [
    "a) retirar a página que acabou de ser referenciada",
    "b) retirar a página que será necessária no futuro mais distante",
    "c) retirar a página que está há mais tempo na memória",
    "d) retirar a página que foi referenciada menos vezes",
    "e) retirar a página que está há mais tempo sem ser utilizada"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Sistemas Operacionais",
  "subarea": "Gerenciamento de Memória: Memória Virtual, Paginação, Segmentação e “Swap”",
  "gabarito": "B",
  "atributo_rag": "fundamentos da computacao - sistemas operacionais - gerenciamento de memoria: memoria virtual, paginacao, segmentacao e “swap”"
},

{
  "id": "2004-27",
  "edicao": 2004,
  "numero": 27,
  "enunciado": "Considere o seguinte programa com dois processos concorrentes. O escalonador poderá alternar entre um e outro, isto é, eles poderão ser intercalados durante sua execução. As variáveis $x$ e $y$ são compartilhadas pelos dois processos e inicializadas antes de sua execução.\n```\nprograma P\nint x = 0;\nint y = 0;\nprocesso A {\n    while (x == 0);\n    print(‘‘a’’);\n    y = 1;\n    y = 0;\n    print(‘‘d’’);\n    y = 1;\n}\n\nprocesso B {\n    print(‘‘b’’);\n    x = 1;\n    while (y == 0);\n    print(\"c\");\n}\n```",
  "alternativas": [
    "a) `adbc` ou `bcad`",
    "b) `badc` ou `bacd`",
    "c) `abdc` ou `abcd`",
    "d) `dbca` ou `dcab`",
    "e) Nenhuma das opções anteriores."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Sistemas Operacionais",
  "subarea": "Comunicação, Concorrência e Sincronização de Processos",
  "gabarito": "B",
  "atributo_rag": "fundamentos da computacao - sistemas operacionais - comunicacao, concorrencia e sincronizacao de processos"
},

{
  "id": "2004-28",
  "edicao": 2004,
  "numero": 28,
  "enunciado": "Qual das seguintes expressões posfixas é equivalente à expressão infixa $A+(B/C)*((D-E)/F)$?",
  "alternativas": [
    "a) $ABC/-DE*F+/$",
    "b) $ABC/DE-/F+*$",
    "c) $ABC/DE-F/*+$",
    "d) $ABC/D-EF*/+$",
    "e) $ABD/CE+/F-*$"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens Formais, Autômatos e Computabilidade",
  "subarea": "Linguagens Regulares, Livres-de-Contexto e Sensíveis-ao-Contexto",
  "gabarito": "C",
  "atributo_rag": "fundamentos da computacao - linguagens formais, automatos e computabilidade - linguagens regulares, livres-de-contexto e sensiveis-ao-contexto"
},

{
  "id": "2004-29",
  "edicao": 2004,
  "numero": 29,
  "enunciado": "Considerando A e B duas variáveis lógicas, a expressão `(not(A) and B) or (A and not(B))` assume o valor verdadeiro:",
  "alternativas": [
    "a) para todos os valores de A e de B",
    "b) sempre que A é igual a B",
    "c) sempre que A é diferente de B",
    "d) sempre que A é falso",
    "e) sempre que B é falso"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens de Programação",
  "subarea": "Semântica Formal",
  "gabarito": "C",
  "atributo_rag": "fundamentos da computacao - linguagens de programacao - semantica formal"
},

{
  "id": "2004-30",
  "edicao": 2004,
  "numero": 30,
  "enunciado": "Ao segmentar um processador, transformando-o num *pipeline*, obtém-se:",
  "alternativas": [
    "a) redução no número de ciclos necessários para executar uma instrução",
    "b) redução no número de ciclos necessários para executar um programa",
    "c) redução no número de ciclos necessários para tratar uma exceção",
    "d) redução no número de ciclos necessários para tratar uma interrupção",
    "e) o circuito do processador fica mais simples"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Arquitetura e Organização de Computadores",
  "subarea": "Pipeline",
  "gabarito": "B",
  "atributo_rag": "fundamentos da computacao - arquitetura e organizacao de computadores - pipeline"
},

{
  "id": "2004-31",
  "edicao": 2004,
  "numero": 31,
  "enunciado": "Um registrador de deslocamento (*shift register*) é um componente importante dos dispositivos listados a seguir:\n\n(I) porta serial (UART, ou *universal asynchronous receiver/transmitter*) \\\n(II) porta paralela \\\n(III) multiplicador sequencial \\\n(IV) somador \n\nAssinale a alternativa correta:",
  "alternativas": [
    "a) somente I e II",
    "b) somente II e IV",
    "c) somente III e IV",
    "d) somente I e III",
    "e) somente II e III"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Circuitos Digitais",
  "subarea": "Análise e Síntese de Componentes Sequenciais e de Memória",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - circuitos digitais - analise e sintese de componentes sequenciais e de memoria"
},

{
  "id": "2004-32",
  "edicao": 2004,
  "numero": 32,
  "enunciado": "Considere as seguintes afirmativas:\n\nI. Uma modificação em uma CPU fez o cycle time e o CPI aumentarem de 10% enquanto o número de instruções executadas para uma dada aplicação decresceu de 20%. Podemos concluir que o tempo de execução desta aplicação será mantido. \\\nII. Um *page fault* ocorre quando a entrada correspondente à página requerida não é encontrada no *translation lookside buffer*. \\\nIII. Para armazenar uma mesma quantidade de dados, uma cache *direct mapped* é tipicamente menor que uma *cache set associative*, assumindo blocos de mesmo tamanho. \\\nIV. Aumentando-se o tamanho do bloco de uma *cache* aumenta-se as vantagens obtidas com a localidade espacial. \\\nV. Memória virtual tipicamente usa a estratégia *write-through* ao invés de estratégia *write-back*. \n\nQuais são as alternativas verdadeiras?",
  "alternativas": [
    "a) Somente as afirmativas I, II, III e IV são verdadeiras.",
    "b) Somente as afirmativas I, III e IV são verdadeiras.",
    "c) Somente as afirmativas II, III e IV são verdadeiras.",
    "d) Somente as afirmativas III e IV são verdadeiras.",
    "e) Todas as afirmativas são verdadeiras."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Arquitetura e Organização de Computadores",
  "subarea": "Organização de Computadores: Memórias, Unidades Centrais de Processamento, Entrada e Saída",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - arquitetura e organizacao de computadores - organizacao de computadores: memorias, unidades centrais de processamento, entrada e saida"
},

{
  "id": "2004-33",
  "edicao": 2004,
  "numero": 33,
  "enunciado": "Considere as seguintes afirmações sobre um grafo $G$ com $n > 0$ vértices: \n\nI - Se $G$ e conexo o número de arestas é maior que $n$; \\\nII - $G$ será acíclico somente se o número de arestas for menor que $n$; \\\nIII - Se $G$ não tem triângulos então $G$ é planar; \\\nIV - $G$ é Euleriano se, e somente se, todo grau é par.\n\nAs afirmativas verdadeiras são:",
  "alternativas": [
    "a) I e II",
    "b) I e III",
    "c) II e III",
    "d) II e IV",
    "e) II, III e IV"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Teoria dos Grafos",
  "subarea": "Grafos orientados e não-orientados",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - teoria dos grafos - grafos orientados e nao-orientados"
},

{
  "id": "2004-34",
  "edicao": 2004,
  "numero": 34,
  "enunciado": "Um algoritmo é executado em 10 segundos para uma entrada de tamanho 50. Se o algoritmo é quadrático, quanto tempo em segundos ele gastará, aproximadamente, no mesmo computador, se a entrada tiver tamanho 100?",
  "alternativas": [
    "a) 10",
    "b) 20",
    "c) 40",
    "d) 100",
    "e) 500"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Análise de Algoritmos",
  "subarea": "Medidas Empíricas de Performance",
  "gabarito": "C",
  "atributo_rag": "fundamentos da computacao - analise de algoritmos - medidas empiricas de performance"
},

{
  "id": "2004-36",
  "edicao": 2004,
  "numero": 36,
  "enunciado": "As seguintes expressões regulares denotam as linguagens $P$, $Q$, $L$ e $R$, respectivamente: $(1 + 10)^*$, $(0 + 01)^*$, $(0 + 1)^*$, $0(11)^* + 1(00)^*$. Não se pode afirmar que:",
  "alternativas": [
    "a) $P \\cap Q \\neq \\emptyset$",
    "b) $P \\cup Q \\neq L$",
    "c) $P \\cap Q = \\{\\epsilon\\}$",
    "d) $(1 + 0)^* \\setminus P = Q$",
    "e) $R \\subset L \\setminus (P \\cup Q)$"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens Formais, Autômatos e Computabilidade",
  "subarea": "Linguagens Regulares, Livres-de-Contexto e Sensíveis-ao-Contexto",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - linguagens formais, automatos e computabilidade - linguagens regulares, livres-de-contexto e sensiveis-ao-contexto"
},

{
  "id": "2004-38",
  "edicao": 2004,
  "numero": 38,
  "enunciado": "Para um certo problema foram apresentados dois algoritmos de divisão e conquista, $A$ e $B$, cujos tempos de execução são descritos, respectivamente, por $T_A(n) = 7T_A(n/2) + n^3$ e $T_B(n) = \\alpha T_B(n/4) + n^2$. Qual é o maior valor inteiro para $\\alpha$, tal que o tempo de execução de $B$ seja assintoticamente menor que o de $A$, isto é, $T_B(n) \\in o(T_A(n))$?",
  "alternativas": [
    "a) 16",
    "b) 49",
    "c) 63",
    "d) 64",
    "e) 65"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Análise de Algoritmos",
  "subarea": "Notação “Big O”, “Little o”, “Omega” e “Theta”",
  "gabarito": "C",
  "atributo_rag": "fundamentos da computacao - analise de algoritmos - notacao “big o”, “little o”, “omega” e “theta”"
},

{
  "id": "2004-39",
  "edicao": 2004,
  "numero": 39,
  "enunciado": "Em um sistema operacional, um processo pode, em um dado instante de tempo, estar em um de três estados: em execução, pronto ou bloqueado. Considere as afirmativas abaixo sobre as possíveis transições entre estes estados que um processo pode realizar.\n\nI. Do estado em execução para o estado bloqueado \\\nII. Do estado em execução para o estado pronto \\\nIII. Do estado pronto para o estado em execução \\\nIV. Do estado pronto para o estado bloqueado \\\nV. Do estado bloqueado para o estado em execução \\\nVI. Do estado bloqueado para o estado pronto \n\nQuais são as afirmativas verdadeiras?",
  "alternativas": [
    "a) Somente as afirmativas I, II e III são verdadeiras.",
    "b) Somente as afirmativas I, II, III e VI são verdadeiras.",
    "c) Somente as afirmativas I, III, IV e VI são verdadeiras.",
    "d) Somente as afirmativas I, III, IV e V são verdadeiras.",
    "e) Todas as afirmativas são verdadeiras."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Sistemas Operacionais",
  "subarea": "Gerência de Processos/Processador",
  "gabarito": "B",
  "atributo_rag": "fundamentos da computacao - sistemas operacionais - gerencia de processos/processador"
},

{
  "id": "2005-21",
  "edicao": 2005,
  "numero": 21,
  "enunciado": "Considere uma cpu usando uma estrutura pipeline com 5 estágios (IF, ID, EX, MEM, WB) e com memórias de dados e de instruções separadas, sem mecanismo de *data forwarding*, escrita no banco de registradores na borda de subida do *clock* e leitura na borda de descida do *clock* e o conjunto de instruções a seguir:\n```\nI1: lw  $2, 100($5)\nI2: add $1, $2, $3\nI3: sub $3, $2, $1\nI4: sw  $2, 50($1)\nI5: add $2, $3, $3\nI6: sub $2, $2, $4\n```\nQuantos ciclos de *clock* são gastos para a execução deste código?",
  "alternativas": [
    "a) 30",
    "b) 17",
    "c) 16",
    "d) 11",
    "e) 10"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Arquitetura e Organização de Computadores",
  "subarea": "Pipeline",
  "gabarito": "B",
  "atributo_rag": "fundamentos da computacao - arquitetura e organizacao de computadores - pipeline"
},

{
  "id": "2005-22",
  "edicao": 2005,
  "numero": 22,
  "enunciado": "Para a representação de número ponto flutuante no padrão IEEE, quais das afirmações a seguir são verdadeiras?\n\n(I) Quando a fração e o expoente são zero, o número representado é zero. \\\n(II) Quando o expoente é zero, o número representado é desnormalizado. \\\n(III) Quando todos os bits do expoente são iguais a um e a fração é zero, o número é $+\\infty$ ou $-\\infty$.\\\n(IV) Quando todos os bits do expoente são iguais a um e a fração é diferente de zero, a representação não é número.",
  "alternativas": [
    "a) Somente as afirmações (II), (III) e (IV).",
    "b) Somente as afirmações (I), (II) e (IV).",
    "c) Somente as afirmações (I), (II) e (III).",
    "d) Somente as afirmações (I), (III) e (IV).",
    "e) Todas as afirmações."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Arquitetura e Organização de Computadores",
  "subarea": "Organização de Computadores: Memórias, Unidades Centrais de Processamento, Entrada e Saída",
  "gabarito": "E",
  "atributo_rag": "fundamentos da computacao - arquitetura e organizacao de computadores - organizacao de computadores: memorias, unidades centrais de processamento, entrada e saida"
},

{
  "id": "2005-23",
  "edicao": 2005,
  "numero": 23,
  "enunciado": "Das afirmações a seguir, sobre memória cache, quais são verdadeiras?\n\n(I) Numa estrutura totalmente associativa, um bloco de memória pode ser mapeado em qualquer slot do cache. \\\n(II) O campo tag do endereço é usado para identificar um bloco válido no cache, junto com o campo de índice. \\\n(III) Um cache de nível 2 serve para reduzir a penalidade no caso de falta no nível 1. \\\n(IV) O esquema de substituição LRU é o mais usado para a estrutura de mapeamento direto.",
  "alternativas": [
    "a) Somente as afirmações (I), (III) e (IV).",
    "b) Somente as afirmações (II), (III) e (IV).",
    "c) Somente as afirmações (I) e (II).",
    "d) Somente as afirmações (I), (II) e (III).",
    "e) Somente as afirmações (II) e (III)."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Arquitetura e Organização de Computadores",
  "subarea": "Organização de Computadores: Memórias, Unidades Centrais de Processamento, Entrada e Saída",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - arquitetura e organizacao de computadores - organizacao de computadores: memorias, unidades centrais de processamento, entrada e saida"
},

{
  "id": "2005-24",
  "edicao": 2005,
  "numero": 24,
  "enunciado": "Considere as seguintes expressões booleanas:\n\n(A) $(a \\cdot b) + (c \\cdot d \\cdot e)$ \\\n(B) $\\overline{(\\overline{a \\cdot b}) \\cdot (\\overline{c \\cdot d \\cdot e})}$ \\\n(C) $(a + b) \\cdot (c + d + e)$ \\\n(D) $\\overline{(\\overline{a + b}) + (\\overline{c + d + e})}$\n\nConsidere ainda as seguintes afirmações:\n\n(I) A é equivalente a B. \\\n(II) C é equivalente a D. \\\n(III) A é equivalente a D. \\\n(IV) B é equivalente a C.\n\nQuais das alternativas acima são verdadeiras?",
  "alternativas": [
    "a) Somente as afirmações (I) e (II) são verdadeiras.",
    "b) Somente as afirmações (I) e (III) são verdadeiras.",
    "c) Somente as afirmações (II) e (IV) são verdadeiras.",
    "d) Todas as afirmações são verdadeiras.",
    "e) Todas as afirmações são falsas."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens Formais, Autômatos e Computabilidade",
  "subarea": "Propriedades das Linguagens",
  "gabarito": "A",
  "atributo_rag": "fundamentos da computacao - linguagens formais, automatos e computabilidade - propriedades das linguagens"
},

{
  "id": "2005-25",
  "edicao": 2005,
  "numero": 25,
  "enunciado": "Uma lista ligada possui a seguinte definição de nó:\n```\ntype ap = ↑no;\n     no = record\n             info : integer;\n             link : ap\n          end;\n```\nComo o procedimento a seguir deve ser complementado para inverter uma lista ligada?\n```\nprocedure inverte(var h: ↑no);\n    var p,q : ↑no;\n    begin\n        if h <> NIL\n            then begin\n                p := h↑.link;\n                h↑.link := NIL;\n                while p <> NIL do\n                    begin\n                    ________;\n                    ________;\n                    ________;\n                    ________;\n                    end\n                end\n    end;\n```",
  "alternativas": [
    "a) `p↑.link:=h; q:=p↑.link; h:=p; p:=q;`",
    "b) `q:=p↑.link; h:=p; p:=q; p↑.link:=h;`",
    "c) `p↑.link:=h; h:=p; p:=q; q:=p↑.link;`",
    "d) `q:=p↑.link; p↑.link:=h; h:=p; p:=q;`",
    "e) `p↑.link:=h; h:=p; q:=p↑.link; p:=q;`"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Algoritmos e Estrutura de Dados",
  "subarea": "Estruturas de Dados Lineares e suas Generalizações: Listas Ordenadas, Listas Encadeadas, Pilhas e Filas",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - algoritmos e estrutura de dados - estruturas de dados lineares e suas generalizacoes: listas ordenadas, listas encadeadas, pilhas e filas"
},

{
  "id": "2005-26",
  "edicao": 2005,
  "numero": 26,
  "enunciado": "Considere um heap $H$ com 24 elementos tendo seu maior elemento na raiz. Em quantos nós de $H$ pode estar o seu segundo menor elemento?",
  "alternativas": [
    "a) 18",
    "b) 15",
    "c) 14",
    "d) 13",
    "e) 12"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Algoritmos e Estrutura de Dados",
  "subarea": "Árvores e suas Generalizações: Árvores Binárias, Árvores de Busca e Árvores Balanceadas",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - algoritmos e estrutura de dados - arvores e suas generalizacoes: arvores binarias, arvores de busca e arvores balanceadas"
},

{
  "id": "2005-27",
  "edicao": 2005,
  "numero": 27,
  "enunciado": "Dadas as seguintes características para uma Árvore B de ordem $n$:\n\n(I) Toda página contém no máximo $2n$ itens (chaves). \\\n(II) Toda página, exceto a página raiz, contém no mínimo $n$ itens. \\\n(III) Toda página ou é uma página folha, ou tem $m + 1$ descendentes, onde $m$ é o número de chaves. \\\n(IV) Todas as páginas folhas aparecem no mesmo nível.\n\nQual das seguintes opções é verdadeira:",
  "alternativas": [
    "a) As características (I), (II), (III) e (IV) são falsas.",
    "b) As características (I) e (IV) são verdadeiras.",
    "c) As características (II), (III) e (IV) são verdadeiras.",
    "d) As características (I), (II), (III) e (IV) são verdadeiras.",
    "e) As características (II), (III) e (IV) são falsas"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Algoritmos e Estrutura de Dados",
  "subarea": "Árvores e suas Generalizações: Árvores Binárias, Árvores de Busca e Árvores Balanceadas",
  "gabarito": "C",
  "atributo_rag": "fundamentos da computacao - algoritmos e estrutura de dados - arvores e suas generalizacoes: arvores binarias, arvores de busca e arvores balanceadas"
},

{
  "id": "2005-28",
  "edicao": 2005,
  "numero": 28,
  "enunciado": "Qual das seguintes afirmações é falsa?",
  "alternativas": [
    "a) Dada uma máquina de Turing $M$ com alfabeto de entrada $\\Sigma$ e uma string $w \\in \\Sigma$, não se sabe se a computação de $M$ com entrada $w$ vai ou não parar.",
    "b) O problema da parada é indecidível.",
    "c) Não existe algoritmo que determina quando uma gramática livre de contexto arbitrária é ambígua.",
    "d) Não existe autômato finito determinístico que reconheça alguma linguagem livre de contexto.",
    "e) Um autômato com duas pilhas pode ser simulado por uma máquina de Turing."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens Formais, Autômatos e Computabilidade",
  "subarea": "Problemas Indecidíveis",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - linguagens formais, automatos e computabilidade - problemas indecidiveis"
},

{
  "id": "2005-29",
  "edicao": 2005,
  "numero": 29,
  "enunciado": "Considere as seguintes afirmações:\n\n(I) O paradigma da programação funcional é baseado em funções matemáticas e composição de funções. \\\n(II) Prolog é uma linguagem de programação cuja sintaxe é uma versão simplificada do cálculo de predicados e seu método de inferência é uma forma restrita de Resolução. \\\n(III) O conceito de “Classe” foi primeiramente introduzido por Simula67. \\\n(IV) O paradigma orientado a objeto surgiu em paralelo ao desenvolvimento de Smalltalk. \\\n(V) No paradigma declarativo, programas são expressos na forma de lógica simbólica e usam um processo de inferência lógica para produzir resultados. \n\nQuais são as afirmações verdadeiras?",
  "alternativas": [
    "a) Somente (I) e (V).",
    "b) Somente (II) e (V).",
    "c) Somente (I), (II) e (V).",
    "d) Somente (I) e (II).",
    "e) Todas as afirmações são verdadeiras."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens de Programação",
  "subarea": "Paradigmas de Linguagens de Programação",
  "gabarito": "E",
  "atributo_rag": "fundamentos da computacao - linguagens de programacao - paradigmas de linguagens de programacao"
},

{
  "id": "2005-30",
  "edicao": 2005,
  "numero": 30,
  "enunciado": "Dadas duas funções $f, g : \\mathbb{N} \\rightarrow \\mathbb{R}$, dizemos que $f = o(g)$ se $\\lim_{n \\to \\infty} f(n)/g(n) = 0$. \\\nSuponha que o tempo de execução de um certo algoritmo em função do tamanho $n$ de sua entrada é descrito por $T(n) = log_2 n + o(1)$. A alternativa que melhor expressa esta afirmação é",
  "alternativas": [
    "a) para todo $\\epsilon > 0$, existe $n_0 > 0$ tal que $|T(n) - \\log_2 n| < \\epsilon$ para todo $n > n_0$.",
    "b) para todo $c > 0$, existe $n_0 > 0$ tal que $T(n) \\leq \\log_2 n + c$ para todo $n > n_0$.",
    "c) existem constantes $c > 0$ e $n_0 > 0$ tais que $T(n) \\leq c \\log_2 n$ para todo $n > n_0$.",
    "d) existem constantes $c_1 > 0$, $c_2 > 0$ e $n_0 > 0$ tais que $c_1 \\log_2 n \\leq T(n) \\leq c_2 \\log_2 n$ para todo $n > n_0$.",
    "e) existem constantes $c > 0$ e $n_0 > 0$ tais que $T(n) \\geq c \\log_2 n$ para todo $n > n_0$."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Análise de Algoritmos",
  "subarea": "Notação “Big O”, “Little o”, “Omega” e “Theta”",
  "gabarito": "A",
  "atributo_rag": "fundamentos da computacao - analise de algoritmos - notacao “big o”, “little o”, “omega” e “theta”"
},

{
  "id": "2005-31",
  "edicao": 2005,
  "numero": 31,
  "enunciado": "Considere o programa:\n```\nprogram P (input, output);\nvar m,n : integer;\nfunction FUN ( n : integer): integer;\nvar x : integer;\nbegin\n    if n < 1 then FUN := 1\n    else begin\n        x := n * FUN (n-1);\n        m := m-1;\n        FUN := m+x;\n        end;\nend;\nbegin\n    readln (m,n);\n    writeln (m, n, FUN ( n ) );\nend.\n```\nEste programa, para os valores $m = 5$ e $n = 4$, tem como resultado:",
  "alternativas": [
    "a) 5, 4, 5",
    "b) 5, 4, 120",
    "c) 1, 4, 14400",
    "d) 5, 4, 165",
    "e) 1, 4, 120"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens de Programação",
  "subarea": "Paradigmas de Linguagens de Programação",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - linguagens de programacao - paradigmas de linguagens de programacao"
},

{
  "id": "2005-32",
  "edicao": 2005,
  "numero": 32,
  "enunciado": "Considere o algoritmo `máximo(v, i, f)` que devolve o índice de um elemento máximo de $\\{v[i], \\dots, v[f]\\}$:\n```\nmáximo(v, i, f)\n    se i = f, devolva i\n    p ← máximo(v, i, ⌊(i + f) / 2⌋)\n    q ← máximo(v, ⌊(i + f) / 2⌋, f)\n    se v[p] \\geq v[q], devolva p\n    devolva q\n```\nConsiderando $n = f - i + 1$, o número de comparações entre elementos de $v$ numa execução de `máximo(v, i, f)` é",
  "alternativas": [
    "a) $n \\log_2 n$",
    "b) $n/2$",
    "c) $n - 1$",
    "d) $\\log_2 n$",
    "e) $2n$"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Análise de Algoritmos",
  "subarea": "O Uso de Relações de Recorrência para Análise de Algoritmos Recursivos",
  "gabarito": "C",
  "atributo_rag": "fundamentos da computacao - analise de algoritmos - o uso de relacoes de recorrencia para analise de algoritmos recursivos"
},

{
  "id": "2005-33",
  "edicao": 2005,
  "numero": 33,
  "enunciado": "Um algoritmo de ordenação é estável se a ordem relativa dos itens com chaves iguais mantém-se inalterada após a ordenação. Quais dos seguintes algoritmos de ordenação são estáveis?\n\n(I) BubbleSort (ordenação por bolha); \\\n(II) InsertionSort (ordenação por inserção); \\\n(III) HeapSort; \\\n(IV) QuickSort.",
  "alternativas": [
    "a) Somente (II).",
    "b) Somente (I) e (II).",
    "c) Somente (I), (II) e (III).",
    "d) Somente (II), (III) e (IV).",
    "e) Somente (I), (III) e (IV)."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Algoritmos e Estrutura de Dados",
  "subarea": "Algoritmos para Pesquisa e Ordenação",
  "gabarito": "B",
  "atributo_rag": "fundamentos da computacao - algoritmos e estrutura de dados - algoritmos para pesquisa e ordenacao"
},

{
  "id": "2005-34",
  "edicao": 2005,
  "numero": 34,
  "enunciado": "Seja $A = a_1, \\dots, a_n $ uma sequência de $n$ números, todos distintos entre si. Dados $1 \\leq i < j \\leq n$, dizemos que o par $(i, j)$ é uma inversão em $A$ se $a_j < a_i$. Qual o número máximo de inversões possível numa sequência de $n$ elementos?",
  "alternativas": [
    "a) $n$",
    "b) $\\binom{n}{2}$",
    "c) $n - 1$",
    "d) $n!$",
    "e) $n^2$"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Análise de Algoritmos",
  "subarea": "Medidas de Complexidade, Análise Assintótica de Limites de Complexidade, Técnicas de Prova de Cotas Inferiores",
  "gabarito": "B",
  "atributo_rag": "fundamentos da computacao - analise de algoritmos - medidas de complexidade, analise assintotica de limites de complexidade, tecnicas de prova de cotas inferiores"
},

{
  "id": "2005-35",
  "edicao": 2005,
  "numero": 35,
  "enunciado": "Em uma estrutura de árvore binária de busca, foram inseridos os elementos “h”, “a”, “b”, “c”, “i”, “j”, nesta sequência. O tamanho do caminho entre um nó qualquer da árvore e a raiz é dada pelo número de arestas neste caminho. Qual o tamanho do maior caminho na árvore, após a inserção dos dados acima?",
  "alternativas": [
    "a) 2",
    "b) 6",
    "c) 4",
    "d) 5",
    "e) 3"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Algoritmos e Estrutura de Dados",
  "subarea": "Árvores e suas Generalizações: Árvores Binárias, Árvores de Busca e Árvores Balanceadas",
  "gabarito": "E",
  "atributo_rag": "fundamentos da computacao - algoritmos e estrutura de dados - arvores e suas generalizacoes: arvores binarias, arvores de busca e arvores balanceadas"
},

{
  "id": "2005-36",
  "edicao": 2005,
  "numero": 36,
  "enunciado": "Quatro tarefas, A, B, C e D, estão prontas para serem executadas num único processador. Seus tempos de execução esperados são 9, 6, 3 e 5 segundos respectivamente. Em qual ordem eles devem ser executados para diminuir o tempo médio de resposta?",
  "alternativas": [
    "a) C, D, B, A",
    "b) A, B, D, C",
    "c) C, B, D, A",
    "d) A, C, D, B",
    "e) O tempo médio de resposta independe da ordem."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Sistemas Operacionais",
  "subarea": "Gerência de Processos/Processador",
  "gabarito": "A",
  "atributo_rag": "fundamentos da computacao - sistemas operacionais - gerencia de processos/processador"
},

{
  "id": "2005-37",
  "edicao": 2005,
  "numero": 37,
  "enunciado": "Qual das alternativas a seguir melhor define uma Região Crítica em Sistemas Operacionais?",
  "alternativas": [
    "a) Um trecho de programa que deve ser executado em paralelo com a Região Crítica de outro programa.",
    "b) Um trecho de programa cujas instruções podem ser executadas em paralelo e em qualquer ordem.",
    "c) Um trecho de programa onde existe o compartilhamento de algum recurso que não permite o acesso concomitante por mais de um programa.",
    "d) Um trecho de programa onde existe algum recurso cujo acesso é dado por uma prioridade.",
    "e) Um trecho de programa onde existe algum recurso a que somente o sistema operacional pode ter acesso."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Sistemas Operacionais",
  "subarea": "Comunicação, Concorrência e Sincronização de Processos",
  "gabarito": "C",
  "atributo_rag": "fundamentos da computacao - sistemas operacionais - comunicacao, concorrencia e sincronizacao de processos"
},

{
  "id": "2005-40",
  "edicao": 2005,
  "numero": 40,
  "enunciado": "Dadas as seguintes afirmações\n\n(I) Qualquer grafo conexo com $n$ vértices deve ter pelo menos $n - 1$ arestas. \\\n(II) O grafo bipartido completo $K_{m,n}$ é Euleriano desde que $m$ e $n$ sejam ímpares. \\\n(III) Em um grafo o número de vértices de grau ímpar é sempre par. \n\nSão verdadeiras:",
  "alternativas": [
    "a) Somente a afirmação (I).",
    "b) Somente as afirmações (I) e (III).",
    "c) Somente as afirmações (II) e (III).",
    "d) Somente as afirmações (I) e (II).",
    "e) Todas as afirmações."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Teoria dos Grafos",
  "subarea": "Grafos orientados e não-orientados",
  "gabarito": "B",
  "atributo_rag": "fundamentos da computacao - teoria dos grafos - grafos orientados e nao-orientados"
},

{
  "id": "2006-21",
  "edicao": 2006,
  "numero": 21,
  "enunciado": "Considere dois sistemas **A** e **B** compostos por um processador, cache e memória cuja única diferença é a cache de dados. As caches de dados possuem em comum palavras de 2 Bytes, capacidade (por exemplo, 2 KBytes), tamanho de bloco (por exemplo, 8 Bytes por linha) e são implementadas com a mesma tecnologia, porém com organizações diferentes como definidas abaixo:\n\n**(Cache de A)** Cache com mapeamento direto, utilizando políticas *write-through* e *no-write allocate* (escritas não utilizam a cache)\\\n**(Cache de B)** Cache *4-way set-associative*, utilizando políticas *write-back*, *write-allocate* e LRU\n\nConsidere as seguintes afirmações para os sistemas A e B executando um mesmo programa típico:\n\n**(I)** O sistema A deve possuir um *miss rate* maior do que B\\\n**(II)** O sistema B deve possuir um *hit rate* menor do que A \\\n**(III)** A cache de dados de A é mais rápida do que a de B\\\n**(IV)** A cache de dados de A é mais simples de ser implementada do que a de B\\\n**(V)** Em média, uma escrita de dados no sistema A é mais rápido do que em B \\\n**(VI)** As caches de dados de A e B possuem o mesmo número de linhas\n\nQuais são as afirmações verdadeiras?",
  "alternativas": [
    "a) Somente as afirmações (II), (III) e (IV) são verdadeiras",
    "b) Somente as afirmações (I), (III) e (VI) são verdadeiras",
    "c) Somente as afirmações (I), (III) e (IV) são verdadeiras",
    "d) Somente as afirmações (II), (V) e (VI) são verdadeiras",
    "e) Todas as afirmações são verdadeiras"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Arquitetura e Organização de Computadores",
  "subarea": "Organização de Computadores: Memórias, Unidades Centrais de Processamento, Entrada e Saída",
  "gabarito": "C",
  "atributo_rag": "fundamentos da computacao - arquitetura e organizacao de computadores - organizacao de computadores: memorias, unidades centrais de processamento, entrada e saida"
},

{
  "id": "2006-22",
  "edicao": 2006,
  "numero": 22,
  "enunciado": "Para a representação de número ponto flutuante no padrão IEEE, quais das afirmações abaixo são verdadeiras?\n\n**I)** a parte exponencial é polarizada\\\n**II)** existe apenas uma representação do número zero\\\n**III)** todas as representações são normalizadas\\\n**IV)** quando todos os bits da parte exponencial são iguais a um e todos os bits da parte fracionária são zeros, o número representado é +infinito ou -infinito;",
  "alternativas": [
    "a) somente I.",
    "b) somente I e IV.",
    "c) somente I, II e IV.",
    "d) somente IV.",
    "e) todas são verdadeiras."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Arquitetura e Organização de Computadores",
  "subarea": "Organização de Computadores: Memórias, Unidades Centrais de Processamento, Entrada e Saída",
  "gabarito": "B",
  "atributo_rag": "fundamentos da computacao - arquitetura e organizacao de computadores - organizacao de computadores: memorias, unidades centrais de processamento, entrada e saida"
},

{
  "id": "2006-23",
  "edicao": 2006,
  "numero": 23,
  "enunciado": "De acordo com o teorema de DeMorgan, o complemento de $X + Y \\cdot Z$ é:",
  "alternativas": [
    "a) $\\overline X + \\overline Y \\cdot \\overline Z$",
    "b) $\\overline X \\cdot \\overline Y + \\overline Z$",
    "c) $\\overline X \\cdot (\\overline Y + \\overline Z)$",
    "d) $\\overline X \\cdot \\overline Y \\cdot \\overline Z$",
    "e) $\\overline{\\overline X \\cdot \\overline Y + \\overline Z}$"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Circuitos Digitais",
  "subarea": "Famílias Lógicas",
  "gabarito": "C",
  "atributo_rag": "fundamentos da computacao - circuitos digitais - familias logicas"
},

{
  "id": "2006-24",
  "edicao": 2006,
  "numero": 24,
  "enunciado": "Num processador superescalar com emissão dinâmica de instruções para o estágio de execução, o circuito com a lógica de emissão de instruções (algoritmo de Tomasulo, ou algoritmo do placar) tem as seguintes funções:\n\n**(I)** computar, em tempo de execução, o grafo de dependências entre as instruções;\\\n**(II)** manter a ordem de execução das instruções segundo o código fonte;\\\n**(III)** trocar a ordem de execução das instruções, segundo o código fonte;\\\n**(IV)** tolerar a latência dos acessos à memória;\\\n**(V)** expor a latência dos acessos à memória.",
  "alternativas": [
    "a) Somente as alternativas (I), (II) e (IV) são verdadeiras.",
    "b) Somente as alternativas (I), (III) e (IV) são verdadeiras.",
    "c) Somente as alternativas (I), (II) e (V) são verdadeiras.",
    "d) Somente as alternativas (I), (III) e (V) são verdadeiras.",
    "e) Todas as alternativas são verdadeiras."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Arquitetura e Organização de Computadores",
  "subarea": "Processadores Superescalares e Superpipeline",
  "gabarito": "B",
  "atributo_rag": "fundamentos da computacao - arquitetura e organizacao de computadores - processadores superescalares e superpipeline"
},

{
  "id": "2006-25",
  "edicao": 2006,
  "numero": 25,
  "enunciado": "Dada uma lista linear de $n + 1$ elementos ordenados e alocados sequencialmente, qual é o número médio (número esperado) de elementos que devem ser movidos para que se faça uma inserção na lista, considerando-se igualmente prováveis as $n+1$ posições de inserção?",
  "alternativas": [
    "a) $n/2$",
    "b) $(n + 2)/2$",
    "c) $(n - 1)/2$",
    "d) $n(n + 3 + 2/n)/2$",
    "e) $(n + 1)/2$"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Análise de Algoritmos",
  "subarea": "Análise de Algoritmos Iterativos e Recursivos",
  "gabarito": "B",
  "atributo_rag": "fundamentos da computacao - analise de algoritmos - analise de algoritmos iterativos e recursivos"
},

{
  "id": "2006-26",
  "edicao": 2006,
  "numero": 26,
  "enunciado": "A respeito da representação de um grafo de $n$ vértices e $m$ arestas é correto dizer que:",
  "alternativas": [
    "a) a representação sob a forma de matriz de adjacência exige espaço $\\Omega(m^2)$.",
    "b) a representação sob a forma de listas de adjacência permite verificar a existência de uma aresta ligando dois vértices dados em tempo $O(1)$.",
    "c) a representação sob a forma de matriz de adjacência não permite verificar a existência de uma aresta ligando dois vértices dados em tempo $O(1)$.",
    "d) a representação sob a forma de listas de adjacência exige espaço $\\Omega(n + m)$.",
    "e) todas as alternativas estão corretas."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Teoria dos Grafos",
  "subarea": "Algoritmos em grafos",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - teoria dos grafos - algoritmos em grafos"
},

{
  "id": "2006-27",
  "edicao": 2006,
  "numero": 27,
  "enunciado": "Considere as afirmações abaixo, onde o alfabeto das linguagens é sempre dado por $\\Sigma = \\{0, 1\\}$.\n\n(I) A linguagem fomada por todas as cadeias $x \\in \\Sigma^*$ onde após cada dois zeros consecutivos sempre ocorrem pelo menos dois uns. Note que: os uns não precisam ser consecutivos, nem precisam ocorrer imediatamente após os zeros. \\\n(II) Se $L$ é livre de contexto e $R$ é regular, então a linguagem $\\{y |$ para algum $x, z \\in \\Sigma^*$ temos $xyz \\in L$ e $xz \\in R\\}$ é sempre livre de contexto. \\\n(III) A linguagem $\\{uv|u, v \\in \\Sigma^*$, com $u \\neq v\\}$ não é livre de contexto. \\\n(IV) Dados dois autômatos finitos, $A_1$ e $A_2$, sempre podemos decidir se são equivalentes, isto é, se aceitam a mesma linguagem. \\\n(V) Dada uma máquina de Turing, $M$, e um número inteiro $k \\geq 0$, sempre podemos decidir se a linguagem aceita por $M$ tem pelo menos $k$ cadeias distintas.\n\nEscolha a afirmação correta:",
  "alternativas": [
    "a) As afirmações (II), (III) e (IV) são verdadeiras.",
    "b) Há duas afirmações falsas entre (I), (II) e (V).",
    "c) Há duas afirmações verdadeiras entre (I), (IV) e (V).",
    "d) Entre todas as cinco afirmações, pelo menos 3 (três) são falsas.",
    "e) Não é possível determinar se a afirmação (V) é verdadeira ou falsa, para uma máquina de Turing genérica e um $k \\geq 0$ genérico."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens Formais, Autômatos e Computabilidade",
  "subarea": "Problemas Indecidíveis",
  "gabarito": "ANULADA",
  "atributo_rag": "fundamentos da computacao - linguagens formais, automatos e computabilidade - problemas indecidiveis"
},

{
  "id": "2006-28",
  "edicao": 2006,
  "numero": 28,
  "enunciado": "Qual das seguintes afirmações é falsa?",
  "alternativas": [
    "a) Todo autômato finito não determinístico com transições vazias pode ser reduzido para um autômato finito determinístico.",
    "b) Nem todo autômato com pilha não determinístico pode ser reduzido para um autômato com pilha determinístico.",
    "c) Toda máquina de Turing com $N \\geq 1$ fitas pode ser reduzida para uma máquina de Turing padrão.",
    "d) Para se provar que uma linguagem é regular basta usar o lema do bombeamento (*pumping lemma*) de linguagens regulares.",
    "e) Máquinas de Turing aceitam linguagens geradas por gramáticas irrestritas."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens Formais, Autômatos e Computabilidade",
  "subarea": "Autômatos de Estados Finitos Determinístico e não Determinístico",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - linguagens formais, automatos e computabilidade - automatos de estados finitos deterministico e nao deterministico"
},

{
  "id": "2006-29",
  "edicao": 2006,
  "numero": 29,
  "enunciado": "Considere a função Pot que calcula $x^n$ , para $x$ real e $n$ inteiro:\n```\nFunction Pot(x: real; n: integer): real;\n   begin\n      if x = 0\n      then\n         Pot := 0\n      else \n         if n = 0\n         then\n            Pot := 1\n         else \n            if n < 0\n            then\n               Pot := 1/Pot(x,abs(n))\n            else \n               if odd(n)\n               then\n                  Pot := x * sqr(Pot(x,(n-1) div 2))\n               else\n                  Pot := sqr(Pot(x,n div 2))\n      end;\n```\nSeja $T(n)$ o tempo de execução da função Pot para as entradas $x$ e $n$. A ordem de $T(n)$ é",
  "alternativas": [
    "a) $T(n) = O(1)$",
    "b) $T(n) = O(n \\log n)$",
    "c) $T(n) = O(n)$",
    "d) $T(n) = O(\\log n)$",
    "e) $T(n) = O(n^2)$"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Análise de Algoritmos",
  "subarea": "O Uso de Relações de Recorrência para Análise de Algoritmos Recursivos",
  "gabarito": "B",
  "atributo_rag": "fundamentos da computacao - analise de algoritmos - o uso de relacoes de recorrencia para analise de algoritmos recursivos"
},

{
  "id": "2006-30",
  "edicao": 2006,
  "numero": 30,
  "enunciado": "Seja $P$ o problema de ordenar, usando comparação, $n \\geq 1$ elementos e $\\mathcal{C}$ a classe dos algoritmos que resolvem $P$. O limitante inferior de $\\mathcal{C}$ é:",
  "alternativas": [
    "a) $\\Omega(1)$",
    "b) $\\Omega(\\log n)$",
    "c) $\\Omega(n)$",
    "d) $\\Omega(n \\log n)$",
    "e) $\\Omega(n^2)$"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Análise de Algoritmos",
  "subarea": "Medidas de Complexidade, Análise Assintótica de Limites de Complexidade, Técnicas de Prova de Cotas Inferiores",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - analise de algoritmos - medidas de complexidade, analise assintotica de limites de complexidade, tecnicas de prova de cotas inferiores"
},

{
  "id": "2006-31",
  "edicao": 2006,
  "numero": 31,
  "enunciado": "Quais algoritmos de ordenação têm complexidade $\\mathcal{O}(n \\log n)$ para o melhor caso, onde $n$ é o número de elementos a ordenar.",
  "alternativas": [
    "a) Insertion Sort e Quicksort",
    "b) Quicksort e Heapsort",
    "c) Bubble Sort e Insertion Sort",
    "d) Heapsort e Insertion Sort",
    "e) Quicksort e Bubble Sort"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Análise de Algoritmos",
  "subarea": "Medidas de Complexidade, Análise Assintótica de Limites de Complexidade, Técnicas de Prova de Cotas Inferiores",
  "gabarito": "B",
  "atributo_rag": "fundamentos da computacao - analise de algoritmos - medidas de complexidade, analise assintotica de limites de complexidade, tecnicas de prova de cotas inferiores"
},

{
  "id": "2006-32",
  "edicao": 2006,
  "numero": 32,
  "enunciado": "Qual dos seguintes mecanismos é o menos recomendado para se implementar regiões críticas em sistemas operacionais?",
  "alternativas": [
    "a) Semáforo",
    "b) Espera ocupada",
    "c) Troca de mensagens",
    "d) Monitores",
    "e) Variáveis de condição"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Sistemas Operacionais",
  "subarea": "Comunicação, Concorrência e Sincronização de Processos",
  "gabarito": "B",
  "atributo_rag": "fundamentos da computacao - sistemas operacionais - comunicacao, concorrencia e sincronizacao de processos"
},

{
  "id": "2006-33",
  "edicao": 2006,
  "numero": 33,
  "enunciado": "Como o procedimento abaixo deve ser completado para que ele seja capaz de ordenar um vetor de $n$ elementos $(n \\leq 100)$ em ordem crescente.\n```\n....\ntype VetorType = array[0..100] of integer;\nprocedure Ordena(n: integer; var a: VetorType);\n   var i,j,x: integer;\n   begin\n      for i := 2 to n do \n         begin\n            x := a[i];\n            j := i - 1;\n            ___________________;\n            While x < a[j] do \n               begin\n                  a[i+j] := a[j];\n                  __________________;\n               end;\n            ____________________;\n         end;\n       end;\n```",
  "alternativas": [
    "a) a[j] := x; j := j - 1; a[j] := x;",
    "b) a[i] := x; j := j + 1; a[i] := x;",
    "c) a[0] := x; j := j - 1; a[j+1] := x;",
    "d) a[i] := x; j := j - 1; a[j+1] := x;",
    "e) a[0] := x; j := j + 1; a[j] := x;"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Algoritmos e Estrutura de Dados",
  "subarea": "Algoritmos para Pesquisa e Ordenação",
  "gabarito": "C",
  "atributo_rag": "fundamentos da computacao - algoritmos e estrutura de dados - algoritmos para pesquisa e ordenacao"
},

{
  "id": "2006-34",
  "edicao": 2006,
  "numero": 34,
  "enunciado": "Sejam [6, 4, 2, 1, 3, 5, 8, 7, 9] e [7, 4, 3, 2, 1, 6, 5, 10, 9, 8, 11] as sequências produzidas pelo percurso em pré-ordem das árvores binárias de busca T1 e T2, respectivamente. Assina-le a afirmação incorreta:",
  "alternativas": [
    "a) T1 possui altura mínima dentre todas as árvores binárias com 9 nós.",
    "b) T1 é uma árvore AVL.",
    "c) T1 é uma árvore rubro-negra.",
    "d) T2 possui altura mínima dentre todas as árvores binárias com 11 nós.",
    "e) T2 é uma árvore rubro-negra."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Algoritmos e Estrutura de Dados",
  "subarea": "Árvores e suas Generalizações: Árvores Binárias, Árvores de Busca e Árvores Balanceadas",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - algoritmos e estrutura de dados - arvores e suas generalizacoes: arvores binarias, arvores de busca e arvores balanceadas"
},

{
  "id": "2006-35",
  "edicao": 2006,
  "numero": 35,
  "enunciado": "Que valores são impressos quando o seguinte algoritmo, escrito em Pascal, é executado?\n```\nProgram P;\nvar a,b: integer;\nProcedure Mist(x: integer; var y: integer);\nbegin\n      x:=y+a+1;\n      y :=x+b+1\nend \nbegin\n      a:=1; b:=2;\n      Mist(a,b);\n      Write(a,b)\nend.\n```",
  "alternativas": [
    "a) 1 2",
    "b) 3 1",
    "c) 3 5",
    "d) 1 7",
    "e) 4 7"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens de Programação",
  "subarea": "Paradigmas de Linguagens de Programação",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - linguagens de programacao - paradigmas de linguagens de programacao"
},

{
  "id": "2006-36",
  "edicao": 2006,
  "numero": 36,
  "enunciado": "Seja $G = (V, E)$ um grafo simples conexo não-euleriano. Queremos construir um grafo $H$ que seja euleriano e que contenha $G$ como subgrafo. Considere os seguintes possíveis processos de construção:\n\n(I) Acrescenta-se um novo vértice, ligando-o a cada vértice de $G$ por uma aresta.\\\n(II) Acrescenta-se um novo vértice, ligando-o a cada vértice de grau ímpar de $G$ por uma aresta.\\\n(III) Cria-se uma nova cópia $G'$ do grafo $G$ e acrescenta-se uma aresta ligando cada par de vértices correspondentes.\\\n(IV) Escolhe-se um vértice arbitrário de $G$ e acrescentam-se arestas ligando este vértice a todo vértice de grau ímpar de $G$.\\\n(V) Duplicam-se todas as arestas de $G$.\\\n(VI) Acrescentam-se arestas a $G$ até se formar o grafo completo com $\\left| V\\right|$ vértices.\n\nQuas dos processos acima sempre constroem corretamente o grafo $H$?",
  "alternativas": [
    "a) Somente (II) e (IV)",
    "b) Somente (II), (IV) e (V)",
    "c) Somente (III), (V) e (VI)",
    "d) Somente (II), (IV), (V) e (VI)",
    "e) Somente (I), (III), (IV) e (V)"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Teoria dos Grafos",
  "subarea": "Grafos orientados e não-orientados",
  "gabarito": "B",
  "atributo_rag": "fundamentos da computacao - teoria dos grafos - grafos orientados e nao-orientados"
},

{
  "id": "2006-37",
  "edicao": 2006,
  "numero": 37,
  "enunciado": "Considere o programa:\n```\nprogram p;\n   var n: integer;\n   function f(n: integer; var k: integer): integer;\n      var p,q:integer;\n   begin (* f *)\n      if n < 2\n         then begin\n               f :=n;\n               k := 0\n            end\n         else begin\n               f := f(n-1, p) + f(n-2, q);\n               k := p + q + 1 \n            end;\n      write(n,' ',k,'; ')\n   end (* f *); \n   begin\n   n := 4; \n   write (f (3,n) ,n)\n   end.\n```\nQuais os valores impressos pelo programa?",
  "alternativas": [
    "a) 1 0; 0 0; 2 1; 1 0; 3 2; 2 4",
    "b) 1 4; 0 0; 2 1; 1 0; 3 2; 2 2",
    "c) 1 0; 0 0; 2 1; 1 0; 3 2; 2 2",
    "d) 1 0; 0 0; 2 1; 1 0; 3 2; 2 3",
    "e) 1 4; 0 4; 2 4; 1 4; 3 4; 2 4"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens de Programação",
  "subarea": "Paradigmas de Linguagens de Programação",
  "gabarito": "C",
  "atributo_rag": "fundamentos da computacao - linguagens de programacao - paradigmas de linguagens de programacao"
},

{
  "id": "2006-38",
  "edicao": 2006,
  "numero": 38,
  "enunciado": "Considere o programa:\n```\nprogram p;\n   var n: integer;\n   function f(n: integer; var k: integer): integer;\n      var p,q:integer;\n   begin (* f *)\n      if n < 2\n         then begin\n               f :=n;\n               k := 0\n            end\n         else begin\n               f := f(n-1, p) + f(n-2, q);\n               k := p + q + 1 \n            end;\n      write(n,' ',k,'; ')\n   end (* f *); \n   begin\n   n := 4; \n   write (f (3,n) ,n)\n   end.\n```\nA complexidade desse Algoritmo é:",
  "alternativas": [
    "a) $O(\\log_2 n)$",
    "b) $O(n)$",
    "c) $O(n \\log_2 n)$",
    "d) $\\Omega(n \\log_2 n)$",
    "e) $\\Omega(n^2)$"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Análise de Algoritmos",
  "subarea": "O Uso de Relações de Recorrência para Análise de Algoritmos Recursivos",
  "gabarito": "C",
  "atributo_rag": "fundamentos da computacao - analise de algoritmos - o uso de relacoes de recorrencia para analise de algoritmos recursivos"
},

{
  "id": "2006-39",
  "edicao": 2006,
  "numero": 39,
  "enunciado": "O uso de associações é muito importante em programação orientada a objetos. Considere agora as afirmações abaixo, relativas ao uso de associações:\n\nI. A multiplicidade de uma associação é uma restrição imposta a essa associação que define o número de instâncias das classes envolvidas nesse relacionamento. \\\nII. A ordenação não é considerada uma restrição a associações, já que ordena as instâncias envolvidas no relacionamento que caracteriza a associação em questão. \\\nIII. O uso de papéis só é permitido em associações reflexivas binárias, pois em outros tipos de associações os papéis causam problemas na modelagem das classes.\n\nBaseado nas afirmações acima, escolha a opção correta:",
  "alternativas": [
    "a) As três afirmações são falsas.",
    "b) As três afirmações são verdadeiras.",
    "c) Apenas a afirmação I é verdadeira.",
    "d) As afirmações I e II são verdadeiras.",
    "e) Apenas a afirmação III é verdadeira."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens de Programação",
  "subarea": "Paradigmas de Linguagens de Programação",
  "gabarito": "C",
  "atributo_rag": "fundamentos da computacao - linguagens de programacao - paradigmas de linguagens de programacao"
},

{
  "id": "2006-40",
  "edicao": 2006,
  "numero": 40,
  "enunciado": "Na modelagem de classes usando UML (*Unified Modeling Language*) é recomendável especificar a multiplicidade dos relacionamentos (associações). Um tipo muito comum de multiplicidade é a um-para-muitos. Nos casos abaixo, diga qual é o caso que se trata de uma associação um-para-muitos, seguindo a notação ”associação (classe1, classe2)”.",
  "alternativas": [
    "a) Votar (Presidente, Eleitor)",
    "b) Casar (Marido, Esposa)",
    "c) Torcer (Time, Torcedor)",
    "d) Escrever (Livro, Autor)",
    "e) Assinar (Revista, Assinante)"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Técnicas de Programação",
  "subarea": "Metodologia de desenvolvimento de programas",
  "gabarito": "A",
  "atributo_rag": "fundamentos da computacao - tecnicas de programacao - metodologia de desenvolvimento de programas"
},

{
  "id": "2007-21",
  "edicao": 2007,
  "numero": 21,
  "enunciado": "Um processador tem a seguinte hierarquia de memória: uma *cache* com latência de acesso de $1 ns$ e uma memória principal com latência de acesso de $100 ns$. O acesso à memória principal somente é realizado após o valor não ser encontrado na *cache*.\\\nA **MAIOR** taxa de *cache miss* aceitável para que o tempo médio de acesso à memória seja menor ou igual à $2ns$ é",
  "alternativas": [
    "a) 10%",
    "b) 5%",
    "c) 50%",
    "d) 1%",
    "e) 2%"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Arquitetura e Organização de Computadores",
  "subarea": "Organização de Computadores: Memórias, Unidades Centrais de Processamento, Entrada e Saída",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - arquitetura e organizacao de computadores - organizacao de computadores: memorias, unidades centrais de processamento, entrada e saida"
},

{
  "id": "2007-23",
  "edicao": 2007,
  "numero": 23,
  "enunciado": "Seja $T$ uma árvore AVL vazia. Supondo que os elementos 5, 10, 11, 7, 9, 3 e 6 sejam inseridos nessa ordem em $T$, indique a sequência abaixo que corresponde a um percurso de $T$ em pós-ordem.",
  "alternativas": [
    "a) 3, 5, 6, 7, 9, 10 e 11.",
    "b) 7, 5, 3, 6, 10, 9 e 11.",
    "c) 9, 10, 7, 6, 11, 5 e 3.",
    "d) 11, 10, 9, 7, 6, 5 e 3.",
    "e) 3, 6, 5, 9, 11, 10 e 7."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Algoritmos e Estrutura de Dados",
  "subarea": "Árvores e suas Generalizações: Árvores Binárias, Árvores de Busca e Árvores Balanceadas",
  "gabarito": "E",
  "atributo_rag": "fundamentos da computacao - algoritmos e estrutura de dados - arvores e suas generalizacoes: arvores binarias, arvores de busca e arvores balanceadas"
},

{
  "id": "2007-24",
  "edicao": 2007,
  "numero": 24,
  "enunciado": "Considere um arquivo texto que contenha uma mensagem de 10.000 caracteres utilizando os caracteres A, B e C, com probabilidades 0,1, 0,1 e 0,8 respectivamente. Ao utilizar o *algoritmo de Huffman* para compressão/codificação do referido texto, as seguintes afirmativas são apresentadas.\n\nI. O comprimento médio dos códigos para os referidos caracteres é 1, 2. \\\nII. Se forem utilizados todos os pares possíveis de símbolos para a construção da\nárvore de *Huffman*, então o comprimento médio dos códigos para os referidos pares é menor que 1, 2 por caractere. \\\nIII. A codificação de *Huffman* a partir de todos os pares possíveis de caracteres sempre produz códigos de menor comprimento médio.\n\nOs dados acima permitem afirmar que",
  "alternativas": [
    "a) apenas a afirmativa I é verdadeira.",
    "b) apenas as afirmativas I e II são verdadeiras.",
    "c) apenas as afirmativas I e III são verdadeiras.",
    "d) apenas as afirmativas II e III são verdadeiras.",
    "e) todas as afirmativas são verdadeiras."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Algoritmos e Estrutura de Dados",
  "subarea": "Metodologia de Desenvolvimento de Algoritmos",
  "gabarito": "B",
  "atributo_rag": "fundamentos da computacao - algoritmos e estrutura de dados - metodologia de desenvolvimento de algoritmos"
},

{
  "id": "2007-25",
  "edicao": 2007,
  "numero": 25,
  "enunciado": "Considerando as diferenças existentes entre a execução de um algoritmo sequencial e a execução de um algoritmo distribuído, analise as seguintes afirmativas.\n\nI. Somente na execução sequencial de um algoritmo existe a possibilidade de ocorrer um *deadlock*. \\\nII. Um algoritmo sequencial apresenta mais de uma execução possível para uma dada entrada. \\\nIII. Um algoritmo distribuído tem sua complexidade medida pela quantidade de mensagens transmitidas durante sua execução. \\\nIV. A execução de um algoritmo distribuído pode ser não determinística.\n\nA análise permite concluir que",
  "alternativas": [
    "a) todas as afirmativas são falsas.",
    "b) todas as afirmativas são verdadeiras.",
    "c) apenas as afirmativas I e II são verdadeiras.",
    "d) apenas as afirmativas I e IV são verdadeiras.",
    "e) apenas a afirmativa IV é verdadeira."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Sistemas Operacionais",
  "subarea": "Comunicação, Concorrência e Sincronização de Processos",
  "gabarito": "E",
  "atributo_rag": "fundamentos da computacao - sistemas operacionais - comunicacao, concorrencia e sincronizacao de processos"
},

{
  "id": "2007-26",
  "edicao": 2007,
  "numero": 26,
  "enunciado": "Seja a linguagem formal $L = \\{a^{n}b^{2n} c, n \\ge 0\\}$ . Analise as seguintes assertivas.\n\nI. $L$ é uma linguagem livre de contexto.\\\nII. A gramática $G = ( \\{S, X \\}, \\{a, b, c\\}, \\{S\\rightarrow Xc, X \\rightarrow aXbb \\vert\\varepsilon ,S)$ gera a linguagem $L$.\\\nIII. $L$ não pode ser reconhecida por um autômato com pilha.\n\nA análise permite concluir que estão **CORRETAS**",
  "alternativas": [
    "a) apenas as assertivas I e II.",
    "b) apenas as assertivas I e III.",
    "c) apenas as assertivas II e III.",
    "d) todas as assertivas.",
    "e) nenhuma das assertivas."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens Formais, Autômatos e Computabilidade",
  "subarea": "Linguagens Regulares, Livres-de-Contexto e Sensíveis-ao-Contexto",
  "gabarito": "A",
  "atributo_rag": "fundamentos da computacao - linguagens formais, automatos e computabilidade - linguagens regulares, livres-de-contexto e sensiveis-ao-contexto"
},

{
  "id": "2007-27",
  "edicao": 2007,
  "numero": 27,
  "enunciado": "Assinale a alternativa que apresenta a afirmativa FALSA.",
  "alternativas": [
    "a) Uma linguagem $L$ é aceita por uma *Máquina de Turing* não determinística com $k$ fitas, $m$ dimensões, $n$ cabeçotes de leitura e gravação por fita se, e somente se, ela é aceita por uma *Máquina de Turing* determinística com uma fita infinita em apenas um sentido e um cabeçote de leitura e gravação.",
    "b) Um problema é dito ser decidível se a linguagem associada a esse problema é *recursiva*.",
    "c) O conjunto de todos os programas que páram para uma dada entrada é um *conjunto recursivo* mas não recursivamente enumerável.",
    "d) Uma função é *parcialmente computável* se, e somente se, ela pode ser obtida a partir de *funções iniciais* (por exemplo, sucessor, zero e pro jeção) por um número finito de aplicações de *composição*, *recursão primitiva* e *minimalização*.",
    "e) Uma *Máquina de Turing Universal* $U$ toma como argumentos uma descrição de uma *Máquina de Turing* qualquer $M$ e uma entrada $x$ para $M$, e executa as mesmas operações sobre $x$ que seriam executadas por $M$, ou seja, $U$ simula $M$ sobre $x$."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens Formais, Autômatos e Computabilidade",
  "subarea": "Máquina de Turing",
  "gabarito": "C",
  "atributo_rag": "fundamentos da computacao - linguagens formais, automatos e computabilidade - maquina de turing"
},

{
  "id": "2007-28",
  "edicao": 2007,
  "numero": 28,
  "enunciado": "Considere o seguinte enunciado e as possibilidades de sua complementação.\n\nA regra de inferência utilizada pela linguagem Prolog, denominada “regra de resolução”,\n\nI. opera com fórmulas contendo apenas quantificadores existenciais. \\\nII. é capaz de reduzir fórmulas quantificadas à suas correspondentes formas clausais. \\\nIII. opera sobre fórmulas em forma clausal pelo corte de literais de sinais opostos. \\\nIV. opera sobre fórmulas em forma clausal pelo corte de literais de mesmo sinal. \\\nV. produz deduções que evitam a construção de árvores de dedução lineares.\n\nCompleta(m) CORRETAMENTE o enunciado acima",
  "alternativas": [
    "a) apenas o item II.",
    "b) apenas o item III.",
    "c) apenas o item IV.",
    "d) apenas os itens I e II.",
    "e) apenas os itens III e V."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens Formais, Autômatos e Computabilidade",
  "subarea": "Funções Recursivas",
  "gabarito": "B",
  "atributo_rag": "fundamentos da computacao - linguagens formais, automatos e computabilidade - funcoes recursivas"
},

{
  "id": "2007-29",
  "edicao": 2007,
  "numero": 29,
  "enunciado": "Analise as seguintes afirmativas.\n\nI. Encapsulamento é a capacidade de uma operação atuar de modos diversos em classes diferentes. \\\nII. Polimorfismo é o compartilhamento de atributos e métodos entre classes com base em um relacionamento hierárquico. \\\nIII. Herança consiste no processo de ocultação dos detalhes internos de implementação de um objeto. \\\nIV. Sobreposição é a redefinição das funções de um método herdado. Os métodos apresentam assinaturas iguais. \\\nV. Em JAVA, todos os métodos numa classe abstrata devem ser declarados como abstratos.\n\nA partir da análise, pode-se concluir que",
  "alternativas": [
    "a) apenas a afirmativa IV está correta.",
    "b) apenas as afirmativas III e IV estão corretas.",
    "c) apenas as afirmativas I, IV e V estão corretas.",
    "d) apenas as afirmativas I, III e V estão corretas.",
    "e) todas as afirmativas são falsas."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens de Programação",
  "subarea": "Paradigmas de Linguagens de Programação",
  "gabarito": "A",
  "atributo_rag": "fundamentos da computacao - linguagens de programacao - paradigmas de linguagens de programacao"
},

{
  "id": "2007-30",
  "edicao": 2007,
  "numero": 30,
  "enunciado": "Suponha que tenhamos à nossa disposição um algoritmo `MULT` que efetua a multiplicação de duas matrizes $ A_{p \\times q} $ e $ B_{q \\times r} $ dadas como entrada com $ p \\times q \\times r $ multiplicações de escalares. Esse algoritmo é, então, usado para definir o seguinte problema de decisão chamado `MULTMAT`:\n\n**ENTRADA**: vetor $ p[0], p[1], \\ldots, p[n] $, um inteiro positivo $ m $.\\\n**QUESTÃO**: existe uma sequência de multiplicações de duas matrizes com o algoritmo `MULT` que produz o resultado de $ A_1A_2 \\cdots A_n $, em que cada $ A_i $, para todo $ i \\in \\{ 1, 2, \\ldots, n \\} $, é uma matriz de dimensões $ p[i - 1] \\times p[i] $, com $ m $ multiplicações de escalares no máximo?\n\nConsidere as seguintes afirmativas.\n\n**I.** O algoritmo abaixo demonstra que `MULTMAT` está na classe de problemas $ P $.\n```\nChamada: MULTMAT(p, m)\n1: q ← Q(p, 0, n)\n2: se q \\leq m então\n3:     retorna “Sim”\n4: retorna “Não”\n\nChamada: Q(p, i, j)\n5: se i = j então\n6:     retorna 0\n7: q ← \\infty\n8: para k ← i, i + 1, ..., j - 1 faça\n9:     r ← Q(p, i, k) + Q(p, k + 1, j) + p[i - 1]p[k]p[j]\n10:    se r < q então\n11:        q ← r\n12: retorna q\n```\n**II.** `MULTMAT` está na classe de problemas $ NP $.\\\n**III.** Se I e II são corretas, então $P = NP$.\n\nAssinale a alternativa que apresenta a(s) afirmativa(s) CORRETA(S).",
  "alternativas": [
    "a) Somente a afirmativa I.",
    "b) Somente a afirmativa II.",
    "c) Somente a afirmativa III.",
    "d) Somente as afirmativas II e III.",
    "e) Somente as afirmativas I, II e III."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Análise de Algoritmos",
  "subarea": "O Uso de Relações de Recorrência para Análise de Algoritmos Recursivos",
  "gabarito": "B",
  "atributo_rag": "fundamentos da computacao - analise de algoritmos - o uso de relacoes de recorrencia para analise de algoritmos recursivos"
},

{
  "id": "2007-31",
  "edicao": 2007,
  "numero": 31,
  "enunciado": "Considere o problema do caixeiro viajante, definido como se segue.\\\nSejam $S$ um conjunto de n $n \\geq 0$ cidades, e $d_{ij} > 0$ a distância entre as cidades $i$ e $j$, $i, j \\in S, i \\neq j$. Define-se um *percurso fechado* como sendo um percurso que parte de uma cidade $i \\in S$, passa exatamente uma vez por cada cidade de $S \\setminus \\{i\\}$, e retorna à cidade de origem. A distância de um percurso fechado é definida como sendo a soma das distâncias entre cidades consecutivas no percurso. Deseja-se encontrar um percurso fechado de distância mínima. Suponha um algoritmo guloso que, partindo da cidade 1, move-se para a cidade mais próxima ainda não visitada e que repita esse processo até passar por todas as cidades, retornando à cidade 1.\\\nConsidere as seguintes afirmativas.\n\nI. Todo percurso fechado obtido com esse algoritmo tem distância mínima.\\\nII. O problema do caixeiro viajante pode ser resolvido com um algoritmo de complexidade linear no número de cidades.\\\nIII. Dado que todo percurso fechado corresponde a uma permutação das cidades, existe um algoritmo de complexidade exponencial no número de cidades para o problema do caixeiro viajante.\n\nEm relação a essas afirmativas, pode-se afirmar que",
  "alternativas": [
    "a) I é falsa e III é correta.",
    "b) I, II e III são corretas.",
    "c) apenas I e II são corretas.",
    "d) apenas I e III são falsas.",
    "e) I, II e III são falsas."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Algoritmos e Estrutura de Dados",
  "subarea": "Técnicas de Projeto de Algoritmos: Método da Força Bruta, Pesquisa Exaustiva, Algoritmo Guloso, Dividir e Conquistar, “Backtracking” e Heurísticas",
  "gabarito": "A",
  "atributo_rag": "fundamentos da computacao - algoritmos e estrutura de dados - tecnicas de projeto de algoritmos: metodo da forca bruta, pesquisa exaustiva, algoritmo guloso, dividir e conquistar, “backtracking” e heuristicas"
},

{
  "id": "2007-33",
  "edicao": 2007,
  "numero": 33,
  "enunciado": "Seja $L = < r_1, \\dots, r_n >$ uma lista qualquer de inteiros não necessariamente distintos.\n\nA esse respeito, assinale a alternativa **INCORRETA**.",
  "alternativas": [
    "a) Existe um algoritmo determinístico ótimo de complexidade $0(n)$ para selecionar o maior elemento de $L$.",
    "b) Existe um algoritmo determinístico de complexidade $O(n \\log n)$ para selecionar,\npara $1\\leq i \\leq n$, o *i-ésimo* menor elemento de $L$.",
    "c) Se existe um algoritmo linear para selecionar o *i-ésimo* menor elemento de $L$,\nentão, usando esse algoritmo, é possível pro jetar um algoritmo linear para ordenar $L$ em ordem não crescente.",
    "d) Existe um algoritmo linear para determinar o terceiro maior elemento de $L$.",
    "e) Existe um algoritmo que, percorrendo uma única vez $L$, pode determinar o menor e o maior elemento de $L$."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Análise de Algoritmos",
  "subarea": "Análise de Algoritmos Iterativos e Recursivos",
  "gabarito": "C",
  "atributo_rag": "fundamentos da computacao - analise de algoritmos - analise de algoritmos iterativos e recursivos"
},

{
  "id": "2007-34",
  "edicao": 2007,
  "numero": 34,
  "enunciado": "Seja $V = < v_1 , \\dots , v_n >$ uma lista qualquer de inteiros distintos que se deseja ordenar em ordem não descrescente. Analise as seguintes afirmativas.\n\nI. Considere o algoritmo *Quicksort*. Suponha uma execução do algoritmo sobre $V$ tal que a cada sorteio do pivot, a mediana do (sub)problema em questão é escolhida. Então, a complexidade dessa execução é $O(n \\lg n)$. \\\nII. Considere o algoritmo *Quicksort*. Suponha uma execução do algoritmo sobre $V$ tal que a cada sorteio do pivot, os dois subproblemas gerados têm tamanho $\\frac{1}{10}$ e $\\frac{9}{10}$ respectivamente do tamanho do (sub)problema em questão. Então, a complexidade dessa execução é $O(n^2)$. \\\nIII. Considere o algoritmo *Mergesort*. A complexidade do pior caso do algoritmo é\n$O(n \\lg n)$ e a complexidade do melhor caso (vetor já está ordenado) é $O(n)$. \\\nIV. Considere o algoritmo *Heapsort*. A complexidade do pior caso do algoritmo é\n$O(n \\lg n)$ e a complexidade do melhor caso (vetor já está ordenado) é $O(n)$. \\\nV. Se para todo $i$, $v_i$ é $O(n)$, então a complexidade do algoritmo *Bucketsort* é $O(n)$.\n\nA partir dos dados acima, pode-se concluir que estão CORRETAS",
  "alternativas": [
    "a) apenas as afirmativas I e II.",
    "b) apenas as afirmativas I, II e III.",
    "c) apenas as afirmativas I, III e V.",
    "d) apenas as afirmativas III, IV e V.",
    "e) apenas as afirmativas I e V."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Algoritmos e Estrutura de Dados",
  "subarea": "Algoritmos para Pesquisa e Ordenação",
  "gabarito": "E",
  "atributo_rag": "fundamentos da computacao - algoritmos e estrutura de dados - algoritmos para pesquisa e ordenacao"
},

{
  "id": "2007-35",
  "edicao": 2007,
  "numero": 35,
  "enunciado": "Analise as seguintes afirmativas e assinale a alternativa INCORRETA.",
  "alternativas": [
    "a) O acesso a setores localizados em sequência em uma mesma trilha de um disco é mais rápido do que acessar o mesmo número de setores em trilhas diferentes, devido ao menor número tanto de deslocamentos do cabeçote quanto de rotações no disco.",
    "b) Na paginação por demanda, não é necessário que o processo inteiro se encontre em memória para execução.",
    "c) O escalonamento de operações de entrada e sída em um disco rígido pode ser utilizado para aumentar o desempenho. Porém, algoritmos como o SSTF (*Shortest Seek Time First*) podem fazer com que requisições esperem indefinidamente.",
    "d) O escalonamento de processos por prioridades utiliza múltiplas filas e garante que todos os processos recebam sua fatia de tempo.",
    "e) O surgimento do conceito de interrupções, juntamente com dispositivos de acesso não-sequencial, foi primordial para a evolução que levou aos sistemas multiprogramados."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Arquitetura e Organização de Computadores",
  "subarea": "Organização de Computadores: Memórias, Unidades Centrais de Processamento, Entrada e Saída",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - arquitetura e organizacao de computadores - organizacao de computadores: memorias, unidades centrais de processamento, entrada e saida"
},

{
  "id": "2007-36",
  "edicao": 2007,
  "numero": 36,
  "enunciado": "Agregações são muito importantes em programação orientada a objetos.\n\nAnalise as afirmativas abaixo relativas ao uso de agregações.\n\nI. Uma agregação é formada por agregado (todo) e componentes (partes). \\\nII. Uma agregação não é transitiva e, portanto, não pode modelar situações desse tipo. \\\nIII. A simetria é uma das principais características de uma agregação.\n\nA análise permite concluir que",
  "alternativas": [
    "a) as três afirmativas são falsas.",
    "b) as três afirmativas são verdadeiras.",
    "c) apenas a afirmativa I é verdadeira.",
    "d) apenas as afirmativas I e II são verdadeiras.",
    "e) apenas a afirmativa III é verdadeira."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens de Programação",
  "subarea": "Paradigmas de Linguagens de Programação",
  "gabarito": "C",
  "atributo_rag": "fundamentos da computacao - linguagens de programacao - paradigmas de linguagens de programacao"
},

{
  "id": "2007-37",
  "edicao": 2007,
  "numero": 37,
  "enunciado": "Multiplicidade é um conceito muito importante na modelagem de classes em programação orientada a objetos. Por isso, na modelagem de classes usando Unified Modeling Language (UML),é sempre recomendável especificar a multiplicidade dos relacionamentos (associações). Um dos tipos mais comuns de multiplicidade é a multiplicidade um-para-muitos (1:n).\n\nEntre as alternativas abaixo, assinale a que apresenta uma situação de associação um-para-muitos, seguindo a notação “associação (classe1, classe2)”.",
  "alternativas": [
    "a) Comprar (Jornal, Leitor)",
    "b) Casar (Marido, Esposa)",
    "c) Torcer (Time, Pessoa)",
    "d) Votar (Prefeito, Eleitor)",
    "e) Escrever (Coluna, Colunista)"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens de Programação",
  "subarea": "Paradigmas de Linguagens de Programação",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - linguagens de programacao - paradigmas de linguagens de programacao"
},

{
  "id": "2007-38",
  "edicao": 2007,
  "numero": 38,
  "enunciado": "Dado o seguinte programa escrito em C:\n```\n#include <stdio.h>\n\nint main(void)\n{\n   int n[] = {7, 8, 9};\n   int *p;\n\n   p = &n[0];\n   p++;\n   printf(\"Valor: %d \", *p);\n   (*p)++;\n   printf(\"Valor: %d\\n\", *p);\n}\n```\nQual é a resposta que será impressa na tela:",
  "alternativas": [
    "a) Valor: 7 Valor: 8",
    "b) Valor: 7 Valor: 7",
    "c) Valor: 8 Valor: 9",
    "d) Valor: 7 Valor: 9",
    "e) Valor: 9 Valor: 9"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens de Programação",
  "subarea": "Paradigmas de Linguagens de Programação",
  "gabarito": "C",
  "atributo_rag": "fundamentos da computacao - linguagens de programacao - paradigmas de linguagens de programacao"
},

{
  "id": "2007-39",
  "edicao": 2007,
  "numero": 39,
  "enunciado": "Seja $G = (V , E)$ um grafo simples e finito, onde $\\lvert V \\rvert = n$ e $\\lvert E \\rvert = m$.\\\nNesse caso, analise as seguintes afirmativas.\n\nI. Se $G$ é hamiltoniano, então $G$ é 2-conexo em vértices.\\\nII. Se $G$ é completo, então $G$ é hamiltoniano.\\\nIII. Se $G$ é 4-regular e conexo, então $G$ é euleriano.\\\nIV. Se $G$ é bipartite com partições $A$ e $B$ , então $G$ é hamitoniano se, e somente se,$\\lvert A \\rvert = \\lvert B \\rvert$.\\\nV. Se $G$ é euleriano, então $G$ é 2-conexo.\\\nA análise permite concluir que são **FALSOS**",
  "alternativas": [
    "a) apenas os itens I e II.",
    "b) apenas os itens I e V.",
    "c) apenas os itens II e III.",
    "d) apenas os itens III e IV.",
    "e) apenas os itens IV e V."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Teoria dos Grafos",
  "subarea": "Grafos orientados e não-orientados",
  "gabarito": "E",
  "atributo_rag": "fundamentos da computacao - teoria dos grafos - grafos orientados e nao-orientados"
},

{
  "id": "2008-16",
  "edicao": 2008,
  "numero": 16,
  "enunciado": "Sejam duas funções $f(n)$ e $g(n)$ que mapeiam números inteiros positivos em números reais positivos. \\\nCom respeito às notações assintóticas de complexidade, avalie as afirmativas abaixo.\n\nI. Diz-se que $f(n)$ é $O(g(n))$ se existe uma constante real $c > 0$ e existe uma constante inteira $n_0 \\geq 1$ tal que $f(n) \\leq c \\times g(n)$ para todo inteiro $n \\geq n_0$. \\\nII. Diz-se que $f(n)$ é $o(g(n))$ se para toda constante real $c > 0$ existe uma constante inteira $n_0 \\geq 1$ tal que $f(n) < c \\times g(n)$ para todo inteiro $n \\geq n_0$. \\\nIII. Diz-se que $f(n)$ é $\\Omega(g(n))$ se existe uma constante real $c > 0$ e existe uma constante inteira $n_0 \\geq 1$ tal que $f(n) \\geq c \\times g(n)$ para todo inteiro $n \\geq n_0$. \\\nIV. Diz-se que $f(n)$ é $\\omega(g(n))$ se para toda constante real $c > 0$ existe uma constante inteira $n_0 \\geq 1$ tal que $f(n) > c \\times g(n)$ para todo inteiro $n \\geq n_0$. \\\nV. Diz-se que $f(n)$ é $\\Theta(g(n))$ se, e somente se, $f(n)$ é $O(g(n))$ e $f(n)$ é $\\Omega(g(n))$.\n\nA análise permite concluir que",
  "alternativas": [
    "a) todas as afirmativas são falsas.",
    "b) todas as afirmativas são verdadeiras.",
    "c) apenas as afirmativas I e III são verdadeiras.",
    "d) apenas as afirmativas II e IV são verdadeiras.",
    "e) apenas a afirmativa V é falsa."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Análise de Algoritmos",
  "subarea": "Notação “Big O”, “Little o”, “Omega” e “Theta”",
  "gabarito": "B",
  "atributo_rag": "fundamentos da computacao - analise de algoritmos - notacao “big o”, “little o”, “omega” e “theta”"
},

{
  "id": "2008-17",
  "edicao": 2008,
  "numero": 17,
  "enunciado": "Analise as seguintes afirmativas.\n\nI. Em um problema de decisão, o objetivo é decidir a resposta sim ou não a uma questão. Em um problema de localização, procura-se localizar uma certa estrutura que satisfaça um conjunto de propriedades dadas. Se as propriedades envolverem critérios de otimização, então o problema é dito de otimização. \\\nII. A teoria da complexidade restringe-se a problemas de decisão, já que o estudo de problemas NP-completos é aplicado somente para esse tipo de problema. \\\nIII. Os problemas NP-Completos são considerados como os problemas mais difíceis em NP. Se qualquer problema NP-Completo pode ser resolvido em tempo polinomial, então todos os problemas em NP podem ser resolvidos da mesma forma.\n\nA análise permite concluir que",
  "alternativas": [
    "a) apenas a afirmativa I está correta.",
    "b) apenas a afirmativa II está correta.",
    "c) apenas as afirmativas I e II estão corretas.",
    "d) apenas as afirmativas I e III estão corretas.",
    "e) todas as afirmativas estão corretas."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens Formais, Autômatos e Computabilidade",
  "subarea": "Classes de Problemas P, NP, NP Completo e NP-Difícil",
  "gabarito": "E",
  "atributo_rag": "fundamentos da computacao - linguagens formais, automatos e computabilidade - classes de problemas p, np, np completo e np-dificil"
},

{
  "id": "2008-18",
  "edicao": 2008,
  "numero": 18,
  "enunciado": "Analise as afirmativas abaixo.\n\nI. A programação dinâmica é um método ascendente que aborda um dado problema subdividindo-o em problemas mínimos, soluciona esses subproblemas, guarda as soluções parciais, combina os subproblemas e sub-resultados para obter e resolver os problemas maiores, até recompor e resolver o problema original. \\\nII. A divisão e conquista é um método recursivo e, por isso, descendente que decompõe sucessivamente um problema em subproblemas independentes triviais, resolvendo-os e combinando as soluções em uma solução para o problema original. \\\nIII. Um algoritmo guloso sempre faz escolhas que parecem ser as melhores no momento, ou seja, escolhas ótimas locais acreditando que estas escolhas o levem a uma solução ótima global. Por essa estratégia, nem sempre asseguram-se soluções ótimas, mas, para muitos problemas, as soluções são ótimas. Os problemas ideais para essa estratégia não devem ter a propriedade de subestrutura ótima.\n\nA análise permite concluir que",
  "alternativas": [
    "a) todas as afirmativas são verdadeiras.",
    "b) todas as afirmativas são falsas.",
    "c) apenas as afirmativas I e II são verdadeiras.",
    "d) apenas as afirmativas II e III são verdadeiras.",
    "e) apenas a afirmativa III é verdadeira."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Algoritmos e Estrutura de Dados",
  "subarea": "Técnicas de Projeto de Algoritmos: Método da Força Bruta, Pesquisa Exaustiva, Algoritmo Guloso, Dividir e Conquistar, “Backtracking” e Heurísticas",
  "gabarito": "C",
  "atributo_rag": "fundamentos da computacao - algoritmos e estrutura de dados - tecnicas de projeto de algoritmos: metodo da forca bruta, pesquisa exaustiva, algoritmo guloso, dividir e conquistar, “backtracking” e heuristicas"
},

{
  "id": "2008-19",
  "edicao": 2008,
  "numero": 19,
  "enunciado": "Com respeito ao projeto de linguagens de programação, assinale a afirmativa CORRETA.",
  "alternativas": [
    "a) A forma dos programas construídos com uma determinada linguagem, definida por regras formais que expressam restrições que definem como são os programas bem formados, é um problema de caráter sintático.",
    "b) O significado de programas bem construídos com uma determinada linguagem, a qual define o efeito da execução desses programas, é um problema de caráter semântico.",
    "c) Sistemas de tipos apresentam três propósitos principais em uma linguagem de programação: a segurança, a abstração e a modularidade.",
    "d) A segurança de uma linguagem de programação está diretamente relacionada com a capacidade de identificação estática e/ou dinâmica de programas mal formados que não podem ser identificados somente por meio de mecanismos de análise sintática, como gramáticas livres do contexto.",
    "e) Todas as alternativas anteriores estão corretas."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens de Programação",
  "subarea": "Paradigmas de Linguagens de Programação",
  "gabarito": "E",
  "atributo_rag": "fundamentos da computacao - linguagens de programacao - paradigmas de linguagens de programacao"
},

{
  "id": "2008-20",
  "edicao": 2008,
  "numero": 20,
  "enunciado": "Analise as seguintes afirmativas.\n\nI. Ocultar dados dentro das classes e torná-los disponíveis apenas por meio de métodos é uma técnica muito usada em programas orientados a objetos e é chamada de *sobrescrita* de atributos. \\\nII. Uma subclasse pode implementar novamente métodos que foram herdados de uma superclasse. Chamamos isso de *sobrecarga* de métodos. \\\nIII. Em Java não existe Herança múltipla como em C++. A única maneira se se obter algo parecido é via interfaces.\n\nA análise permite concluir que",
  "alternativas": [
    "a) apenas a afirmativa I está incorreta.",
    "b) apenas a afirmativa II está incorreta.",
    "c) apenas a afirmativa III está incorreta.",
    "d) apenas as afirmativas I e III estão incorretas.",
    "e) apenas as afirmativas I e II estão incorretas"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens de Programação",
  "subarea": "Paradigmas de Linguagens de Programação",
  "gabarito": "E",
  "atributo_rag": "fundamentos da computacao - linguagens de programacao - paradigmas de linguagens de programacao"
},

{
  "id": "2008-21",
  "edicao": 2008,
  "numero": 21,
  "enunciado": "Analise as seguintes afirmativas.\n\nI. Encapsulamento permite que uma classe defina métodos com o mesmo nome de métodos presentes em sua superclasse desde que esses métodos tenham argumentos um pouco diferentes. \\\nII. Em Java, uma instância de uma classe C que implementa uma interface I é membro tanto do tipo definido pela interface I quanto do tipo definido pela classe C. \\\nIII. Em Java, classes abstratas não precisam ser completamente abstratas, ao contrário das interfaces, classes abstratas podem ter métodos implementados que serão herdados por suas subclasses.\n\nA análise permite concluir que",
  "alternativas": [
    "a) apenas as afirmativas II e III estão corretas.",
    "b) apenas as afirmativas I e II estão corretas.",
    "c) apenas as afirmativas I e III estão corretas.",
    "d) apenas a afirmativa II está correta.",
    "e) apenas a afirmativa I está correta."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens de Programação",
  "subarea": "Paradigmas de Linguagens de Programação",
  "gabarito": "A",
  "atributo_rag": "fundamentos da computacao - linguagens de programacao - paradigmas de linguagens de programacao"
},

{
  "id": "2008-22",
  "edicao": 2008,
  "numero": 22,
  "enunciado": "Os fragmentos de programas abaixo, enumerados 1, 2 e 3, são implementações para o problema de ordenação usando o algoritmo *quicksort*. \\\n**Programa 1:**\n```\nquicksort([], []).\nquicksort([Head | Tail], Sorted) :-\n    partition(Head, Tail, Left, Right), quicksort(Left, SortedL),\nquicksort(Right, SortedR),\nappend(SortedL, [Head | SortedR], Sorted).\npartition(Pivot, [], [], []).\npartition(Pivot, [Head | Tail], [Head | Left], Right) :-\n    Head =< Pivot, partition(Pivot, Tail, Left, Right).\npartition(Pivot, [Head | Tail], Left, [Head | Right]) :-\n    Head > Pivot, partition(Pivot, Tail, Left, Right).\nappend([], List, List).\nappend([Head | List1], List2, [Head | List3]) :-\n    append(List1, List2, List3).\n```\n**Programa 2:**\n```\nquicksort [] = []\nquicksort (head:tail) = let pivot = head left = [x|x <- tail,x < pivot]\nright = [x|x <- tail,x >= pivot]\nin quicksort left ++ [pivot] ++ quicksort right\n```\n**Programa 3:**\n```\nvoid quickSort( int a[], int l, int r) {\n    int j;\n    if( l < r ) {\n        j = partition( a, l, r);\n        quickSort( a, l, j-1);\n        quickSort( a, j+1, r);\n        }\n}\n\nint partition( int a[], int l, int r) {\n    int pivot, i, j, t;\n    pivot = a[l]; i = l; j = r+1;\n    while(i<j) {\n        do ++i; while( a[i] <= pivot && i <= r );\n        do --j; while( a[j] > pivot );\n        if( i < j ) {\n            t = a[i]; a[i] = a[j]; a[j] = t;\n        }\n    }\n    t = a[l]; a[l] = a[j]; a[j] = t;\n    return j;\n}\n```\nAssinale a alternativa que enumera os paradigmas das linguagens com as quais os programas 1, 2 e 3 foram respectivamente implementados.",
  "alternativas": [
    "a) Lógico, imperativo e funcional",
    "b) Imperativo, funcional e lógico",
    "c) Funcional, lógico e imperativo",
    "d) Lógico, funcional e imperativo",
    "e) Funcional, funcional e imperativo"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens de Programação",
  "subarea": "Paradigmas de Linguagens de Programação",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - linguagens de programacao - paradigmas de linguagens de programacao"
},

{
  "id": "2008-23",
  "edicao": 2008,
  "numero": 23,
  "enunciado": "Analise as seguintes afirmativas.\n\nI. A função *map* presente em linguagens funcionais como *Haskell* e *OCaml* é um bom exemplo de função de alta-ordem com tipo polimórfico. \\\nII. *Prolog* é uma linguagem de programação baseada em lógica de predicados de primeira ordem. \\\nIII. Em *Haskell* todas as funções recebem apenas um argumento. Uma função que recebe dois inteiros e devolve um *float* como resposta na verdade é uma função que recebe apenas um inteiro como argumento e devolve como resposta uma função de inteiro para *float*.\n\nA análise permite concluir que",
  "alternativas": [
    "a) apenas as afirmativas II e III estão corretas.",
    "b) apenas as afirmativas I e III estão corretas.",
    "c) apenas as afirmativas I e II estão corretas.",
    "d) apenas a afirmativa II está correta.",
    "e) apenas as afirmativas I, II e III estão corretas."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens de Programação",
  "subarea": "Paradigmas de Linguagens de Programação",
  "gabarito": "E",
  "atributo_rag": "fundamentos da computacao - linguagens de programacao - paradigmas de linguagens de programacao"
},

{
  "id": "2008-24",
  "edicao": 2008,
  "numero": 24,
  "enunciado": "Denomina-se complemento de um grafo $G(V,E)$ o grafo $H$ que tem o conjunto de vértices igual ao de $G$ e tal que, para todo par de vértices distintos $v,w$ em $V$, temos que a aresta $(v,w)$ é aresta de $G$ se e somente se $(v,w)$ não é aresta de $H$.\n\nA esse respeito, assinale a afirmativa CORRETA.",
  "alternativas": [
    "a) $G$ e $H$ são grafos isomorfos.",
    "b) Se o grafo $G$ é conexo, então $H$ é conexo.",
    "c) Se o grafo $G$ não é conexo, então $H$ é conexo.",
    "d) Se o grafo $G$ não é conexo, então $H$ não é conexo.",
    "e) Os grafos $G$ e $H$ têm o mesmo número de componentes conexas."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Teoria dos Grafos",
  "subarea": "Grafos orientados e não-orientados",
  "gabarito": "C",
  "atributo_rag": "fundamentos da computacao - teoria dos grafos - grafos orientados e nao-orientados"
},

{
  "id": "2008-25",
  "edicao": 2008,
  "numero": 25,
  "enunciado": "Um grafo $G(V,E)$ é uma árvore se $G$ é conexo e acíclico. \n\nAssinale a definição que NÃO pode ser usada para definir árvores.",
  "alternativas": [
    "a) $G$ é conexo e o número de arestas é mínimo.",
    "b) $G$ é conexo e o número de vértices excede o número de arestas por uma unidade.",
    "c) $G$ é acíclico e o número de vértices excede o número de arestas por uma unidade.",
    "d) $G$ é acíclico e, para todo par de vértices $v$, $w$, que não são adjacentes em $G$, a adição da aresta $(v,w)$ produz um grafo contendo exatamente um ciclo.",
    "e) $G$ é acíclico, e o número de arestas é mínimo."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Teoria dos Grafos",
  "subarea": "Conectividade",
  "gabarito": "E",
  "atributo_rag": "fundamentos da computacao - teoria dos grafos - conectividade"
},

{
  "id": "2008-26",
  "edicao": 2008,
  "numero": 26,
  "enunciado": "Em um grafo $G(V,E)$, o grau de um vértice é o número de vértices adjacentes a $v$.\n\nA esse respeito, assinale a afirmativa CORRETA.",
  "alternativas": [
    "a) Num grafo, o número de vértices com grau ímpar é sempre par.",
    "b) Num grafo, o número de vértices com grau par é sempre ímpar.",
    "c) Num grafo, sempre existe algum vértice com grau par.",
    "d) Num grafo, sempre existe algum vértice com grau ímpar.",
    "e) Num grafo, o número de vértices com grau ímpar é sempre igual ao número de vértices com grau par."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Teoria dos Grafos",
  "subarea": "Grafos orientados e não-orientados",
  "gabarito": "A",
  "atributo_rag": "fundamentos da computacao - teoria dos grafos - grafos orientados e nao-orientados"
},

{
  "id": "2008-28",
  "edicao": 2008,
  "numero": 28,
  "enunciado": "Seja $G(V,E)$ um grafo tal que $|V| = n$ e $|E| = m$.\n\nAnalise as seguintes sentenças:\n\nI. Se $G$ é acíclico com no máximo $n - 1$ arestas, então $G$ é uma árvore. \\\nII. Se $G$ é um ciclo, então $G$ tem $n$ árvores geradoras distintas. \\\nIII. Se $G$ é conexo com no máximo $n - 1$ arestas, então $G$ é uma árvore. \\\nIV. Se $G$ é conexo e tem um ciclo, então para toda árvore geradora $T$ de $G$, $E(G) - E(T) = \\emptyset $.\n\nA análise permite concluir que",
  "alternativas": [
    "a) apenas os itens I e III são verdadeiros.",
    "b) apenas os itens II e III são verdadeiros.",
    "c) apenas o item I é falso.",
    "d) todos os itens são verdadeiros.",
    "e) apenas os itens II e IV são verdadeiros."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Teoria dos Grafos",
  "subarea": "Árvore Geradora",
  "gabarito": "C",
  "atributo_rag": "fundamentos da computacao - teoria dos grafos - arvore geradora"
},

{
  "id": "2008-29",
  "edicao": 2008,
  "numero": 29,
  "enunciado": "Assinale a afirmativa INCORRETA.",
  "alternativas": [
    "a) Existe uma máquina de Turing U que simula qualquer outra máquina de Turing M sobre qualquer entrada para M.",
    "b) A Tese de *Church* afirma que o conceito informal de procedimento efetivo é capturado pelo conceito formal de Máquina de *Turing*.",
    "c) Uma linguagem é recursivamente enumerável se, e somente se, for aceita por alguma Máquina de *Turing*.",
    "d) Existe uma máquina de *Turing* T que, dada qualquer máquina de Turing M e qualquer entrada w para M, T determina, em um número finito de passos, se M pára para a entrada w ou não.",
    "e) Toda linguagem recursiva é recursivamente enumerável, mas o inverso nem sempre é verdadeiro."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens Formais, Autômatos e Computabilidade",
  "subarea": "Máquina de Turing",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - linguagens formais, automatos e computabilidade - maquina de turing"
},

{
  "id": "2008-30",
  "edicao": 2008,
  "numero": 30,
  "enunciado": "Analise as seguintes afirmativas.\n\nI. Todo autômato finito não-determinístico pode ser simulado por um autômato finito determinístico. \\\nII. Todo autômato finito determinístico pode ser simulado por um autômato finito não-determinístico. \\\nIII. Todo autômato finito não-determinístico pode ser simulado por um autômato de pilha determinístico. \\\nIV. Todo autômato de pilha determinístico pode ser simulado por um autômato finito não-determinístico. \\\nV. Todo autômato finito não-determinístico pode ser simulado por uma máquina de *Turing* determinística.\n\nA análise permite concluir que estão CORRETAS",
  "alternativas": [
    "a) apenas as afirmativas I, II, III e IV.",
    "b) apenas as afirmativas II, III e V.",
    "c) apenas as afirmativas I, II, III e V.",
    "d) apenas as afirmativas II e IV.",
    "e) apenas as afirmatias I, II e IV."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens Formais, Autômatos e Computabilidade",
  "subarea": "Autômatos de Estados Finitos Determinístico e não Determinístico",
  "gabarito": "C",
  "atributo_rag": "fundamentos da computacao - linguagens formais, automatos e computabilidade - automatos de estados finitos deterministico e nao deterministico"
},

{
  "id": "2008-31",
  "edicao": 2008,
  "numero": 31,
  "enunciado": "Um dos itens do problema denominado \"Problema do *Busy Beaver*\" consiste em determinar qual o tamanho da maior computação finita que pode ser realizada por máquinas de *Turing* com determinada quantidade $k$ de estados, quando as máquinas começam com a fita em branco (fita vazia).\n\nAnalise as seguintes afirmativas.\n\nI. Todas as computações de qualquer máquina de Turing de dois estados ($k = 2$) são infinitas, quando a máquina começa com a fita vazia. \\\nII. Todas as computações de qualquer máquina de Turing de dois estados ($k = 2$) são finitas, quando a máquina começa com a fita vazia. \\\nIII. Para qualquer número $k \\geq 2$, máquinas de Turing com $k$ estados podem realizar computações de qualquer tamanho finito, quando a fita começa vazia, dependendo apenas do algoritmo que as máquinas estão computando.\n\nA análise permite concluir que",
  "alternativas": [
    "a) nenhuma das afirmativas é verdadeira.",
    "b) todas as afirmativas são verdadeiras.",
    "c) somente I e II são verdadeiras.",
    "d) somente III é verdadeira.",
    "e) somente II e III são verdadeiras."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens Formais, Autômatos e Computabilidade",
  "subarea": "Máquina de Turing",
  "gabarito": "A",
  "atributo_rag": "fundamentos da computacao - linguagens formais, automatos e computabilidade - maquina de turing"
},

{
  "id": "2008-32",
  "edicao": 2008,
  "numero": 32,
  "enunciado": "Analise as seguintes afirmativas.\n\nI. Uma arquitetura *multithreading* executa simultaneamente o código de diversos fluxos de instruções (*threads*). \\\nII. Em uma arquitetura VLIW, o controle da execução das várias instruções por ciclo de máquina é feito pelo compilador. \\\nIII. Uma arquitetura superescalar depende de uma boa taxa de acerto do mecanismo de predição de desvio para obter um bom desempenho. \\\nIV. Os processadores vetoriais são um tipo de arquitetura SIMD. \\\nV. Um processador *dual-core* é mais eficiente em termos de consumo de energia do que dois processadores *single-core* de mesma tecnologia.\n\nA  partir da análise, pode-se concluir que",
  "alternativas": [
    "a) apenas a afirmativa IV está correta.",
    "b) apenas as afirmativas III e IV estão corretas.",
    "c) apenas as afirmativas I, IV e V estão corretas.",
    "d) apenas as afirmativas I, III e V estão corretas.",
    "e) todas as afirmativas estão corretas."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Arquitetura e Organização de Computadores",
  "subarea": "Organização de Computadores: Memórias, Unidades Centrais de Processamento, Entrada e Saída",
  "gabarito": "E",
  "atributo_rag": "fundamentos da computacao - arquitetura e organizacao de computadores - organizacao de computadores: memorias, unidades centrais de processamento, entrada e saida"
},

{
  "id": "2008-33",
  "edicao": 2008,
  "numero": 33,
  "enunciado": "O uso de memória caches é muito importante para o desempenho dos processadores atuais.\n\nAnalise as afirmativas abaixo relativas ao uso de memórias caches.\n\nI. Em uma memória cache com mapeamento direto um bloco de memória pode ser colocado em qualquer posição (entrada) dessa memória cache. \\\nII. Na política de escrita *write-back* o bloco modificado é atualizado na memória principal apenas quando for substituído. \\\nIII. O uso de associatividade nas memórias cache serve para reduzir o número de falhas por conflito.\n\nA análise permite concluir que",
  "alternativas": [
    "a) as três afirmativas são falsas.",
    "b) as três afirmativas são verdadeiras.",
    "c) apenas a afirmativa I é verdadeira.",
    "d) apenas as afirmativas II e III são verdadeiras.",
    "e) apenas a afirmativa III é verdadeira."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Arquitetura e Organização de Computadores",
  "subarea": "Organização de Computadores: Memórias, Unidades Centrais de Processamento, Entrada e Saída",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - arquitetura e organizacao de computadores - organizacao de computadores: memorias, unidades centrais de processamento, entrada e saida"
},

{
  "id": "2008-34",
  "edicao": 2008,
  "numero": 34,
  "enunciado": "O trecho de código em linguagem de montagem do MIPS64 a seguir faz a soma do conteúdo de dois vetores, armazenando o resultado em um terceiro vetor.\n```\nLOOP: ld R1, A(R5) ;; R1 = MEM[A+R5]\n\nld R2, B(R5) ;; R2 = MEM[B+r5]\n\ndadd R3, R1, R2 ;; R3 = R1 + r2\n\nsd R3, C(R5) ;; MEM[C+r5] = R3\n\ndaddi R5, R5, -8 ;; R5 = R5 -8\n\nbnez R5, loop ;; IF R5 <> 0 THEn PC=LOOP\n\nnop\n```\nAssinale a alternativa que indica quantas dependências diretas, antidependências e dependências de saída respectivamente, podem ser encontradas nesse trecho de código.",
  "alternativas": [
    "a) 3, 1, 1",
    "b) 4, 3, 0",
    "c) 2, 2, 1",
    "d) 1, 2, 3",
    "e) Nenhuma das respostas anteriores."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Arquitetura e Organização de Computadores",
  "subarea": "Linguagens de Montagem",
  "gabarito": "B",
  "atributo_rag": "fundamentos da computacao - arquitetura e organizacao de computadores - linguagens de montagem"
},

{
  "id": "2008-35",
  "edicao": 2008,
  "numero": 35,
  "enunciado": "Uma tabela de histórico de desvios (PHT) é uma pequena memória colocada no estágio de busca de instruções, indexada pelos bits mais baixos do endereço da instrução que está sendo buscada. Cada entrada na PHT codifica a predição do resultado da próxima execução de qualquer instrução de desvio que indexe essa entrada na tabela, baseado no resultado de um contador saturante de 2 bits.\\\nAssumindo 00 como valor inicial dos contadores, **ASSINALE** a predição de cada desvio\n(**A:**, **B:** e **C:**) após a verificação das seguintes sequências de resultados para uma mesma instrução de desvio: (**T** = tomado, **N** = não tomado).\n```\n    A: N T T T N T T T N N T T N N T T N\n    B: N T N N N N N N N N T N T T N N T\n    C: T N T T T T N N N T T N N N T T T\n```",
  "alternativas": [
    "a) **T**omado, **N**ão Tomado, **T**omado",
    "b) **T**omado, **T**omado, **T**omado",
    "c) **N**ão Tomado, **N**ão Tomado, **N**ão Tomado",
    "d) **N**ão Tomado, **T**omado, **N**ão Tomado",
    "e) **N**ão Tomado, **N**ão Tomado, **T**omado"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Arquitetura e Organização de Computadores",
  "subarea": "Pipeline",
  "gabarito": "A",
  "atributo_rag": "fundamentos da computacao - arquitetura e organizacao de computadores - pipeline"
},

{
  "id": "2008-36",
  "edicao": 2008,
  "numero": 36,
  "enunciado": "Assuma que um programa tem um *profile* de execução onde 85% das instruções são simples (tais como AND, XOR, ADD e BRANCH) e os 15% restantes são instruções complexas (tais como MUL e DIV). Adicionalmente, considere que as instruções simples precisam de 2 ciclos de máquina e as complexas precisam de 12 ciclos em uma máquina CISC (cada ciclo = 10 ns). Em uma máquina RISC, as instruções simples serão executadas em 1 ciclo, enquanto que as instruções complexas deverão ser simuladas por software necessitando, em média, 20 ciclos por instrução. Devido a sua simplicidade, o tempo de ciclo em uma máquina RISC é de 8 ns. Considere também que o programa precisou de 100.000.000 instruções para ser completado. \n\nQual o tempo gasto em segundos na execução desse programa, respectivamente, nas máquinas CISC e RISC?",
  "alternativas": [
    "a) 1 e 0,8",
    "b) 3,5 e 3,08",
    "c) 10 e 12,8",
    "d) 8,5 e 1,5",
    "e) 14 e 16,8"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Arquitetura e Organização de Computadores",
  "subarea": "Arquiteturas RISC e CISC",
  "gabarito": "B",
  "atributo_rag": "fundamentos da computacao - arquitetura e organizacao de computadores - arquiteturas risc e cisc"
},

{
  "id": "2008-37",
  "edicao": 2008,
  "numero": 37,
  "enunciado": "Assinale a afirmativa INCORRETA.",
  "alternativas": [
    "a) Seja $A[1, n]$ um vetor não ordenado de inteiros com um número constante $k$ de valores distintos. Então existe algoritmo de ordenação por contagem que ordena $A$ em tempo linear.",
    "b) Seja $A[1, n]$ um vetor não ordenado de inteiros com um número constante $k$ de valores distintos, então o limite inferior para um algoritmo de ordenação por comparações para ordenar $A$ é de $O(n lg n)$.",
    "c) Seja $A[1, n]$ um vetor não ordenado de inteiros, cada inteiro com no máximo $d$ dígitos, onde cada dígito assume um valor entre um número constante $k$ de valores distintos. Então o problema de ordenar $A$ tem limite inferior $O(n)$.",
    "d) Seja $A[1, n]$ um vetor não ordenado de inteiros, cada inteiro com no máximo $d$ dígitos, onde cada dígito assume um valor entre $O(n)$ valores distintos. Então o problema de ordenar $A$ tem limite inferior $O(n lg n)$.",
    "e) Seja $A[1, n]$ um vetor não ordenado de inteiros com um número constante $k$ de valores distintos, então um um algoritmo de ordenação por comparações ótimo para ordenar $A$ tem complexidade $O(n lg n)$."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Análise de Algoritmos",
  "subarea": "Análise de Algoritmos Iterativos e Recursivos",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - analise de algoritmos - analise de algoritmos iterativos e recursivos"
},

{
  "id": "2008-38",
  "edicao": 2008,
  "numero": 38,
  "enunciado": "Considere as seguintes sentenças:\n\nI. Se um vetor $A[1, n]$, $n \\geq 2$, de inteiros é ordenado em ordem não decrescente, então encontrar o $i$-ésimo maior elemento, $1 \\leq i \\leq n$, pode ser feito em tempo constante. \\\nII. Se um vetor $A[1, n]$, $n \\geq 2$, de inteiros é ordenado em ordem não decrescente, o limite inferior para o problema de encontrar o $i$-ésimo maior elemento, $1 \\leq i \\leq n$, com um algoritmo de comparação, é $O(n)$. \\\nIII. Se um vetor $A[1, n]$, $n \\geq 2$, de inteiros é ordenado em ordem não decrescente, o limite inferior para o problema de encontrar o $i$-ésimo maior elemento, $1 \\leq i \\leq n$, com um algoritmo de comparação, é $O(\\lg n)$. \\\nIV. Se um vetor $A[1, n]$, $n \\geq 2$, de inteiros é ordenado em ordem crescente, então encontrar o $(n - 1)$-ésimo maior elemento, pode ser feito em tempo constante. \\\nV. Se um vetor $A[1, n]$, $n \\geq 2$, de inteiros é ordenado em ordem crescente, então encontrar o $i$-ésimo maior elemento, pode ser feito em tempo constante.\n\nA  esse respeito, assinale a alternativa CORRETA.",
  "alternativas": [
    "a) Apenas os itens II e IV são falsos.",
    "b) Apenas os itens I, III e V são verdadeiros.",
    "c) Apenas os itens III, IV e V são verdadeiros.",
    "d) Apenas os itens II e III são falsos.",
    "e) Apenas os itens II e V são verdadeiros."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Análise de Algoritmos",
  "subarea": "Medidas de Complexidade, Análise Assintótica de Limites de Complexidade, Técnicas de Prova de Cotas Inferiores",
  "gabarito": "C",
  "atributo_rag": "fundamentos da computacao - analise de algoritmos - medidas de complexidade, analise assintotica de limites de complexidade, tecnicas de prova de cotas inferiores"
},

{
  "id": "2008-39",
  "edicao": 2008,
  "numero": 39,
  "enunciado": "Associações reflexivas são tipos especiais de associações que podem ocorrer em programação orientada a objetos.\n\nAnalise as seguintes afirmativas relativas ao uso de associações reflexivas.\n\nI. Elas acontecem quando instâncias de uma mesma classe se relacionam. \\\nII. Não permitem o uso de papéis (rótulos) para clarificar os relacionamentos. \\\nIII. Permitem multiplicidade somente do tipo um-para-um (1:1).\n\nA análise permite concluir que",
  "alternativas": [
    "a) as três afirmativas são falsas.",
    "b) as três afirmativas são verdadeiras.",
    "c) apenas a afirmativa I é verdadeira.",
    "d) as afirmativas I e II são verdadeiras.",
    "e) apenas a afirmativa III é verdadeira."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens de Programação",
  "subarea": "Paradigmas de Linguagens de Programação",
  "gabarito": "C",
  "atributo_rag": "fundamentos da computacao - linguagens de programacao - paradigmas de linguagens de programacao"
},

{
  "id": "2008-40",
  "edicao": 2008,
  "numero": 40,
  "enunciado": "Na modelagem de classes usando UML (*Unified Modeling Language*) é sempre recomendável especificar a multiplicidade dos relacionamentos (associações). \\\nSeguindo-se a notação associação (classe1, classe2), assinale a alternativa que melhor descreve a multiplicidade da associação Casar(Marido, Esposa).",
  "alternativas": [
    "a) 1:1",
    "b) 1:n",
    "c) n:n",
    "d) 2:1",
    "e) 1:2"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Técnicas de Programação",
  "subarea": "Metodologia de desenvolvimento de programas",
  "gabarito": "A",
  "atributo_rag": "fundamentos da computacao - tecnicas de programacao - metodologia de desenvolvimento de programas"
},

{
  "id": "2008-41",
  "edicao": 2008,
  "numero": 41,
  "enunciado": "Os membros de uma classe (atributos e operações) podem ser privados, protegidos ou públicos em programação orientada a objetos. Suponha agora que se tenha um dado em uma determinada classe que só deve ser acessado por instâncias dessa mesma classe. \n\nAssinale a alternativa que melhor descreve o que esse dado pode ser.",
  "alternativas": [
    "a) Somente público",
    "b) Somente privado",
    "c) Somente protegido",
    "d) Privado ou público",
    "e) Privado ou protegido"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens de Programação",
  "subarea": "Paradigmas de Linguagens de Programação",
  "gabarito": "B",
  "atributo_rag": "fundamentos da computacao - linguagens de programacao - paradigmas de linguagens de programacao"
},

{
  "id": "2008-42",
  "edicao": 2008,
  "numero": 42,
  "enunciado": "Analise as seguintes igualdades de expressões regulares:\n\nI. $a^* = (a^*)^*$ \\\nII. $(a+b)^* = (b+a)^*$ \\\nIII. $a^*+b^* = (a+b)^*$\n\nA análise permite concluir que",
  "alternativas": [
    "a) somente as igualdades I e II são verdadeiras.",
    "b) somente a igualdade I é verdadeira.",
    "c) somente as igualdades II e III são verdadeiras.",
    "d) todas as igualdades são verdadeiras.",
    "e) nenhuma das igualdades é verdadeira."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens Formais, Autômatos e Computabilidade",
  "subarea": "Linguagens Regulares, Livres-de-Contexto e Sensíveis-ao-Contexto",
  "gabarito": "A",
  "atributo_rag": "fundamentos da computacao - linguagens formais, automatos e computabilidade - linguagens regulares, livres-de-contexto e sensiveis-ao-contexto"
},

{
  "id": "2008-44",
  "edicao": 2008,
  "numero": 44,
  "enunciado": "Considere a seguinte gramática *G* , onde *S* é o símbolo inicial:\n$$\n\\begin{array}{l}\nS \\rightarrow AcB \\\\\nA \\rightarrow cA \\mid aB \\\\\nB \\rightarrow cB \\mid aA \\\\\nA \\rightarrow \\varepsilon\n\\end{array}\n$$\nAssinale a alternativa que apresenta a palavra que **NÃO** pertence à linguagem gerada pela gramática *G*.",
  "alternativas": [
    "a) $ccca$",
    "b) $aaca$",
    "c) $aaaca$",
    "d) $ccac$",
    "e) $aaa$"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens Formais, Autômatos e Computabilidade",
  "subarea": "Linguagens Regulares, Livres-de-Contexto e Sensíveis-ao-Contexto",
  "gabarito": "E",
  "atributo_rag": "fundamentos da computacao - linguagens formais, automatos e computabilidade - linguagens regulares, livres-de-contexto e sensiveis-ao-contexto"
},

{
  "id": "2008-45",
  "edicao": 2008,
  "numero": 45,
  "enunciado": "Considere as seguintes gramáticas.\\\n**Gramática I:**\n$$\n\\begin{aligned}\nA &\\rightarrow bA \\\\\nA &\\rightarrow aA \\\\\nA &\\rightarrow \\varepsilon\n\\end{aligned}\n$$\n**Gramática II:**\n$$\n\\begin{align*}\nB &\\rightarrow BB \\\\\nB &\\rightarrow b\n\\end{align*}\n$$\n**Gramática III:**\n$$\n\\begin{align*}\nC &\\rightarrow CaC \\\\\nA &\\rightarrow AcA \\\\\nA &\\rightarrow aca\n\\end{align*}\n$$\n**Gramática IV:**\n$$\n\\begin{align*}\nD &\\rightarrow EE \\\\\nEE &\\rightarrow FG \\\\\nF &\\rightarrow a \\mid aF \\\\\nG &\\rightarrow b \\mid bG\n\\end{align*}\n$$\nA esse respeito, assinale a afirmativa **FALSA**.",
  "alternativas": [
    "a) A gramática I é livre de contexto.",
    "b) A gramática II é livre de contexto.",
    "c) A gramática III é livre de contexto.",
    "d) A gramática IV é livre de contexto.",
    "e) Nenhuma das gramáticas é livre de contexto."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens Formais, Autômatos e Computabilidade",
  "subarea": "Linguagens Regulares, Livres-de-Contexto e Sensíveis-ao-Contexto",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - linguagens formais, automatos e computabilidade - linguagens regulares, livres-de-contexto e sensiveis-ao-contexto"
},

{
  "id": "2008-50",
  "edicao": 2008,
  "numero": 50,
  "enunciado": "Numa loja existem três sensores: de fumaça, de movimento de pessoas e de porta aberta. Qualquer um desses sensores, quando detecta alguma das situações para as quais foram projetados, envia um sinal com nível lógico alto (A=1 para fumaça, B=1 para movimento e C=1 para porta aberta). Entretanto, apenas a informação referente à existência de fumaça na loja deverá automaticamente acionar o corpo de bombeiros, via comando Y.\n\nAdmitindo-se que, nas situações em que o corpo de bombeiros deve ser acionado, a saída referente ao comando deverá estar em nível lógico alto (Y=1), assinale a expressão lógica que representa **corretamente** o acionamento do corpo de bombeiros.",
  "alternativas": [
    "a) $Y = ABC + \\overline{ABC}$",
    "b) $Y = A \\oplus B \\oplus C$",
    "c) $Y = A + B + C$",
    "d) $Y = A$",
    "e) $Y = ABC$"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Circuitos Digitais",
  "subarea": "Representação e Manipulação de Circuitos Combinatórios",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - circuitos digitais - representacao e manipulacao de circuitos combinatorios"
},

{
  "id": "2008-51",
  "edicao": 2008,
  "numero": 51,
  "enunciado": "Considere o seguinte termo do cálculo-lambda:\n$$\nM = (\\lambda x . \\lambda y . x ) ( \\lambda u .\\lambda z .u )\n$$\nConsiderando a forma normal que resulta da redução completa do termo M , assinale a alternativa **CORRETA**.",
  "alternativas": [
    "a) $(\\lambda y . z )$",
    "b) $(\\lambda x . x ) (\\lambda z . z )$",
    "c) $( \\lambda y . (\\lambda u .\\lambda z .u ) )$",
    "d) $(\\lambda x . \\lambda y . x )$",
    "e) Nenhuma das formas acima."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens Formais, Autômatos e Computabilidade",
  "subarea": "Tese de Church",
  "gabarito": "C",
  "atributo_rag": "fundamentos da computacao - linguagens formais, automatos e computabilidade - tese de church"
},

{
  "id": "2008-52",
  "edicao": 2008,
  "numero": 52,
  "enunciado": "Analise as seguintes afirmativas.\n\nI. Condições de corrida podem ocorrer se múltiplas *threads* fazem leituras de um dado compartilhado, mesmo que nenhuma realize escritas. \\\nII. O uso de *mutex* para a exclusão mútua em seções críticas garante que não haja condição de corrida, porém pode ocasionar *deadlocks* se não for corretamente empregado. \\\nIII. Monitores são baseados em um tipo abstrato de dados e um controle de acesso aos dados. Apenas funções do monitor acessam os dados e apenas uma *thread* ou processo pode executar funções de um monitor por vez. \\\nIV. Semáforos têm duas operações, P( ) e V( ), sendo que apenas a operação P( ) pode bloquear um processo ou *thread*.\n\nA análise permite concluir que",
  "alternativas": [
    "a) apenas as afirmativas I, II e III são verdadeiras.",
    "b) apenas as afirmativas I, III e IV são verdadeiras.",
    "c) apenas as afirmativas II e IV são verdadeiras.",
    "d) apenas as afirmativas II, III e IV são verdadeiras.",
    "e) nenhuma das afirmativas é verdadeira."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Sistemas Operacionais",
  "subarea": "Comunicação, Concorrência e Sincronização de Processos",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - sistemas operacionais - comunicacao, concorrencia e sincronizacao de processos"
},

{
  "id": "2008-53",
  "edicao": 2008,
  "numero": 53,
  "enunciado": "Analise as seguintes afirmativas.\n\nI. O gerenciamento de operações de entrada e saída permite o compartilhamento de periféricos entre múltiplos processos. \\\nII. O gerenciamento de memória depende do hardware, mais especificamente da MMU (*Memory Management Unit*) para definir se partições, paginação ou segmentação podem ser usadas. \\\nIII. Os sistemas operacionais de tempo compartilhado não necessitam de interrupções para sua implementação. \\\nIV. O algoritmo FIFO (*First In, First Out*) de escalonamento de processos é inerentemente preemptivo.\n\nA análise permite concluir que",
  "alternativas": [
    "a) apenas as afirmativas I e II são verdadeiras.",
    "b) apenas as afirmativas I, II e III são verdadeiras.",
    "c) apenas as afirmativas I, II e IV são verdadeiras.",
    "d) apenas as afirmativas II e IV são verdadeiras.",
    "e) nenhuma das afirmativas é verdadeira."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Sistemas Operacionais",
  "subarea": "Gerenciamento de Dispositivos de Entrada/Saída",
  "gabarito": "A",
  "atributo_rag": "fundamentos da computacao - sistemas operacionais - gerenciamento de dispositivos de entrada/saida"
},

{
  "id": "2008-54",
  "edicao": 2008,
  "numero": 54,
  "enunciado": "Um processador tem cinco estágios de *pipeline*. Suponha que cada uma das etapas do processador (busca, decodificação, execução, leitura ou escrita de dados em memória e escrita em registrador) seja executada em 5ns. \\\nO tempo total para que 5 instruções sejam executadas em *pipeline*, supondo que não haja dependência de dados entre as instruções é",
  "alternativas": [
    "a) 15ns",
    "b) 25ns",
    "c) 30ns",
    "d) 45ns",
    "e) 50ns"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Arquitetura e Organização de Computadores",
  "subarea": "Pipeline",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - arquitetura e organizacao de computadores - pipeline"
},

{
  "id": "2008-55",
  "edicao": 2008,
  "numero": 55,
  "enunciado": "Analise as seguintes afirmativas.\n\nI. O processador que apresenta o melhor desempenho é sempre aquele que tem a frequência de relógio mais alta. \\\nII. A técnica de *pipeline* é utilizada para aumentar o desempenho em processadores. Dessa forma, o *pipeline* alivia o tempo de latência das instruções. \\\nIII. A maneira mais simples de aumentar a taxa de acertos em memória cache é\naumentar a sua capacidade. \\\nIV. Em arquiteturas superescalares, os efeitos das dependências e antidependências de dados são reduzidos na etapa de renomeação de registradores.\n\nA análise permite concluir que",
  "alternativas": [
    "a) todas as afirmativas são verdadeiras.",
    "b) somente as afirmativas II e III são verdadeiras.",
    "c) somente as afirmativas III e IV são verdadeiras.",
    "d) somente as afirmativas II, III e IV são verdadeiras.",
    "e) nenhuma das afirmativas é verdadeira."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Arquitetura e Organização de Computadores",
  "subarea": "Organização de Computadores: Memórias, Unidades Centrais de Processamento, Entrada e Saída",
  "gabarito": "C",
  "atributo_rag": "fundamentos da computacao - arquitetura e organizacao de computadores - organizacao de computadores: memorias, unidades centrais de processamento, entrada e saida"
},

{
  "id": "2009-21",
  "edicao": 2009,
  "numero": 21,
  "enunciado": "A sequência de Fibonacci é uma sequência de inteiros, cujo primeiro termo é 0, o segundo termo é 1, e a partir do terceiro, cada termo é igual à soma dos dois anteriores.\nO seguinte algoritmo recursivo retorna o $n$-ésimo termo da sequência\n```\nProcedimento F(n)\n    se n < 3 então retornar n-1\n    senão retornar F(n-1) + F(n-2)\n```\nA chamada externa é `F(n)`, sendo $n > 0$. \n\nAssinale a alternativa CORRETA:",
  "alternativas": [
    "a) O algoritmo não está correto, pois não retorna o $n$-ésimo termo da sequência.",
    "b) O algoritmo é ótimo, no que diz respeito ao número de passos.",
    "c) O número de passos efetuados pelo algoritmo é linear em $n$.",
    "d) O número de passos efetuados pelo algoritmo é polinomial em $n$.",
    "e) O número de passos efetuados pelo algoritmo é exponencial em $n$."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Algoritmos e Estrutura de Dados",
  "subarea": "Recursividade: Conceito e Implementação",
  "gabarito": "E",
  "atributo_rag": "fundamentos da computacao - algoritmos e estrutura de dados - recursividade: conceito e implementacao"
},

{
  "id": "2009-22",
  "edicao": 2009,
  "numero": 22,
  "enunciado": "Deseja-se efetuar uma busca para localizar uma certa chave fixa $x$, em uma tabela contendo $n$ elementos. A busca considerada pode ser a linear ou binária. No primeiro caso pode-se considerar que a tabela esteja ordenada ou não. No segundo caso a tabela está, de forma óbvia, ordenada. \n\nAssinale a alternativa CORRETA:",
  "alternativas": [
    "a) A busca binária sempre localiza $x$, efetuando menos comparações que a busca linear.",
    "b) A busca linear ordenada sempre localiza $x$, efetuando menos comparações que a não ordenada.",
    "c) A busca linear não ordenada sempre localiza $x$, com menos comparações que a ordenada.",
    "d) A busca binária requer $O(log n)$ comparações, no máximo, para localizar $x$.",
    "e) A busca linear ordenada nunca requer mais do que $n/2$ comparações para localizar $x$."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Algoritmos e Estrutura de Dados",
  "subarea": "Algoritmos para Pesquisa e Ordenação",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - algoritmos e estrutura de dados - algoritmos para pesquisa e ordenacao"
},

{
  "id": "2009-23",
  "edicao": 2009,
  "numero": 23,
  "enunciado": "Considere o seguinte programa escrito em C:\n```\n#include<stdio.h>\n#include<string.h>\nint main (void)\n{\n   char texto[]= \"foi muito facil\";\n   int i;\n\n   for (i = 0; i < strlen(texto); i++)\n   {\n        if (texto[i] == ' ') break;\n   }\n   i++;\n\n   for ( ; i < strlen(texto); i++)\n   {\n        printf(\"%c\", texto[i]);\n   }\n    return 0;\n}\n```\nO que será impresso quando o programa for executado?",
  "alternativas": [
    "a) `foi muito facil`",
    "b) `facil`",
    "c) `muito facil`",
    "d) `uito facil`",
    "e) `acil`"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Técnicas de Programação",
  "subarea": "Comandos de uma Linguagem de programação",
  "gabarito": "C",
  "atributo_rag": "fundamentos da computacao - tecnicas de programacao - comandos de uma linguagem de programacao"
},

{
  "id": "2009-24",
  "edicao": 2009,
  "numero": 24,
  "enunciado": "Assinalar a afirmativa correta, em relação a um grafo completo $G$ com $n > 2$ vértices.",
  "alternativas": [
    "a) O grau de cada vértice é $n$.",
    "b) O número cromático de $G$ é igual a $n-1$.",
    "c) $G$ não pode ser um grafo bipartido.",
    "d) $G$ possui caminho hamiltoniano.",
    "e) $G$ possui ciclo euleriano."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Teoria dos Grafos",
  "subarea": "Grafos orientados e não-orientados",
  "gabarito": "ANULADA",
  "atributo_rag": "fundamentos da computacao - teoria dos grafos - grafos orientados e nao-orientados"
},

{
  "id": "2009-25",
  "edicao": 2009,
  "numero": 25,
  "enunciado": "Dada uma rede de interconexão estática com topologia hipercúbica de dimensão seis, com 64 nós, considere as afirmativas a seguir:\n\nI. Os nós com numeração binária igual a 010101 e 101010 são vizinhos. \\\nII. São necessários 192 canais (*links*) para a construção desta rede. \\\nIII. Existem 5 nós conectados diretamente ao nó 111000. \\\nIV. O maior caminho mínimo entre dois nós da rede é igual a 6. \\\nV. Se cada canal (*link*) da rede tem taxa de transmissão de 100 Mb/s, a largura de banda da bisseção é igual a 3,2 Gb/s. \n\nAssinale a alternativa CORRETA:",
  "alternativas": [
    "a) Apenas a afirmativa IV está correta.",
    "b) Apenas as afirmativas III e IV estão corretas.",
    "c) Apenas as afirmativas Ie V estão corretas.",
    "d) Apenas as afirmativas II, IV e V estão corretas.",
    "e) Todas as afirmativas estão corretas."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Arquitetura e Organização de Computadores",
  "subarea": "Barramento, Comunicações, Interfaces e Periféricos",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - arquitetura e organizacao de computadores - barramento, comunicacoes, interfaces e perifericos"
},

{
  "id": "2009-26",
  "edicao": 2009,
  "numero": 26,
  "enunciado": "Considere uma arquitetura de memória com as seguintes características:\n- Memória logicamente particionada em segmentos paginados.\n- Endereços virtuais de 32 bits: 8 para segmentos, 11 para páginas, o restante para o endereçamento na página.\n- Endereços físicos de 20 bits e páginas de 8KB.\n\nCaso o particionamento lógico fosse o de paginação pura, a relação entre o número de páginas virtuais e o número de frames seria equivalente a:",
  "alternativas": [
    "a) 8192",
    "b) 4096",
    "c) 1024",
    "d) 128",
    "e) 32"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Arquitetura e Organização de Computadores",
  "subarea": "Organização de Memória",
  "gabarito": "B",
  "atributo_rag": "fundamentos da computacao - arquitetura e organizacao de computadores - organizacao de memoria"
},

{
  "id": "2009-27",
  "edicao": 2009,
  "numero": 27,
  "enunciado": "Considere as estruturas de dados a seguir.\n\n- Uma lista é um conjunto de dados onde cada elemento contido na lista ocupa sozinho uma posição de 1 até $n$, onde $n$ é a quantidade de elementos na lista. Uma inserção ou remoção pode ser realizada em qualquer posição da lista.\n- Uma fila é um caso especial de lista onde a inserção só pode ser realizada em uma extremidade e uma remoção na outra.\n- Uma pilha é um caso especial de lista onde uma inserção ou uma remoção só\npodem ser realizadas em uma extremidade.\n\nAnalise as afirmativas seguintes sobre essas estruturas de dados:\n\nI. Uma fila pode ser implementada usando duas pilhas; \\\nII. Uma pilha pode ser implementada usando duas filas; \\\nIII. Uma lista pode ser implementada usando uma fila e uma pilha. \n\nAssinale a alternativa CORRETA:",
  "alternativas": [
    "a) Apenas a afirmativa I está correta.",
    "b) Apenas a afirmativa II está correta.",
    "c) Apenas a afirmativa III está correta.",
    "d) Apenas as afirmativas I e II estão corretas.",
    "e) Apenas as afirmativas I e III estão corretas."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Algoritmos e Estrutura de Dados",
  "subarea": "Estruturas de Dados Lineares e suas Generalizações: Listas Ordenadas, Listas Encadeadas, Pilhas e Filas",
  "gabarito": "ANULADA",
  "atributo_rag": "fundamentos da computacao - algoritmos e estrutura de dados - estruturas de dados lineares e suas generalizacoes: listas ordenadas, listas encadeadas, pilhas e filas"
},

{
  "id": "2009-28",
  "edicao": 2009,
  "numero": 28,
  "enunciado": "Considere uma árvore binária de busca $T$ com $n$ nós e altura $h$. A altura de uma árvore é o número máximo de nós de um caminho entre a raiz e as folhas. Analise as afirmativas a seguir:\n\nI. $h < 1 + \\log_2n$; \\\nII. Todo nó que pertence à subárvore esquerda de um nó $x$ tem valor maior que o pai de $x$. \\\nIII. Uma busca em ordem simétrica (*in-order*) em $T$ produz uma ordenação crescente dos elementos de $T$. \n\nAssinale a alternativa CORRETA:",
  "alternativas": [
    "a) Apenas a afirmativa I está correta;",
    "b) Apenas a afirmativa II está correta;",
    "c) Apenas a afirmativa III está correta;",
    "d) Apenas as afirmativas I e II estão corretas;",
    "e) Apenas as afirmativas I e III estão corretas."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Algoritmos e Estrutura de Dados",
  "subarea": "Árvores e suas Generalizações: Árvores Binárias, Árvores de Busca e Árvores Balanceadas",
  "gabarito": "C",
  "atributo_rag": "fundamentos da computacao - algoritmos e estrutura de dados - arvores e suas generalizacoes: arvores binarias, arvores de busca e arvores balanceadas"
},

{
  "id": "2009-29",
  "edicao": 2009,
  "numero": 29,
  "enunciado": "A função PASCAL-like abaixo deve implementar o algoritmo de busca binária num vetor de inteiros A, com N elementos, ordenado crescentemente, onde o argumento v é a chave de busca.\n```\nfunction buscabinaria (v:integer);\n   var x, e, d : integer;\nbegin\n   e :=1;\n   d := N;\n   repeat\n      x := (e+d) div 2;\n      if v < A[x]    then d := x-1\n                     else e := x+1\n   until ............\n   if v=A[x]         then buscabinaria := x\n                     else buscabinaria := N+1\nend;\n```\nPara que isso ocorra, o trecho pontilhado no corpo da função deve ser substituído por:",
  "alternativas": [
    "a) `(v=A[x]) or (e>d);`",
    "b) `(v=A[x]) and (e>d);`",
    "c) `(v=A[x]);`",
    "d) `(e>d);`",
    "e) `not ((v=A[x]) or (e>d));`"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Algoritmos e Estrutura de Dados",
  "subarea": "Algoritmos para Pesquisa e Ordenação",
  "gabarito": "A",
  "atributo_rag": "fundamentos da computacao - algoritmos e estrutura de dados - algoritmos para pesquisa e ordenacao"
},

{
  "id": "2009-31",
  "edicao": 2009,
  "numero": 31,
  "enunciado": "Considere uma tabela de espalhamento (tabela *hash*) de comprimento $m = 11$, que usa endereçamento aberto (*open addressing*), a técnica de tentativa linear (*linear probing*) para resolver colisões e com a função de dispersão (função *hash*) $h(k) = k \\mod m$, onde $k$ é a chave a ser inserida. Considere as seguintes operações sobre essa tabela:\n\n- Inserção das chaves 3, 14, 15, 92, 65, 35 (nesta ordem);\n- Remoção da chave 15; e\n- Inserção da chave 43.\n\nEscolha a opção que representa esta tabela após estas operações:",
  "alternativas": [
    "a) $ 65 - \\varnothing - 35 - 14 - \\varnothing - 92 - 3 - \\varnothing - \\varnothing - \\varnothing - 43 $",
    "b) $ 43 - \\varnothing - 35 - 3 - 14 - 92 - \\varnothing - \\varnothing - \\varnothing - 65 $",
    "c) $ 65 - \\varnothing - 35 - X - 14 - 92 - 3 - \\varnothing - \\varnothing - \\varnothing - 43 $",
    "d) $ 65 - \\varnothing - 35 - 3 - 14 - 92 - \\varnothing - \\varnothing - \\varnothing - 43 $",
    "e) $ 43 - \\varnothing - 35 - 3 - 14 - X - 92 - \\varnothing - \\varnothing - \\varnothing - 65 $"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Algoritmos e Estrutura de Dados",
  "subarea": "Tabelas Hash",
  "gabarito": "E",
  "atributo_rag": "fundamentos da computacao - algoritmos e estrutura de dados - tabelas hash"
},

{
  "id": "2009-32",
  "edicao": 2009,
  "numero": 32,
  "enunciado": "O que imprime o programa escrito em “C” abaixo?\n```\nint f (int a [], int n) {\n   if (n <= 0) return 1;\n   return a[n-1] * f (a, n-2) + 1;\n}\n\nint a [6] = { 0, 1, 2, 3, 4, 5};\n\n#include <stdio.h>\nint main() {\n   printf (\"%d\\n\", f(a,6));\n}\n```",
  "alternativas": [
    "a) 35",
    "b) 36",
    "c) 49",
    "d) 79",
    "e) 1957"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens de Programação",
  "subarea": "Paradigmas de Linguagens de Programação",
  "gabarito": "B",
  "atributo_rag": "fundamentos da computacao - linguagens de programacao - paradigmas de linguagens de programacao"
},

{
  "id": "2009-34",
  "edicao": 2009,
  "numero": 34,
  "enunciado": "Dado um conjunto $C$ contendo $n$ inteiros distintos, qual das seguintes estruturas de dados em memória principal permite construir um algoritmo para encontrar o valor máximo de $C$ em tempo constante?",
  "alternativas": [
    "a) Um vetor não ordenado.",
    "b) Um vetor ordenado.",
    "c) Uma árvore binária de busca balanceada.",
    "d) Uma lista encadeada simples ordenada em ordem crescente.",
    "e) Uma árvore rubro-negra."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Algoritmos e Estrutura de Dados",
  "subarea": "Tipos de Dados Básicos e Estruturados",
  "gabarito": "B",
  "atributo_rag": "fundamentos da computacao - algoritmos e estrutura de dados - tipos de dados basicos e estruturados"
},

{
  "id": "2009-35",
  "edicao": 2009,
  "numero": 35,
  "enunciado": "Seja o alfabeto $\\Sigma = \\{a, b\\}$ e a linguagem regular\n$$\nL = \\{\\omega \\mid \\omega \\in \\Sigma^* \\text{ e o nº de } a\\text{'s em } \\omega \\text{ é par} \\}.\n$$\nQual das expressões regulares abaixo gera essa linguagem?",
  "alternativas": [
    "a) $(ab^*a b^*)^*$",
    "b) $((aa)^*|b^*)^*$",
    "c) $(b^*| (aa )^* | b^*)^*$",
    "d) $(b^*a b^*ab^*)^*$",
    "e) $(aa |b)^*$"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens Formais, Autômatos e Computabilidade",
  "subarea": "Linguagens Regulares, Livres-de-Contexto e Sensíveis-ao-Contexto",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - linguagens formais, automatos e computabilidade - linguagens regulares, livres-de-contexto e sensiveis-ao-contexto"
},

{
  "id": "2009-36",
  "edicao": 2009,
  "numero": 36,
  "enunciado": "Considere as seguintes afirmativas relativas à ocorrência de \"deadlocks\" (ou impasses).\n\nI. A estratégia de tratamento de \"deadlocks\" conhecida como prevenção requer que se determine uma condição suficiente a que eles ocorram. Uma vez determinada a condição, os algoritmos de manipulação dos recursos compartilhados em questão devem ser projetados de forma que,\ngarantidamente, ela jamais ocorra. \\\nII. A estratégia de tratamento de \"deadlocks\" conhecida como detecção requer que se determine uma condição suficiente a que eles ocorram. Uma vez determinada a condição, o tratamento por detecção consiste em verificar sua validade e, em caso afirmativo, concluir que existe um \"deadlock\". \\\nIII. As estratégias conhecidas como prevenção e detecção para o tratamento de\n\"deadlocks\" são complementares uma à outra: Enquanto a primeira guia o projeto dos algoritmos de compartilhamento de recursos para que \"deadlocks\" jamais ocorram, a segunda trata de impedir que ocorram quaisquer condições necessárias à ocorrência de \"deadlocks\". \\\nIV. Para que ocorra um \"deadlock\" é necessário que haja um ciclo de espera envolvendo um determinado conjunto de processos. Uma estratégia comum de prevenção é a criação de algoritmos de compartilhamento de recursos que impeçam a ocorrência desses ciclos. \n\nAssinale a alternativa CORRETA:",
  "alternativas": [
    "a) Apenas a afirmativa I é verdadeira.",
    "b) Apenas a afirmativa II é verdadeira.",
    "c) Apenas as afirmativas I e III são verdadeiras.",
    "d) Apenas as afirmativas II e III são verdadeiras.",
    "e) Apenas as afirmativas Il e IV são verdadeiras."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Sistemas Operacionais",
  "subarea": "Comunicação, Concorrência e Sincronização de Processos",
  "gabarito": "E",
  "atributo_rag": "fundamentos da computacao - sistemas operacionais - comunicacao, concorrencia e sincronizacao de processos"
},

{
  "id": "2009-37",
  "edicao": 2009,
  "numero": 37,
  "enunciado": "Considere as afirmativas abaixo:\n\nI. Fortran, Pascal e Java são linguagens de terceira geração. \\\nII. C++ e Java permitem a criação de classes e o uso de herança múltipla. \\\nIII. Prolog é uma linguagem funcional pura. \\\nIV. PHP, Perl e Ruby são linguagens de sexta geração. \n\nAssinale a alternativa CORRETA:",
  "alternativas": [
    "a) Apenas a afirmativa I é verdadeira.",
    "b) Apenas a afirmativa II é verdadeira.",
    "c) Apenas a afirmativa III é verdadeira.",
    "d) Apenas as afirmativas I e IV são verdadeiras.",
    "e) Apenas as afirmativas II e III são verdadeiras."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens de Programação",
  "subarea": "Paradigmas de Linguagens de Programação",
  "gabarito": "A",
  "atributo_rag": "fundamentos da computacao - linguagens de programacao - paradigmas de linguagens de programacao"
},

{
  "id": "2009-38",
  "edicao": 2009,
  "numero": 38,
  "enunciado": "Após a execução do pedaço de programa a seguir, escrito na linguagem de montagem do 8086, que valores estarão em AL e BL?\n\n```\n; if 25=10 then VAR = 30\nMOV AL, 25\nMOV BL, 10\nCMP AL, BL\nJNZ rot1\nMOV AL, 30\nMOV VAR, AL\nrot1:\n...\n...\nVAR DB 0\n```",
  "alternativas": [
    "a) `AL=15 BL=10`",
    "b) `AL=25 BL=10`",
    "c) `AL=15 BL=30`",
    "d) `AL=25 BL=30`",
    "e) `AL=30 BL=10`"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Arquitetura e Organização de Computadores",
  "subarea": "Linguagens de Montagem",
  "gabarito": "B",
  "atributo_rag": "fundamentos da computacao - arquitetura e organizacao de computadores - linguagens de montagem"
},

{
  "id": "2009-40",
  "edicao": 2009,
  "numero": 40,
  "enunciado": "Assinale a alternativa FALSA.",
  "alternativas": [
    "a) O conjunto de todas as Máquinas de Turing é enumerável.",
    "b) O conjunto de todas as Expressões Regulares é enumerável.",
    "c) Toda Linguagem Regular é enumerável.",
    "d) Todo Conjunto Finito é enumerável.",
    "e) Nenhum Conjunto Infinito é enumerável."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens Formais, Autômatos e Computabilidade",
  "subarea": "Máquina de Turing",
  "gabarito": "E",
  "atributo_rag": "fundamentos da computacao - linguagens formais, automatos e computabilidade - maquina de turing"
},

{
  "id": "2009-41",
  "edicao": 2009,
  "numero": 41,
  "enunciado": "Quais das seguintes propriedades não se aplicam a árvores rubro-negras?",
  "alternativas": [
    "a) Todo nó é vermelho ou preto.",
    "b) Todo nó folha é preto.",
    "c) Se um nó é preto, ambos seus filhos são vermelhos.",
    "d) Se um nó é vermelho, ambos seus filhos são negros.",
    "e) Todos os caminhos simples entre um nó e suas folhas descendentes contêm o mesmo número de nós pretos."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Algoritmos e Estrutura de Dados",
  "subarea": "Árvores e suas Generalizações: Árvores Binárias, Árvores de Busca e Árvores Balanceadas",
  "gabarito": "C",
  "atributo_rag": "fundamentos da computacao - algoritmos e estrutura de dados - arvores e suas generalizacoes: arvores binarias, arvores de busca e arvores balanceadas"
},

{
  "id": "2009-42",
  "edicao": 2009,
  "numero": 42,
  "enunciado": "Suponha que a tabela a seguir apresenta a frequência de cada letra de um alfabeto em uma *string*. Quantos bits seriam necessários para representar essa string usando um código de Huffman?\n\n| Letra      | a  | b  | c  | d  | e  | f  |\n|------------|----|----|----|----|----|----|\n| Frequência | 20 | 10 | 8  | 5  | 4  | 2  |",
  "alternativas": [
    "a) 392",
    "b) 147",
    "c) 113",
    "d) 108",
    "e) Nenhuma das respostas anteriores."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Organização de Arquivos e Dados",
  "subarea": "Algoritmos de Codificação e Decodificação",
  "gabarito": "C",
  "atributo_rag": "fundamentos da computacao - organizacao de arquivos e dados - algoritmos de codificacao e decodificacao"
},

{
  "id": "2009-43",
  "edicao": 2009,
  "numero": 43,
  "enunciado": "Considere as afirmativas abaixo:\n\nI. A linguagem Java possui tipos de dados primitivos. \\\nII. Nas linguagens de programação de terceira geração, o desempenho de uma operação com uma matriz é independente da forma como elas são organizadas em memória. \\\nIII. Uma estrutura de dados do tipo união (*union*) é representada em memória da mesma forma que um registro (*record*). \n\nAssinale a alternativa CORRETA:",
  "alternativas": [
    "a) Apenas a afirmativa I é verdadeira.",
    "b) Apenas a afirmativa II é verdadeira.",
    "c) Apenas a afirmativa III é verdadeira.",
    "d) Todas as afirmativas são verdadeiras.",
    "e) Nenhuma das afirmativas é verdadeira."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens de Programação",
  "subarea": "Teoria dos Tipos: Sistemas de Tipos, Polimorfismo",
  "gabarito": "A",
  "atributo_rag": "fundamentos da computacao - linguagens de programacao - teoria dos tipos: sistemas de tipos, polimorfismo"
},

{
  "id": "2009-44",
  "edicao": 2009,
  "numero": 44,
  "enunciado": "Dada a seguinte expressão em LISP, qual o seu resultado?\n```\n(CAR (CDR (CDR '( A B C D E )))\n```",
  "alternativas": [
    "a) `A`",
    "b) `B`",
    "c) `C`",
    "d) `D`",
    "e) `nil`"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens de Programação",
  "subarea": "Paradigmas de Linguagens de Programação",
  "gabarito": "C",
  "atributo_rag": "fundamentos da computacao - linguagens de programacao - paradigmas de linguagens de programacao"
},

{
  "id": "2009-46",
  "edicao": 2009,
  "numero": 46,
  "enunciado": "Qual o resultado do programa em Java a seguir:\n```\npublic class Prova {\n   static int v1;\n   int v2;\n\n   static { v1=1 ;}\n   { v2 = 2; }\n\n   void troca() {\n      v1=v2 ;\n   }\n\n   public static void main(String[] args) {\n      Prova a=new Prova();\n      Prova b=new Prova();\n      a.v2=5;\n      a.troca();\n      System.out.print(a.v1);\n      System.out.print(a.v2);\n      System.out.print(b.v1);\n      System.out.print(b.v2);\n    }\n}\n```",
  "alternativas": [
    "a) 1522",
    "b) 5512",
    "c) 1512",
    "d) 5552",
    "e) Nenhuma das respostas anteriores."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens de Programação",
  "subarea": "Paradigmas de Linguagens de Programação",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - linguagens de programacao - paradigmas de linguagens de programacao"
},

{
  "id": "2009-47",
  "edicao": 2009,
  "numero": 47,
  "enunciado": "Seja o programa em Prolog a seguir:\n```\npai(abel, bernardo).\npai(abel, bia).\nmae(ana, bernardo).\nmae(ana, bia).\n\nparenteSimples(X,Y) :- pai(xX,Y).\nparenteSimples(X,Y) :- mae(X,Y).\n\nirmao(X,Y) :- parenteSimples(Z,X), parenteSimples(Z,Y),X \\=Y.\n```\nQual a resposta para a entrada:\n\n```\nirmao(X,Y).\n```\n\nSupondo que para cada resposta do programa é digitado “;” (ponto e vírgula).",
  "alternativas": [
    "a) \n```\nX = bernardo,\nY = bia ;\nX = bia,\nY = bernardo ;\nfalse.\n```",
    "b)\n```\nX = bernardo,\nY = bia ;\nX = bernardo,\nY = bia ;\nX = bia,\nY = bernardo ;\nX = bia,\nY = bernardo ;\nfalse.\n```",
    "c) \n```\nX = bernardo,\nY = bia ;\nX = bia,\nY = bernardo ;\nX = bernardo,\nY = bia ;\nX = bia,\nY = bernardo ;\nfalse.\n```",
    "d) \n```\nX = bernardo,\nY = bia ;\nfalse.\n```",
    "e) Nenhuma das respostas anteriores."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens de Programação",
  "subarea": "Paradigmas de Linguagens de Programação",
  "gabarito": "C",
  "atributo_rag": "fundamentos da computacao - linguagens de programacao - paradigmas de linguagens de programacao"
},

{
  "id": "2009-50",
  "edicao": 2009,
  "numero": 50,
  "enunciado": "Dado o programa em Pascal a seguir, qual o valor impresso no final?\n\n```\nprogram project1;\n\nvar\n   v1 : integer;\n   v2 : integer;\n\nprocedure a;\nvar \n   v1 : integer;\nbegin\n   v1 := 1;\n   v2 := 2; \nend;\n\nprocedure b(var v1 : integer; v2:integer) ;\nbegin\n   v1 := 3;\n   v2 := 4;  \nend;\n\nbegin\n   v1:=5;\n   v2:=6;\n   a;\n   b(v2,v1);\n   writeln(vi,' ',v2);\nend.\n```",
  "alternativas": [
    "a) 3 5",
    "b) 4 3",
    "c) 3 4",
    "d) 5 6",
    "e) 5 3"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens de Programação",
  "subarea": "Paradigmas de Linguagens de Programação",
  "gabarito": "E",
  "atributo_rag": "fundamentos da computacao - linguagens de programacao - paradigmas de linguagens de programacao"
},

{
  "id": "2010-21",
  "edicao": 2010,
  "numero": 21,
  "enunciado": "Um estudante de computação precisa resolver um problema bastante importante, que é executar as operações que estão descritas abaixo, cuja estrutura é uma pilha. Tão logo ele retire algum elemento desta pilha, estes deverão ser inseridos em uma fila, cuja entrada é pela esquerda e a saída, pela direita. \n\nAssinale a alternativa que contém a sequência correta de entrada dos elementos na fila.\n```\nPUSH P\nPUSH E\nPUSH R\nPUSH T\nPUSH O\nPOP\nPOP\nPUSH S\nPUSH O\nPUSH L\nPOP\nPOP\nPOP\n```",
  "alternativas": [
    "a) `S - O - L - T - O`",
    "b) `O - T - R - E - P`",
    "c) `P - E - R - T - O`",
    "d) `O - T - L - O - S`",
    "e) `P - O - R - L - S`"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Algoritmos e Estrutura de Dados",
  "subarea": "Estruturas de Dados Lineares e suas Generalizações: Listas Ordenadas, Listas Encadeadas, Pilhas e Filas",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - algoritmos e estrutura de dados - estruturas de dados lineares e suas generalizacoes: listas ordenadas, listas encadeadas, pilhas e filas"
},

{
  "id": "2010-22",
  "edicao": 2010,
  "numero": 22,
  "enunciado": "Considere o seguinte trecho de programa escrito na linguagem C.\n```\n#include<stdio.h>\n\n...\n  char str[100], *ptr;\n...\n  for (ptr=str;(*ptr++=getchar())!=’\\n’;*ptr=’\\0’);\n...\n```\nPode-se afirmar que o objetivo do comando `for` é:",
  "alternativas": [
    "a) Procurar pelo primeiro caracter `‘\\n’` no vetor `str` e substituí-lo pelo caracter `‘\\0’`.",
    "b) Ler caracteres do *stdin* para região de memório referenciada pela variável `str`.",
    "c) Apresentar no dispositivo de saída a *string* armazenada na região de memória referenciada pela variável `str`.",
    "d) Limpar a área de memória referenciada pela variável `str`, atribuindo o caracter `‘\\0’` a todas as 100 posições.",
    "e) Alocar espaço de memória na região referenciada pela variável `ptr`."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Técnicas de Programação",
  "subarea": "Comandos de uma Linguagem de programação",
  "gabarito": "B",
  "atributo_rag": "fundamentos da computacao - tecnicas de programacao - comandos de uma linguagem de programacao"
},

{
  "id": "2010-23",
  "edicao": 2010,
  "numero": 23,
  "enunciado": "Assinale a alternativa em que todas as propriedades de uma árvore vermelho e preto são verdadeiras.",
  "alternativas": [
    "a) Todo nó é vermelho ou preto. A raiz pode ser vermelha ou preta. Todas as folhas são vermelhas.",
    "b) A raiz é preta. Todas as folhas são vermelhas. Para cada nó, todos os caminhos, desde um nó até as folhas descendentes, contêm um mesmo número de nós pretos.",
    "c) Toda folha é preta. Todo nó é vermelho ou preto. A raiz é preta.",
    "d) Se um nó é vermelho, ambos os filhos são vermelhos. A raiz pode ser vermelha ou preta. Todas as folhas são pretas.",
    "e) Todas as folhas são vermelhas. Todo nó é vermelho ou preto. A raiz pode ser vermelha ou preta."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Algoritmos e Estrutura de Dados",
  "subarea": "Árvores e suas Generalizações: Árvores Binárias, Árvores de Busca e Árvores Balanceadas",
  "gabarito": "C",
  "atributo_rag": "fundamentos da computacao - algoritmos e estrutura de dados - arvores e suas generalizacoes: arvores binarias, arvores de busca e arvores balanceadas"
},

{
  "id": "2010-24",
  "edicao": 2010,
  "numero": 24,
  "enunciado": "Considere a seguinte função escrita na linguagem C.\n```\nint F1 (unsigned int n)\n{\n  if (n==0) return n;\n  int i,j;\n  for (i=j=1;i<2*n-1;i+=2,j+=i);\n  return j;\n}\n```\nAssinale a alternativa que apresenta corretamente a função com o mesmo resultado da função `F1`.",
  "alternativas": [
    "a) \n```\nint F2 (unsigned int n)\n{\n  if (n==0) return n;\n  int i,j;\n  for (i=j=1;i<2*n-1;i++,j*=2);\n  return j;\n}\n```",
    "b) \n```\nint F3 (unsigned int n)\n{\n  if (n==0) return n;\n  int i,j,k;\n  for (i=1,j=2;i<n;i++)\n    for (k=0;k<n;k++,j++);\n  return j;\n}\n```",
    "c) \n```\nint F4 (unsigned int n)\n{\n  if (n==0) return n;\n  int i,j,k;\n  for (i=j=1;i<n;i++,j++)\n    for (k=0;k<n;k++,j++);\n  return j;\n}\n```",
    "d) \n```\nint F5 (unsigned int n)\n{\n  if (n==0) return n;\n  else return 2 * n - 1;\n}\n```",
    "e) \n```\nint F6 (unsigned int n)\n{\n  if (n==0) return n;\n  else return n * (n + 1) * (n + 2) / 6;\n}\n```"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Algoritmos e Estrutura de Dados",
  "subarea": "Comandos de uma Linguagem de Programação",
  "gabarito": "C",
  "atributo_rag": "fundamentos da computacao - algoritmos e estrutura de dados - comandos de uma linguagem de programacao"
},

{
  "id": "2010-25",
  "edicao": 2010,
  "numero": 25,
  "enunciado": "Considere dois algoritmos $A_1$ e $A_2$, cujas funções de custo são, respectivamente, $T_1(n) = n^2 - n + 1$ e $T_2(n) = 6n \\log_2n + 2n$. Para simplificar a análise, assuma que $n > 0$ é sempre uma potência de 2. \\\nCom relação ao enunciado, assinale a alternativa correta.",
  "alternativas": [
    "a) Como $T_1(n) = \\Theta(n^2)$ e $T_2(n) = \\Theta(n \\log n)$, então $A_2$ é sempre mais eficiente que $A_1$.",
    "b) O limite superior $T_1(n) = O(n^3)$ é correto e assintoticamente restrito.",
    "c) O limite inferior $T_2(n) = \\Omega(n^3)$ é correto e assintoticamente restrito.",
    "d) $T_1$ e $T_2$ são assintoticamente equivalentes.",
    "e) $A_1$ é mais eficiente que $A_2$, para $n$ suficientemente pequeno."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Análise de Algoritmos",
  "subarea": "Notação “Big O”, “Little o”, “Omega” e “Theta”",
  "gabarito": "E",
  "atributo_rag": "fundamentos da computacao - analise de algoritmos - notacao “big o”, “little o”, “omega” e “theta”"
},

{
  "id": "2010-26",
  "edicao": 2010,
  "numero": 26,
  "enunciado": "Os algoritmos a seguir representam os três caminhamentos para árvores binárias.\n```\ncaminhamento(binário)\nse binário.esquerda ≠ NULL então caminhamento(binário.esquerda)\nescrever binário.valor\nse binário.direita ≠ NULL então caminhamento(binário.direita)\n\ncaminhamento(binário)\nescrever binário.dado\nse binário.esquerda ≠ NULL então caminhamento(binário.esquerda)\nse binário.direita ≠ NULL então caminhamento(binário.direita)\n\ncaminhamento(binário)\nse binário.esquerda ≠ NULL então caminhamento(binário.esquerda)\nse binário.direita ≠ NULL então caminhamento(binário.direita)\nescrever binário.valor\n```\nAssinale a alternativa que contém os nomes dos 3 caminhamentos, respectivamente.",
  "alternativas": [
    "a) pré-ordem, pós-ordem, em-ordem",
    "b) pré-ordem, em-ordem, pós-ordem",
    "c) pós-ordem, pré-ordem, em-ordem",
    "d) em -ordem , pr é-ordem , pós -ordem",
    "e) em-ordem, pós-ordem, pré-ordem"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Algoritmos e Estrutura de Dados",
  "subarea": "Árvores e suas Generalizações: Árvores Binárias, Árvores de Busca e Árvores Balanceadas",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - algoritmos e estrutura de dados - arvores e suas generalizacoes: arvores binarias, arvores de busca e arvores balanceadas"
},

{
  "id": "2010-27",
  "edicao": 2010,
  "numero": 27,
  "enunciado": "Considere o problema de ordenação onde os vetores a serem ordenados, de tamanho $n > 0$, possuem $\\lfloor n/2 \\rfloor$ valores iguais a um número real $x$ e $\\lceil n/2 \\rceil$ valores iguais a um outro número real $y$. Considere que os números reais $x$ e $y$ são conhecidos e fixos, porém estão distribuídos aleatoriamente no vetor a ser ordenado. \\\nNeste caso, é correto afirmar:",
  "alternativas": [
    "a) Podemos ordenar estes vetores a um custo $O(n)$.",
    "b) No caso médio, o *Quicksort* será o algoritmo mais eficiente para este problema, com um custo $O(n \\log n)$.",
    "c) O algoritmo de ordenação por inserção sempre opera no melhor caso com um custo $O(n)$.",
    "d) O limite inferior para esta classe de problema é $\\Omega(n^2)$.",
    "e) O limite inferior para esta classe de problema é $\\Omega(n \\log n)$."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Análise de Algoritmos",
  "subarea": "Medidas de Complexidade, Análise Assintótica de Limites de Complexidade, Técnicas de Prova de Cotas Inferiores",
  "gabarito": "A",
  "atributo_rag": "fundamentos da computacao - analise de algoritmos - medidas de complexidade, analise assintotica de limites de complexidade, tecnicas de prova de cotas inferiores"
},

{
  "id": "2010-28",
  "edicao": 2010,
  "numero": 28,
  "enunciado": "Com base nos conhecimentos sobre as linguagens de programação funcionais, considere as afirmativas a seguir.\n\nI. Uma linguagem de programação funcional tem o objetivo de imitar as funções matemáticas, ou seja, os programas são definições de funções e de especificações da aplicação dessas funções. \\\nII. Nas linguagens funcionais, os dados e as rotinas para manipulá-los são mantidos em uma mesma unidade, chamada objeto. Os dados só podem ser manipulados por meio das rotinas que estão na mesma unidade. \\\nIII. As rotinas de um programa do paradigma funcional descrevem ações que mudam o estado das variáveis do programa, seguindo uma sequência de comandos para o computador executar. \\\nIV. A linguagem Lisp é um exemplo do paradigma funcional de programação. \n\nAssinale a alternativa correta.",
  "alternativas": [
    "a) Somente as afirmativas I e IV são corretas.",
    "b) Somente as afirmativas II e III são corretas.",
    "c) Somente as afirmativas III e IV são corretas.",
    "d) Somente as afirmativas I, II e III são corretas.",
    "e) Somente as afirmativas I, II e IV são corretas."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens de Programação",
  "subarea": "Paradigmas de Linguagens de Programação",
  "gabarito": "A",
  "atributo_rag": "fundamentos da computacao - linguagens de programacao - paradigmas de linguagens de programacao"
},

{
  "id": "2010-29",
  "edicao": 2010,
  "numero": 29,
  "enunciado": "Considere o programa a seguir, desenvolvido em linguagem C.\n```\n#include <stdio.h>\nint F1(int X, int Y) {\n  if (X < Y) return X;\n  else return F1(X-Y,Y);\n}\nint F2(int X, int Y) {\n  if (X < Y) return 0;\n  else return 1 + F2(X-Y,Y);\n}\nvoid F3(int X, int Y) {\n  if (X < Y) printf(\"%d\",X);\n  else {\n    F3(F2(X,Y),Y);\n    printf(\"%d\",F1(X,Y));\n  }\n}\nint main() {\n  int A, B;\n  scanf(\"%d %d\",&A, &B);\n  if ((A > 0) && (A < 1000)\n      && (B > 1) && (B < 10)) {\n    F3(A,B);\n    printf(\"\\n\");\n  }\n  return 0;\n}\n```\nNo programa apresentado, a técnica da recursividade foi aplicada às três funções `F1`, `F2` e `F3`. Essa técnica envolve a definição de uma função ou rotina que pode invocar a si própria. \\\nCom relação ao programa apresentado e à técnica de recursão, atribua F (falso) ou V (verdadeiro) para as afirmativas a seguir. \\\n( ) A chamada da função `F1`, através da expressão `F1(X,Y)`, pode ser substituída, sem alterar o resultado do programa, pela expressão `X%Y`. \\\n( ) O objetivo da função `F2` é retornar o valor da variável `X` elevado à `Y`-ésima potência. \\\n( ) A chamada à função `F3` entrará em uma recursão sem fim se o valor da variável `X` for maior que o valor da variável `Y`. \\\n( ) A função `main` não é recursiva, pois na Linguagem C não é possível implementar esta técnica na função principal do programa. \\\n( ) A expressão `((A > 0) && (A < 1000) && (B > 1) && (B < 10))`, da função `main`, pode ser substituída pela expressão `(!((A <= 0) || (A >= 1000) || (B <= 1) || (B >= 10)))`, sem afetar o resultado do comando condicional `if` nesta expressão. \n\nAssinale a alternativa que contém, de cima para baixo, a sequência correta.",
  "alternativas": [
    "a) F, V, F, F, V.",
    "b) V, F, F, V, F.",
    "c) V, V, F, V, V.",
    "d) F, V, V, V, F.",
    "e) V, F, F, F, V."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Algoritmos e Estrutura de Dados",
  "subarea": "Recursividade: Conceito e Implementação",
  "gabarito": "E",
  "atributo_rag": "fundamentos da computacao - algoritmos e estrutura de dados - recursividade: conceito e implementacao"
},

{
  "id": "2010-30",
  "edicao": 2010,
  "numero": 30,
  "enunciado": "O mecanismo de herança, no paradigma da programação orientada a objetos, é uma forma de reutilização de software na qual uma nova classe é criada, absorvendo membros de uma classe existente e aprimorada com capacidades novas ou modificadas.\nConsidere as seguintes classes descritas na linguagem C++.\n```\n#include <iostream>\nusing namespace std;\nclass A {\nprotected:\n  int v;\npublic:\n  A() { v = 0; };\n  void m1() {\n    v += 10;\n    m2();\n  };\n\n  void m2() {\n    v += 20;\n  };\n\n  int getv() {\n    return v;\n  };\n};\nclass B : public A {\npublic:\n  void m2() {\n    v += 30;\n  };\n};\n```\nSe essas classes forem utilizadas a partir do programa a seguir,\n```\nint main()\n{\n  B *Obj = new B();\n  Obj->m1();\n  Obj->m2();\n  cout << Obj->getv() << endl;\n  return 0;\n}\n```\na saída do código computacional acima será:",
  "alternativas": [
    "a) 30",
    "b) 40",
    "c) 50",
    "d) 60",
    "e) 70"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens de Programação",
  "subarea": "Paradigmas de Linguagens de Programação",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - linguagens de programacao - paradigmas de linguagens de programacao"
},

{
  "id": "2010-31",
  "edicao": 2010,
  "numero": 31,
  "enunciado": "Sobre tipos *union*, considere as afirmativas a seguir.\n\nI. Uma *union* é um tipo que pode armazenar diferentes valores de tipo durante a execução do programa. \\\nII. Na linguagem C, a *union* é realizada por meio do mecanismo de construção de tipos *struct*. \\\nIII. Na linguagem C++, a *union* é realizada através do mecanismo de construção de tipos *class*. \\\nIV. Nas linguagens Pascal e Ada, a *union* é construída mediante um registro variante, permitindo que a verificação de tipos de cada *union* seja discriminada. \n\nAssinale a alternativa correta.",
  "alternativas": [
    "a) Somente as afirmativas I e II são corretas.",
    "b) Somente as afirmativas I e IV são corretas.",
    "c) Somente as afirmativas III e IV são corretas.",
    "d) Somente as afirmativas I, II e III são corretas.",
    "e) Somente as afirmativas II, III e IV são corretas."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens de Programação",
  "subarea": "Teoria dos Tipos: Sistemas de Tipos, Polimorfismo",
  "gabarito": "B",
  "atributo_rag": "fundamentos da computacao - linguagens de programacao - teoria dos tipos: sistemas de tipos, polimorfismo"
},

{
  "id": "2010-32",
  "edicao": 2010,
  "numero": 32,
  "enunciado": "Considere o algoritmo a seguir.\n```\nPROC (n)\n  se n <= 1 então\n    retorna 1 + n;\n  senão\n    retorna PROC(n/2) + PROC(n/2);\n  fim se\n```\nAssinale a alternativa que indica corretamente quantas comparações são feitas para uma entrada $n > 0$, onde $n$ é um número natural.",
  "alternativas": [
    "a) $n$",
    "b) $\\log n + 1$",
    "c) $n \\log n + 1$",
    "d) $n^2 + n - 1$",
    "e) $2n - 1$"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Análise de Algoritmos",
  "subarea": "O Uso de Relações de Recorrência para Análise de Algoritmos Recursivos",
  "gabarito": "ANULADA",
  "atributo_rag": "fundamentos da computacao - analise de algoritmos - o uso de relacoes de recorrencia para analise de algoritmos recursivos"
},

{
  "id": "2010-33",
  "edicao": 2010,
  "numero": 33,
  "enunciado": "Um computador apresenta um sistema de memória organizado em quatro níveis: memórias cache níveis 1 e 2, memórias RAM principal e secundária. Programas prontos para execução são trazidos da memória secundária e transformados em processos na memória principal. Uma instrução para acessar dados na memória fornece o endereço real de memória onde se localiza a informação desejada. A informação é então buscada na cache nível 1. Se lá não for encontrada, ela é buscada no segundo nível de cache. Não sendo encontrada, a informação é finalmente buscada na memória principal. \n\nQual o modo de endereçamento utilizado?",
  "alternativas": [
    "a) Imediato.",
    "b) Indireto.",
    "c) Direto.",
    "d) Implícito.",
    "e) Relativo."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Arquitetura e Organização de Computadores",
  "subarea": "Modos de Endereçamento, Conjunto de Instruções",
  "gabarito": "C",
  "atributo_rag": "fundamentos da computacao - arquitetura e organizacao de computadores - modos de enderecamento, conjunto de instrucoes"
},

{
  "id": "2010-34",
  "edicao": 2010,
  "numero": 34,
  "enunciado": "Considere o conjunto de operações descritas a seguir, em linguagem de transferência entre registradores.\n```\nF1: REM ← CP;\nF2: RDM ← M[REM], CP ← CP + 1;;\nF3: RI ← RDM; \n```\nDados: `REM` é o registrador de endereços da memória; `RDM` é o registrador de dados da memória; `RI` é o registrador de instruções; `CP` é o contador de programa e `M[X]` é o conteúdo de memória indicado pelo endereço `X`. \n\nAssinale a alternativa que indica a que fase do processamento de uma instrução em uma máquina *pipeline* corresponde o conjunto de operações descrito.",
  "alternativas": [
    "a) Decodificação de instrução.",
    "b) Busca de operando.",
    "c) Execução de instrução.",
    "d) Busca de instrução.",
    "e) Armazenamento de resultado."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Arquitetura e Organização de Computadores",
  "subarea": "Pipeline",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - arquitetura e organizacao de computadores - pipeline"
},

{
  "id": "2010-35",
  "edicao": 2010,
  "numero": 35,
  "enunciado": "Embora ambos tenham seu escalonamento feito pelo gerenciamento de processos, *threads* e processos são estruturalmente distintos. \n\nQual é a principal diferença entre eles?",
  "alternativas": [
    "a) Apenas *threads* podem ser executados em paralelo.",
    "b) *Threads* possuem contexto simplificado.",
    "c) Processos executam mais rapidamente.",
    "d) Processos apenas podem ocorrer em sistemas de grande porte.",
    "e) Threads apenas podem ocorrer em processadores multicore."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Sistemas Operacionais",
  "subarea": "Comunicação, Concorrência e Sincronização de Processos",
  "gabarito": "B",
  "atributo_rag": "fundamentos da computacao - sistemas operacionais - comunicacao, concorrencia e sincronizacao de processos"
},

{
  "id": "2010-36",
  "edicao": 2010,
  "numero": 36,
  "enunciado": "Técnicas eficientes para o uso de memória, como memória virtual e *caching*, podem ser utilizadas porque",
  "alternativas": [
    "a) aumentou o espaço de armazenamento em RAM.",
    "b) memórias dinâmicas são mais rápidas que memórias estáticas.",
    "c) aumentou a velocidade de acesso para a memória RAM.",
    "d) o princípio da localidade pode ser aplicado.",
    "e) o *thrashing* não pode ocorrer em memórias modernas."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Arquitetura e Organização de Computadores",
  "subarea": "Organização de Memória",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - arquitetura e organizacao de computadores - organizacao de memoria"
},

{
  "id": "2010-37",
  "edicao": 2010,
  "numero": 37,
  "enunciado": "Um processador tem um ciclo de operação igual a 20ns. Ele gasta dois ciclos para fazer a busca de uma instrução, um ciclo para decodificar cada instrução, dois ciclos para buscar os operandos necessários e três ciclos para executar a instrução e armazenar o resultado correspondente em algum registrador. Se a organização desta máquina for estritamente sequencial, qual será o período de execução de uma instrução? Se utilizarmos *latches* de 2ns de atraso e considerarmos cada módulo como indivisível, qual será o período do *pipeline* se a máquina for organizada segundo uma estrutura de quatro estágios?",
  "alternativas": [
    "a) Respectivamente 20ns e 22ns.",
    "b) Respectivamente 20ns e 42ns.",
    "c) Respectivamente 20ns e 62ns.",
    "d) Respectivamente 160ns e 42ns.",
    "e) Respectivamente 160ns e 62ns."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Arquitetura e Organização de Computadores",
  "subarea": "Pipeline",
  "gabarito": "E",
  "atributo_rag": "fundamentos da computacao - arquitetura e organizacao de computadores - pipeline"
},

{
  "id": "2010-38",
  "edicao": 2010,
  "numero": 38,
  "enunciado": "Um analista de sistemas foi convidado para opinar sobre por que um determinado sistema tinha desempenho ruim. Considerando que o analista observou que o sistema tinha alta taxa de acesso a disco, por demanda de entrada e saída dos processos, qual das alternativas abaixo pode explicar o baixo desempenho?",
  "alternativas": [
    "a) O sistema operacional gerenciava E/S pelo algoritmo FIFO.",
    "b) O sistema operacional entrava em *deadlock*.",
    "c) O sistema operacional entrava em *starvation*.",
    "d) O sistema operacional gerenciava E/S pelo algoritmo do elevador.",
    "e) O sistema operacional usava dispositivos de DMA."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Sistemas Operacionais",
  "subarea": "Gerenciamento de Dispositivos de Entrada/Saída",
  "gabarito": "A",
  "atributo_rag": "fundamentos da computacao - sistemas operacionais - gerenciamento de dispositivos de entrada/saida"
},

{
  "id": "2010-39",
  "edicao": 2010,
  "numero": 39,
  "enunciado": "Considerando uma função descrita em sua forma canônica de soma de produtos pelos mintermos 3, 7, 11, 12, 13, 14 e 15 de um mapa de Karnaugh e considerando a variável $A$ como o termo de mais alta ordem lógica, $B$ como o de segunda maior ordem, $C$ como o de terceira maior ordem e $D$ como o de menor ordem lógica, determine a sua representação lógica minimizada.",
  "alternativas": [
    "a) $\\bar{A} B + C D$",
    "b) $A B + C D$",
    "c) $A \\bar{B} + C D$",
    "d) $\\bar{A} \\bar{B} + C D$",
    "e) $\\bar{A} \\bar{B} + \\bar{C}\\bar{D}$"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Circuitos Digitais",
  "subarea": "Minimização e Otimização de Funções Combinatórias",
  "gabarito": "B",
  "atributo_rag": "fundamentos da computacao - circuitos digitais - minimizacao e otimizacao de funcoes combinatorias"
},

{
  "id": "2010-42",
  "edicao": 2010,
  "numero": 42,
  "enunciado": "Considerando as linguagens $L_1$ = {$a^lc^mb^n; l \\geq 0, m \\geq 0, n \\geq 0$} e$L_2$ = {$a^lc^mb^n; l \\geq 0, m \\geq 0, n = l + m$} sobre o alfabeto $\\Sigma$ = {$a, b, c$}, considere as afirmativas a seguir.\n\nI.$L_1$  é uma linguagem regular.\\\nII. $L_2$  é uma linguagem regular.\\\nIII. Existe um autômato de pilha determinístico que reconhece $L_1$.\\\nIV. A linguagem $L_2$ pode ser gerada pela G = ({$X, Y$}, {$a, b, c$}, {$X \\to aX b, X \\to Y, Y \\to cY b, Y \\to \\lambda$}, $X$), onde $\\lambda$ é a palavra vazia.\n\nAssinale a alternativa correta.",
  "alternativas": [
    "a) Somente as afirmativas I e II são corretas.",
    "b) Somente as afirmativas II e IV são corretas.",
    "c) Somente as afirmativas III e IV são corretas.",
    "d) Somente as afirmativas I, II e III são corretas.",
    "e) Somente as afirmativas I, III e IV são corretas."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens Formais, Autômatos e Computabilidade",
  "subarea": "Linguagens Regulares, Livres-de-Contexto e Sensíveis-ao-Contexto",
  "gabarito": "E",
  "atributo_rag": "fundamentos da computacao - linguagens formais, automatos e computabilidade - linguagens regulares, livres-de-contexto e sensiveis-ao-contexto"
},

{
  "id": "2010-43",
  "edicao": 2010,
  "numero": 43,
  "enunciado": "Dados dois grafos não orientados $G_1 (V_1, E_1)$ e $G_2 (V_2, E_2)$:\n- $G_1$: $V_1$= {a, b, c} $E_1$ = {(a,b), (b,c), (a, c)}\n- $G_2$: $V_2$= {d, e} $E_2$ = {(d,e)}\n\nQual alternativa apresenta corretamente o grafo $G_r(V, E)$ resultante da soma dos grafos $G_1$ e $G_2$?",
  "alternativas": [
    "a) $G_r$: $V$ = {a, b, c, d, e} $E$ = {(a,b), (b,c), (a,c), (d,e)}",
    "b) $G_r$: $V$ = {a, b, c, d, e} $E$ = {(a,d), (a,e), (b,d), (b,e), (c,d), (c,e), (d,e)}",
    "c) $G_r$: $V$ = {a, b, c, d, e} $E$ = {(a,b), (b,c), (a,c), (a,d), (a,e), (b,d), (b,e), (c,d), (c,e)}",
    "d) $G_r$: $V$ = {a, b, c , d, e} $E$ = {(a,b), (b,c ), (a,c ), (a,d), (a,e), (b,d), (b,e), (c ,d), (c ,e), (d,e)}",
    "e) $G_r$: $V$ = {a, b, c, d, e} $E$ = {(a,b), (b,c), (c,d), (d,e), (e,a)}"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Teoria dos Grafos",
  "subarea": "Grafos orientados e não-orientados",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - teoria dos grafos - grafos orientados e nao-orientados"
},

{
  "id": "2010-44",
  "edicao": 2010,
  "numero": 44,
  "enunciado": "Em relação a autômatos e linguagens, podemos afirmar:",
  "alternativas": [
    "a) Existem linguagens reconhecidas por autômatos finitos não determinísticos que não podem ser reconhecidas por autômatos finitos determinísticos.",
    "b) Existem linguagens reconhecidas por autômatos de pilha não determinísticos que não podem ser reconhecidas por autômatos de pilha determinísticos.",
    "c) Linguagens infinitas somente são reconhecidas por autômatos de pilha.",
    "d) Linguagens regulares não podem ser reconhecidas por autômatos de pilha.",
    "e) Linguagens livres de contexto podem ser reconhecidas por autômatos finitos."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens Formais, Autômatos e Computabilidade",
  "subarea": "Autômatos de Estados Finitos Determinístico e não Determinístico",
  "gabarito": "ANULADA",
  "atributo_rag": "fundamentos da computacao - linguagens formais, automatos e computabilidade - automatos de estados finitos deterministico e nao deterministico"
},

{
  "id": "2010-45",
  "edicao": 2010,
  "numero": 45,
  "enunciado": "Dado um inteiro fixo $k > 0$ e a linguagem $L = \\{a^{2n}c^nb^n; n \\leq k\\}$, podemos afirmar que",
  "alternativas": [
    "a) $L$ é uma linguagem livre de contexto, mas não regular.",
    "b) $L$ é uma linguagem sensível ao contexto, mas não livre dele.",
    "c) $L$ é uma linguagem regular apenas.",
    "d) $L$ é uma linguagem recursiva, mas não sensível ao contexto.",
    "e) $L$ é uma linguagem recursiva, mas não regular."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens Formais, Autômatos e Computabilidade",
  "subarea": "Linguagens Regulares, Livres-de-Contexto e Sensíveis-ao-Contexto",
  "gabarito": "ANULADA",
  "atributo_rag": "fundamentos da computacao - linguagens formais, automatos e computabilidade - linguagens regulares, livres-de-contexto e sensiveis-ao-contexto"
},

{
  "id": "2010-46",
  "edicao": 2010,
  "numero": 46,
  "enunciado": "Qual é o número cromático do grafo $K_{3,2}$?",
  "alternativas": [
    "a) 2",
    "b) 3",
    "c) 4",
    "d) 5",
    "e) 6"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Teoria dos Grafos",
  "subarea": "Coloração",
  "gabarito": "A",
  "atributo_rag": "fundamentos da computacao - teoria dos grafos - coloracao"
},

{
  "id": "2010-47",
  "edicao": 2010,
  "numero": 47,
  "enunciado": "Índices são estruturas de acesso auxiliares usados para aumentar a velocidade de recuperação de registros na resposta a certas condições de busca. \n\nCom base nos conhecimentos sobre índices, considere as afirmativas a seguir.\n\nI. Um índice esparso possui uma entrada de índice para cada valor da chave de busca (portanto, para cada registro) do arquivo de dados. Um índice denso possui entradas de índice para apenas alguns dos valores da chave de busca. \\\nII. Um arquivo de índice é um exemplo de arquivo sequencial; os pares chave-ponteiro podem ser tratados como registros classificados pelo valor da chave de pesquisa. \\\nIII. Um arquivo pode ter, no máximo, um índice secundário, utilizado para ordenar fisicamente os registros do arquivo no disco, porém um arquivo pode ter diversos índices primários, que podem ser especificados sobre qualquer campo de um arquivo. \\\nIV. Inserir ou eliminar registros no arquivo de dados resulta na mesma ação sobre o seu arquivo de índices (se ele for denso), à medida que um par chave-ponteiro para esse registro é inserido ou eliminado. \n\nAssinale a alternativa correta.",
  "alternativas": [
    "a) Somente as afirmativas I e II são corretas.",
    "b) Somente as afirmativas II e IV são corretas.",
    "c) Somente as afirmativas III e IV são corretas.",
    "d) Somente as afirmativas I, II e III são corretas.",
    "e) Somente as afirmativas I, III e IV são corretas."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Organização de Arquivos e Dados",
  "subarea": "Organização, Estrutura e Operação de Arquivos",
  "gabarito": "B",
  "atributo_rag": "fundamentos da computacao - organizacao de arquivos e dados - organizacao, estrutura e operacao de arquivos"
},

{
  "id": "2010-48",
  "edicao": 2010,
  "numero": 48,
  "enunciado": "Um arquivo é organizado logicamente como uma sequência de registros. Esses registros são mapeados em blocos de discos. \n\nCom base no conhecimento sobre organização de arquivos, considere as afirmativas a seguir.\n\nI. As organizações de arquivos sequenciais exigem uma estrutura de índice para localizar os dados. De outra forma, organizações de arquivos baseadas em *hashing* permitem-nos encontrar o endereço de um item de dado diretamente por meio do cálculo de uma função sobre o valor da chave de procura do registro desejado. \\\nII. As operações em arquivos são geralmente divididas em operações de recuperação e operações de atualização: as primeiras não alteram nenhum valor no arquivo, apenas localizam certos registros, de forma que seus valores de campo possam ser examinados e processados; as últimas mudam o arquivo por meio da inclusão ou da exclusão de registros ou pela modificação de valores dos campos. \\\nIII. Registros de tamanho fixo permitem campos repetidos, tamanhos variáveis para um ou mais campos e ainda o armazenamento de múltiplos tipos de registro. \\\nIV. Nos arquivos desordenados (também conhecidos como arquivos pilha), os registros são posicionados no arquivo segundo a ordem pela qual foram incluídos, ou seja, novos registros são acrescentados no final do arquivo. Incluir um novo registro é muito eficiente, entretanto a pesquisa por um registro, usando qualquer condição, envolve uma pesquisa sequencial bloco a bloco do arquivo, procedimento dispendioso. \n\nAssinale a alternativa correta.",
  "alternativas": [
    "a) Somente as afirmativas I e II são corretas.",
    "b) Somente as afirmativas I e III são corretas.",
    "c) Somente as afirmativas III e IV são corretas.",
    "d) Somente as afirmativas I, II e IV são corretas.",
    "e) Somente as afirmativas II, III e IV são corretas."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Organização de Arquivos e Dados",
  "subarea": "Organização, Estrutura e Operação de Arquivos",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - organizacao de arquivos e dados - organizacao, estrutura e operacao de arquivos"
},

{
  "id": "2010-49",
  "edicao": 2010,
  "numero": 49,
  "enunciado": "Em uma Árvore B de ordem $m$, temos que: (i) cada nó contém no mínimo $m$ registros (e $m+1$ descendentes) e no máximo $2m$ registros (e $2m + 1$ descendentes), exceto o nó raiz que pode conter entre $1$ e $2m$ registros; (ii) todas os nós folha aparecem no mesmo nível. Sobre Árvores B, é correto afirmar:",
  "alternativas": [
    "a) O particionamento de nós em uma Árvore B ocorre quando um registro precisa ser inserido em um nó com $2m$ registros.",
    "b) O particionamento de nós em uma Árvore B ocorre quando um registro precisa ser inserido em um nó com menos de $2m$ registros.",
    "c) O particionamento de nós em uma Árvore B ocorre quando a chave do registro a ser inserido contém um valor (conteúdo) intermediário entre os valores das chaves dos registros contidos no mesmo nó.",
    "d) O particionamento de nós ocorre quando é necessário diminuir a altura da árvore.",
    "e) Em uma Árvore B, aumenta em um nível sua altura, toda vez que ocorre o particionamento de um nó."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Algoritmos e Estrutura de Dados",
  "subarea": "Árvores e suas Generalizações: Árvores Binárias, Árvores de Busca e Árvores Balanceadas",
  "gabarito": "A",
  "atributo_rag": "fundamentos da computacao - algoritmos e estrutura de dados - arvores e suas generalizacoes: arvores binarias, arvores de busca e arvores balanceadas"
},

{
  "id": "2010-50",
  "edicao": 2010,
  "numero": 50,
  "enunciado": "Determinar a corretude da conjectura $P \\neq NP$ constitui-se em um problema de decisão que desafia os cientistas da computação e matemáticos desde sua proposição. Levando-se em conta este problema e a teoria de decibilidade, considere as afirmativas a seguir.\n\nI. Não há algoritmo determinístico de tempo polinomial que solucione este problema de decisão. \\\nII. Existem apenas algoritmos não determinísticos para solucionar este problema de decisão. \\\nIII. Existe um algoritmo determinístico de tempo polinomial para este problema de decisão. \\\nIV. Considerando-se os algoritmos “retorne sim” e “retorne não”, um deles é a solução para este problema de decisão. \n\nAssinale a alternativa correta.",
  "alternativas": [
    "a) Somente as afirmativas I e II são corretas.",
    "b) Somente as afirmativas I e IV são corretas.",
    "c) Somente as afirmativas III e IV são corretas.",
    "d) Somente as afirmativas I, II e III são corretas.",
    "e) Somente as afirmativas II, III e IV são corretas."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens Formais, Autômatos e Computabilidade",
  "subarea": "Classes de Problemas P, NP, NP Completo e NP-Difícil",
  "gabarito": "C",
  "atributo_rag": "fundamentos da computacao - linguagens formais, automatos e computabilidade - classes de problemas p, np, np completo e np-dificil"
},

{
  "id": "2011-21",
  "edicao": 2011,
  "numero": 21,
  "enunciado": "Considere a seguinte variante do algoritmo quicksort para ordenação de uma lista de inteiros $x_1, \\dots x_n$:\n\nAlgoritmo $QS(x_1, \\dots, x_n)$ \\\nEntrada: $x_1, \\dots, x_n \\in \\mathbb{Z}$ \\\nSaída: $x_1, \\dots, x_n \\in \\mathbb{Z}$\n\n1\\. Se $n = 2$ e $x_1 > x_2$, permutar $x_1$ com $x_2$. \\\n2. Se $n \\leq 2$, retornar. \\\n3. $i \\leftarrow 2$, $j \\leftarrow n$, \\\n4. Enquanto $i < j$, \\\n4.1 $\\quad$ Enquanto $x_1 \\geq x_i$ e $i < n + 1$, incrementar $i$. \\\n4.2 $\\quad$ Enquanto $x_1 < x_j$, decrementar $j$. \\\n4.3 $\\quad$ Se $i < j$, permutar $x_i$ com $x_j$. \\\n5. Permutar $x_1$ com $x_j$. \\\n6. $QS(x_1, \\dots, x_{j-1})$ \\\n7. $QS(x_{j+1}, . . . , x_n)$\n\nSeja $\\Phi(x_1 , \\dots, x_n )$ o número total de permutações de dois elementos durante a execução do algoritmo QS, inclusive durante as chamadas recursivas. Seja $\\Phi_{\\max}(n)$ o maior valor de $\\Phi(x_1, \\dots, x_n)$ para todas as listas possíveis de comprimento $n$.\n\nSabendo que \n$$\n\\Phi_{\\max}(n) = \\max_{1 \\leq j \\leq n} \\Phi_{\\max}(j - 1) + \\Phi_{\\max}(n - j ) + \\min(j - 1, n - j ) + 1,\n$$",
  "alternativas": [
    "a) $\\Phi_{\\max}(n) = n - 1$.",
    "b) $\\Phi_{\\max}(n)$ está em $o(n)$",
    "c) $\\Phi_{\\max}(n)$ está em $O(n \\log(n))$, mas não em $O(n)$",
    "d) $\\Phi_{\\max}(n)$ está em $O(n^2)$, mas não em $O(n \\log n)$",
    "e) $\\Phi_{\\max}(n) > 2^n.$"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Análise de Algoritmos",
  "subarea": "O Uso de Relações de Recorrência para Análise de Algoritmos Recursivos",
  "gabarito": "C",
  "atributo_rag": "fundamentos da computacao - analise de algoritmos - o uso de relacoes de recorrencia para analise de algoritmos recursivos"
},

{
  "id": "2011-22",
  "edicao": 2011,
  "numero": 22,
  "enunciado": "Considere a seguinte variante do algoritmo quicksort para ordenação de uma lista de inteiros $x_1, \\dots x_n$:\n\nAlgoritmo $QS(x_1, \\dots, x_n)$ \\\nEntrada: $x_1, \\dots, x_n \\in \\mathbb{Z}$ \\\nSaída: $x_1, \\dots, x_n \\in \\mathbb{Z}$\n\n1\\. Se $n = 2$ e $x_1 > x_2$, permutar $x_1$ com $x_2$. \\\n2. Se $n \\leq 2$, retornar. \\\n3. $i \\leftarrow 2$, $j \\leftarrow n$, \\\n4. Enquanto $i < j$, \\\n4.1 $\\quad$ Enquanto $x_1 \\geq x_i$ e $i < n + 1$, incrementar $i$. \\\n4.2 $\\quad$ Enquanto $x_1 < x_j$, decrementar $j$. \\\n4.3 $\\quad$ Se $i < j$, permutar $x_i$ com $x_j$. \\\n5. Permutar $x_1$ com $x_j$. \\\n6. $QS(x_1, \\dots, x_{j-1})$ \\\n7. $QS(x_{j+1}, . . . , x_n)$\n\nAssinale a alternativa correta.",
  "alternativas": [
    "a) O tempo de execução do algoritmo $QS$, no pior caso, para entradas de tamanho $n$, é de $\\Theta(n log (n))$.",
    "b) O tempo de execução total do algoritmo para a entrada $x_1, \\dots, x_n$ é sempre de $O(\\Phi(x_1, \\dots, x_n ))$.",
    "c) O tempo de execução total do algoritmo QS para a entrada $x_1, \\dots, x_n$ não é proporcional à soma das vezes que cada uma das linhas foi executada.",
    "d) O tempo de execução do algoritmo $QS$, no pior caso, para entradas de tamanho $n$, é de $\\Theta(n^2)$.",
    "e) O número total de comparações do algoritmo $QS$, incluindo as chamadas recursivas, é de $O(\\Phi_{\\max} (n))$ no pior caso."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Análise de Algoritmos",
  "subarea": "Análise de Algoritmos Iterativos e Recursivos",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - analise de algoritmos - analise de algoritmos iterativos e recursivos"
},

{
  "id": "2011-23",
  "edicao": 2011,
  "numero": 23,
  "enunciado": "Ao usar o cálculo de endereço ou hashing, geralmente é necessário o uso de um método de tratamento de colisões. \\\nSobre esse método, é correto afirmar:",
  "alternativas": [
    "a) O tratamento de colisões é necessário apenas quando a tabela está cheia e se necessita inserir mais uma chave.",
    "b) O tratamento de colisões é necessário para determinar o local da chave no momento da inserção na tabela.",
    "c) O tratamento de colisões é necessário quando a tabela está vazia, pois não é possível calcular o endereço diretamente nesse caso.",
    "d) O tratamento de colisões é necessário quando a chave inserida ainda não existir na tabela de endereçamento.",
    "e) O tratamento de colisões é necessário, pois o hashing gera repetição de endereço para diferentes chaves."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Algoritmos e Estrutura de Dados",
  "subarea": "Tabelas Hash",
  "gabarito": "E",
  "atributo_rag": "fundamentos da computacao - algoritmos e estrutura de dados - tabelas hash"
},

{
  "id": "2011-24",
  "edicao": 2011,
  "numero": 24,
  "enunciado": "Sejam $T_A(n)$ e $T_B(n)$ os tempos de execução de pior caso de dois algoritmos $A$ e $B$ propostos para um mesmo problema computacional, em função de um certo parâmetro $n$. \n\nDizemos que o algoritmo $A$ é mais eficiente que o algoritmo $B$ assintoticamente no pior caso quando",
  "alternativas": [
    "a) $T_A(n) = o(T_B(n)).$",
    "b) $T_B(n) = o(T_A(n)).$",
    "c) $T_A(n) = O(T_B(n)).$",
    "d) $T_B(n) = O(T_A(n)).$",
    "e) $T_A(n) = \\Theta(T_B(n)).$"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Análise de Algoritmos",
  "subarea": "Notação “Big O”, “Little o”, “Omega” e “Theta”",
  "gabarito": "A",
  "atributo_rag": "fundamentos da computacao - analise de algoritmos - notacao “big o”, “little o”, “omega” e “theta”"
},

{
  "id": "2011-25",
  "edicao": 2011,
  "numero": 25,
  "enunciado": "Com relação aos métodos de ordenação, relacione a coluna da esquerda com a coluna da direita.\n\n|(I) Inserção|(A) Encontra o menor elemento e o troca com a primeira posição, depois o segundo menor com a segunda posição e assim sucessivamente (n-1 vezes).|\n|-|-|\n|(II) Seleção|(B) As comparações e trocas são feitas baseadas em uma distância determinada (por exemplo: distância 4, onde o primeiro seria comparado com o quinto elemento, o segundo com o sexto, e assim sucessivamente), depois a distância é reduzida. Este processo se repete até que a distância seja 1 e as últimas comparações e trocas sejam efetuadas.|\n|(III) QuickSort|(C) A partir do segundo elemento, este deve ser colocado na sua posição correspondente (entre os elementos já analisados, como ao se organizarem as cartas de baralho na mão do jogador). Repete-se o procedimento até o último elemento.|\n|(IV) ShellSort|(D) Escolhe-se um ponto de referência (pivô) e separam-se os elementos em 2 partes: à esquerda, ficam os elementos menores que o pivô, e à direita, os maiores. Repete-se este processo para os grupos de elementos formados (esquerda e direita) até que todos os elementos estejam ordenados.|\n|(V) MergeSort (ou ordenação por fusão)|(E) Divide-se o grupo de elementos ao meio, repete-se a divisão para cada um dos subgrupos, até que cada subgrupo tenha apenas 1 elemento. Nesse ponto, faz-se o reagrupamento dos subgrupos comparando os elementos e trocando, se necessário, para que eles fiquem ordenados. Repete-se este procedimento até restar um só grupo de elementos.|\n\nAssinale a alternativa que contém a associação correta.",
  "alternativas": [
    "a) I-A, II-D, III-B, IV-C, V-E.",
    "b) I-B, II-A, III-C, IV-E, V-D.",
    "c) I-B, II-A, III-E, IV-D, V-C.",
    "d) I-C, II-A, III-D, IV-B, V-E.",
    "e) I-D, II-E, III-B, IV-A, V-C."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Algoritmos e Estrutura de Dados",
  "subarea": "Algoritmos para Pesquisa e Ordenação",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - algoritmos e estrutura de dados - algoritmos para pesquisa e ordenacao"
},

{
  "id": "2011-26",
  "edicao": 2011,
  "numero": 26,
  "enunciado": "A teoria da computabilidade, em conjunto com a álgebra booleana, garante que é possível construir um processador com um conjunto de instruções unitário que possua capacidade de resolver qualquer problema solúvel. \\\nSuponha que exista uma organização de computador convencional, dotada de um processador de uma instrução, memória e periféricos de entrada e saída. \\\nCom relação à instrução única que o processador executa, considere as afirmativas a seguir.\n\nI. Deve obrigatoriamente fazer acesso a um dispositivo de entrada e saída. \\\nII. Deve obrigatoriamente ler e escrever na memória principal do processador. \\\nIII. Deve obrigatoriamente calcular uma soma de produtos de literais booleanos. \\\nIV. Deve obrigatoriamente realizar um teste, e sua ação deve ser condicionada ao resultado deste teste. \n\nAssinale a alternativa correta.",
  "alternativas": [
    "a) Somente as afirmativas I e II são corretas.",
    "b) Somente as afirmativas II e IV são corretas.",
    "c) Somente as afirmativas III e IV são corretas.",
    "d) Somente as afirmativas I, II e III são corretas.",
    "e) Somente as afirmativas I, III e IV são corretas."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Arquitetura e Organização de Computadores",
  "subarea": "Organização de Computadores: Memórias, Unidades Centrais de Processamento, Entrada e Saída",
  "gabarito": "B",
  "atributo_rag": "fundamentos da computacao - arquitetura e organizacao de computadores - organizacao de computadores: memorias, unidades centrais de processamento, entrada e saida"
},

{
  "id": "2011-27",
  "edicao": 2011,
  "numero": 27,
  "enunciado": "As estruturas de dados lineares (fila, pilha e lista) são muito utilizadas para resolver problemas computacionais. Cada uma dessas estruturas pode ser implementada com diferentes características e atendem a diferentes tipos de problemas. \\\nSobre as características dessas estruturas de dados, atribua V (verdadeiro) ou F (falso) para as afirmativas a seguir.\n\n( ) Em uma pilha, o último elemento a entrar é o primeiro a sair. \\\n( ) Em uma fila, o primeiro elemento a entrar é o último a sair. \\\n( ) Uma lista permite que as inserções possam ser feitas em qualquer lugar (posição), mas as remoções, não. \\\n( ) Em uma lista circular com encadeamento simples, o primeiro elemento aponta para o segundo e para o último. \\\n( ) Para remover um elemento de uma lista duplamente encadeada, deve-se alterar o encadeamento dos elementos anterior e próximo ao elemento removido. \n\nAssinale a alternativa que contém, de cima para baixo, a sequência correta.",
  "alternativas": [
    "a) V, F, V, F, V.",
    "b) V, F, F, V, F.",
    "c) V, F, F, F, V.",
    "d) F, V, V, F, F.",
    "e) F, F, V, V, V."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Algoritmos e Estrutura de Dados",
  "subarea": "Estruturas de Dados Lineares e suas Generalizações: Listas Ordenadas, Listas Encadeadas, Pilhas e Filas",
  "gabarito": "C",
  "atributo_rag": "fundamentos da computacao - algoritmos e estrutura de dados - estruturas de dados lineares e suas generalizacoes: listas ordenadas, listas encadeadas, pilhas e filas"
},

{
  "id": "2011-28",
  "edicao": 2011,
  "numero": 28,
  "enunciado": "Um processador RISC é implementado em duas versões de organização síncrona: uma monociclo, em que cada instrução executa em exatamente um ciclo de relógio, e uma versão pipeline de 5 estágios. Os estágios da versão pipeline são: (1) busca de instrução, (2) busca de operandos, (3) execução da operação, (4) acesso à memória e (5) atualização do banco de registradores. A frequência máxima de operação das organizações foi calculada em 100 MHz para a versão monociclo e 400 MHz para a versão pipeline. Um programa X que executa 200 instruções é usado para comparar o desempenho das organizações. Das 200 instruções, apenas 40% fazem acesso à memória, enquanto as demais operam apenas sobre registradores internos da organização. Assuma que o programa não apresenta nenhum conflito de dados ou de controle entre instruções que podem estar simultaneamente dentro do pipeline da segunda organização.\n\nAssim, o tempo de execução do programa X nas organizações monociclo e pipeline é, respectivamente:",
  "alternativas": [
    "a) 2.000 nanossegundos e 510 nanossegundos.",
    "b) 2.000 nanossegundos e 500 nanossegundos.",
    "c) 2.000 nanossegundos e 2.300 nanossegundos.",
    "d) 2.300 nanossegundos e 500 nanossegundos.",
    "e) 2.300 nanossegundos e 510 nanossegundos."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Arquitetura e Organização de Computadores",
  "subarea": "Pipeline",
  "gabarito": "A",
  "atributo_rag": "fundamentos da computacao - arquitetura e organizacao de computadores - pipeline"
},

{
  "id": "2011-29",
  "edicao": 2011,
  "numero": 29,
  "enunciado": "Relacione a coluna da esquerda com a coluna da direita.\n\n|(I) Multicore|(A) Múltiplos pipelines que operam em paralelo.|\n|-|-|\n|(II) Superpipeline|(B) Execução de instruções fora de ordem em um pipeline.|\n|(III) Superescalar|(C) Pipelines com grande número de estágios.|\n|(IV) Pipeline dinâmico|(D) Múltiplos processadores compartilhando um espaço de endereços.|\n|(V) Multiprocessadores|(E) Múltiplos processadores em um único encapsulamento.|\n\nAssinale a alternativa que contém a associação correta.",
  "alternativas": [
    "a) I-B, II-A, III-C, IV-E, V-D.",
    "b) I-C, II-A, III-B, IV-D, V-E.",
    "c) I-D, II-E, III-B, IV-A, V-C.",
    "d) I-E, II-C, III-A, IV-B, V-D.",
    "e) I-E, II-C, III-A, IV-D, V-B."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Arquitetura e Organização de Computadores",
  "subarea": "Processadores Superescalares e Superpipeline",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - arquitetura e organizacao de computadores - processadores superescalares e superpipeline"
},

{
  "id": "2011-30",
  "edicao": 2011,
  "numero": 30,
  "enunciado": "Um sistema de computador possui um mapa de memória de 4 Gbytes, usando endereçamento a byte e uma memória cache com organização de mapeamento direto. A cache tem capacidade de armazenar até 1.024 palavras de 32 bits provenientes do mapa de memória. Assuma que a cache sempre é escrita de forma atômica com quatro bytes vindos de um endereço de memória alinhado em uma fronteira de palavra de 32 bits, e que ela usa 1 bit de validade por linha de cache. \\\nNeste caso, as dimensões do rótulo (tag) da cache, do índice e o tamanho da cache são, respectivamente:",
  "alternativas": [
    "a) 12 bits, 18 bits e 54.272 bits.",
    "b) 14 bits, 18 bits e 56.320 bits.",
    "c) 20 bits, 10 bits e 54.272 bits.",
    "d) 20 bits, 12 bits e 54.272 bits.",
    "e) 22 bits, 10 bits e 56.320 bits."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Arquitetura e Organização de Computadores",
  "subarea": "Organização de Computadores: Memórias, Unidades Centrais de Processamento, Entrada e Saída",
  "gabarito": "C",
  "atributo_rag": "fundamentos da computacao - arquitetura e organizacao de computadores - organizacao de computadores: memorias, unidades centrais de processamento, entrada e saida"
},

{
  "id": "2011-31",
  "edicao": 2011,
  "numero": 31,
  "enunciado": "Considerando as duas equações booleanas de um somador completo:\n$S = A_i \\oplus B_i \\oplus C_{in}$ e $C_{out} = (A_i \\land B_i) \\lor (C_{in} \\land (B_i \\oplus A_i))$, atribua V (verdadeiro) ou F (falso) para as afirmativas a seguir.\n\n( ) A equação $C_{out}$ = ($B_i$ and $C_{in}$) or $A_i$ and $C_{in}$ or ($A_i$ and $B_i$) é equivalente à equação $C_{out}$ do enunciado da questão.\\\n( ) O maior atraso de propagação ocorre na equação $S = A_i$ xor $B_i$ xor $C_{in}$.\\\n( ) O uso destas equações conduz à implementação do mais rápido somador completo, entre os somadores descritos na literatura.\\\n( ) Somadores completos de $n$ bits (com $n > 1$) podem ser implementados com $n$ circuitos, cada um deles implementando estas mesmas equações.\\\n( ) Para apenas uma combinação de valores de $A_i, B_i$ e $C_{in}$, obtêm-se $S = 1$ e $C_{out} = 1$.\n\nAssinale a alternativa que contém, de cima para baixo, a sequência correta.",
  "alternativas": [
    "a) V, V, F, V, F.",
    "b) V, F, F, V, V.",
    "c) F, V, V, F, V.",
    "d) F, V, F, V, F.",
    "e) F, F, V, F, V."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Circuitos Digitais",
  "subarea": "Projeto de Circuitos Combinatórios",
  "gabarito": "B",
  "atributo_rag": "fundamentos da computacao - circuitos digitais - projeto de circuitos combinatorios"
},

{
  "id": "2011-32",
  "edicao": 2011,
  "numero": 32,
  "enunciado": "Considere a seguinte propriedade sobre uma linguagem formal $L$: “Existe um número $p \\geq 0$, tal que para qualquer palavra $w \\in L, |w| \\geq p$, existem palavras $x, y$ e $z$, com $y \\neq \\epsilon$ e $|xy| \\leq p$, tais que, para qualquer inteiro $i \\geq 0$, a palavra $xy^iz \\in L$”.\nCom base no enunciado e nos conhecimentos sobre o tema, atribua V (verdadeiro) ou F (falso) para as afirmativas a seguir.\n\n( ) Se L é aceita por AFND, então L satisfaz a propriedade acima.\\\n( ) A linguagem formada de 1’s e 0’s com igual quantidade de ocorrências das palavras 01 e 10 satisfaz a propriedade acima.\\\n( ) A propriedade acima é falsa para a linguagem $0^i1^k2^j /i, j, k \\geq 0$ e se $i = 1$, então $k = j$.\\\n( ) A linguagem {$a^nb^nc^n/n \\geq 0$} não satisfaz a propriedade acima.\\\n( ) A linguagem {$a^nb^m/n, m \\geq 0, n \\neq m$} satisfaz a propriedade acima.\n\nAssinale a alternativa que contém, de cima para baixo, a sequência correta.",
  "alternativas": [
    "a) V, V, V, V, F.",
    "b) V, V, F, V, F.",
    "c) V, F, V, F, F.",
    "d) F, V, V, F, V.",
    "e) F, V, F, V, V."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens Formais, Autômatos e Computabilidade",
  "subarea": "Propriedades das Linguagens",
  "gabarito": "B",
  "atributo_rag": "fundamentos da computacao - linguagens formais, automatos e computabilidade - propriedades das linguagens"
},

{
  "id": "2011-33",
  "edicao": 2011,
  "numero": 33,
  "enunciado": "Com base nos conhecimentos sobre projeto de circuitos sequenciais, considere as afirmativas a seguir.\n\nI. O projeto de circuitos sequenciais usando flip-flops é crítico devido ao problema conhecido como transparência de flip-flops. \\\nII. Uma vez que um flip-flop é sabidamente sensível a uma das bordas do relógio, o tempo de permanência do relógio em nível alto ou baixo não é mais crítico para o funcionamento do circuito sequencial. \\\nIII. Tempo de setup é o tempo durante o qual a entrada deve ser mantida estável antes da transição ativa do relógio. \\\nIV. Um flip-flop tipo D pode ser implementado com dois latchs tipo D ou com um latch tipo D e um circuito detector de borda. \n\nAssinale a alternativa correta.",
  "alternativas": [
    "a) Somente as afirmativas I e IV são corretas.",
    "b) Somente as afirmativas II e III são corretas.",
    "c) Somente as afirmativas III e IV são corretas.",
    "d) Somente as afirmativas I, II e III são corretas.",
    "e) Somente as afirmativas I, II e IV são corretas."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Circuitos Digitais",
  "subarea": "Projeto de Circuitos Sequenciais",
  "gabarito": "C",
  "atributo_rag": "fundamentos da computacao - circuitos digitais - projeto de circuitos sequenciais"
},

{
  "id": "2011-34",
  "edicao": 2011,
  "numero": 34,
  "enunciado": "Em linguagens orientadas a objetos, o polimorfismo refere-se à ligação tardia de uma chamada a uma ou várias implementações diferentes de um método em uma hierarquia de herança. \\\nNeste contexto, considere as seguintes classes descritas na Linguagem C++.\n```\n#include <iostream>\nusing namespace std;\nclass PosComp1 {\npublic:\n  int Calcula()\n  { return 1; };\n};\nclass PosComp2 : public PosComp1 {\npublic:\n  virtual int Calcula()\n  { return 2; }\n};\nclass PosComp3 : public PosComp2 {\npublic:\n  int Calcula()\n  { return 3; }\n};\n```\nSe estas classes forem utilizadas a partir do programa a seguir \n```\nint main() {\n  int Result=0;\n  PosComp1 *Objs[3];\n  Objs[0] = new PosComp1();\n  Objs[1] = new PosComp2();\n  Objs[2] = new PosComp3();\n  for (int i=0; i<3; i++)\n    Result += Objs[i]->Calcula();\n  cout << Result << endl;\n  return 0;\n}\n```\na saída desse programa será:",
  "alternativas": [
    "a) 0",
    "b) 3",
    "c) 5",
    "d) 6",
    "e) 9"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens de Programação",
  "subarea": "Paradigmas de Linguagens de Programação",
  "gabarito": "B",
  "atributo_rag": "fundamentos da computacao - linguagens de programacao - paradigmas de linguagens de programacao"
},

{
  "id": "2011-35",
  "edicao": 2011,
  "numero": 35,
  "enunciado": "Com relação aos Paradigmas de Linguagens de Programação e as linguagens apresentadas na segunda coluna abaixo, relacione a primeira coluna com a segunda considerando a linguagem que melhor representa cada paradigma.\n\n|(I) Programação Imperativa|(A) Linguagem Scheme|\n|-|-|\n|(II) Programação Orientada a Objetos|(B) Linguagem Smalltalk|\n|(III) Programação Funcional|(C) Linguagem Pascal|\n|(IV) Programação Lógica|(D) Linguagem Prolog|\n\nAssinale a alternativa que contém a associação correta.",
  "alternativas": [
    "a) I-A, II-B, III-D, IV-C.",
    "b) I-B, II-A, III-C, IV-D.",
    "c) I-C, II-A, III-B, IV-D.",
    "d) I-C, II-B, III-A, IV-D.",
    "e) I-D, II-C, III-B, IV-A."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens de Programação",
  "subarea": "Paradigmas de Linguagens de Programação",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - linguagens de programacao - paradigmas de linguagens de programacao"
},

{
  "id": "2011-36",
  "edicao": 2011,
  "numero": 36,
  "enunciado": "Sejam as linguagens $L_1 = a^ib^nc^m/i, n, m \\geq 0$ e $L_2 = a^nb^mc^id^k/i, n, k, m \\geq 0$, com $i = m$ ou $n = m$. Com base nessa informação, é correto afirmar:",
  "alternativas": [
    "a) $L_1 \\cap L_2 $ é aceita por autômato finito não determinístico.",
    "b) $L_1 . L_2$, isto é, a concatenação das linguagens $L_1$ e $L_2$ não é livre de contexto.",
    "c) $L_2$ é aceita por autômato de pilha determinístico.",
    "d) $L_1 \\cup L_2$ é aceita por autômato finito possuindo, no mínimo, 6 estados.",
    "e) $L_1 \\cap L_2$ possui gramática livre de contexto geradora."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens Formais, Autômatos e Computabilidade",
  "subarea": "Autômatos de Estados Finitos Determinístico e não Determinístico",
  "gabarito": "E",
  "atributo_rag": "fundamentos da computacao - linguagens formais, automatos e computabilidade - automatos de estados finitos deterministico e nao deterministico"
},

{
  "id": "2011-37",
  "edicao": 2011,
  "numero": 37,
  "enunciado": "Em programas que utilizam grande quantidade de memória, a alocação deste recurso deve ser realizada com muito cuidado. Em algumas circunstâncias, o uso da memória pode ser otimizado com a utilização de registros variantes. Em linguagens como C, o registro variante é construído através de uma união disjuntiva.\n\nAnalise a declaração de tipo em C++, a seguir.\n```\nunion PosCompType {\n  char A[2];\n  struct {\n    char B;\n    char C;\n  };\n};\n```\nConsidere o código a seguir, que utiliza esse tipo.\n```\nint main() {\n  PosCompType Dado;\n  Dado.A[0] = ’a’;\n  Dado.A[1] = ’b’;\n  Dado.B = ’c’;\n  Dado.C = ’d’;\n  printf (\"%c %c %c %c\\n\", Dado.A[0],Dado.A[1],Dado.B,Dado.C);\n  return 0;\n}\n```\nA saída do código será:",
  "alternativas": [
    "a) `a b a b`",
    "b) `a b c d`",
    "c) `c d a b`",
    "d) `c d c d`",
    "e) `d c b a`"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens de Programação",
  "subarea": "Paradigmas de Linguagens de Programação",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - linguagens de programacao - paradigmas de linguagens de programacao"
},

{
  "id": "2011-38",
  "edicao": 2011,
  "numero": 38,
  "enunciado": "Com relação às linguagens e seus aceitadores, considere as afirmativas a seguir.\n\nI. $\\{ww^{rev} / w\\in\\{a,b\\}^*\\}$ é aceita por autômato de pilha determinístico. \\\nII. $\\{wcw^{rev} / w\\in\\{a,b\\}^*\\}$ é aceita por autômato finito não determinístico. \\\nIII. $\\{a,b\\}^*-\\{ww / w\\in\\{a,b\\}^*\\}$ é aceita por autômato de pilha não determinístico. \\\nIV. $\\{M / M$ é M.T. e $M$ para$\\}$ é aceita for Máquina de Turing não determinística. \n\nAssinale a alternativa correta.",
  "alternativas": [
    "a) Somente as afirmativas I e II são corretas.",
    "b) Somente as afirmativas II e IV são corretas.",
    "c) Somente as afirmativas III e IV são corretas.",
    "d) Somente as afirmativas I, II e III são corretas.",
    "e) Somente as afirmativas I, III e IV são corretas."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens Formais, Autômatos e Computabilidade",
  "subarea": "Tipos de Reconhecedores",
  "gabarito": "C",
  "atributo_rag": "fundamentos da computacao - linguagens formais, automatos e computabilidade - tipos de reconhecedores"
},

{
  "id": "2011-39",
  "edicao": 2011,
  "numero": 39,
  "enunciado": "Considere a função desenvolvida na Linguagem C, a seguir.\n```\nchar *Teste (char *s1, const char *s2)\n{\n  char *aux=s1;\n  while (*s1) s1++;\n  for (;(*s1 = *s2)!=’\\0’;s1++,s2++);\n  return aux;\n}\n```\nO seu objetivo é:",
  "alternativas": [
    "a) Copiar o conteúdo da região de memória referenciada pelo identificador `s1` para a região de memória referenciada pelo identificador `s2`.",
    "b) Atribuir o valor `‘\\0’` para todas as posições de memória entre o endereço referenciado pelo identificador `s1` até a região de memória referenciada pelo identificador `s2`.",
    "c) Comparar o conteúdo de memória que se inicia na posição referenciada pelo identificador `s1` e ir até a ocorrência de um valor `‘\\0’` com o conteúdo da região de memória referenciada pelo identificador `s2`.",
    "d) Substituir os elementos armazenados na região de memória referenciada pelo identificador `s1` pelos elementos armazenados na região de memória referenciada pelo identificador `s2`.",
    "e) Copiar os elementos contidos na região de memória referenciada pelo identificador `s2` após os elementos armazenados na região de memória referenciada pelo identificador `s1`."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Técnicas de Programação",
  "subarea": "Desenvolvimento de algoritmos",
  "gabarito": "E",
  "atributo_rag": "fundamentos da computacao - tecnicas de programacao - desenvolvimento de algoritmos"
},

{
  "id": "2011-40",
  "edicao": 2011,
  "numero": 40,
  "enunciado": "O gerenciamento dos sistemas de entrada/saída de dados é normalmente implementado em duas camadas: uma responsável pelo controle do dispositivo e outra, pelo gerenciamento de entrada/saída. \\\nPor que isso representa um projeto eficiente?",
  "alternativas": [
    "a) Porque permite o uso de duas linguagens de programação na sua implementação, pois o controle do dispositivo exige a programação em linguagem de máquina.",
    "b) Porque permite separar as operações de entrada das operações de saída de dados.",
    "c) Porque permite o compartilhamento dos dispositivos de entrada/saída através do gerenciamento de entrada/saída.",
    "d) Porque permite evitar o uso de DMA para a operação de entrada/saída.",
    "e) Porque permite separar características de hardware de características funcionais do dispositivo de entrada/saída."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Sistemas Operacionais",
  "subarea": "Gerenciamento de Dispositivos de Entrada/Saída",
  "gabarito": "E",
  "atributo_rag": "fundamentos da computacao - sistemas operacionais - gerenciamento de dispositivos de entrada/saida"
},

{
  "id": "2011-41",
  "edicao": 2011,
  "numero": 41,
  "enunciado": "O gerenciamento de processos em sistemas modernos é feito, quase sempre, com o uso de preempção de processos através de técnicas de compartilhamento de tempo. \\\nO que a introdução de processadores com vários núcleos altera nesse gerenciamento?",
  "alternativas": [
    "a) Torna-se possível a paralelização efetiva de processos concorrentes.",
    "b) Torna-se possível eliminar a condição de corrida em processos concorrentes executados em paralelo.",
    "c) Torna-se possível o uso de threads para a execução de processos concorrentes.",
    "d) Torna-se possível separar os demais mecanismos de gerenciamento do sistema operacional do gerenciamento de processos.",
    "e) Torna-se possível o uso de sistemas operacionais multitarefas."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Sistemas Operacionais",
  "subarea": "Gerência de Processos/Processador",
  "gabarito": "A",
  "atributo_rag": "fundamentos da computacao - sistemas operacionais - gerencia de processos/processador"
},

{
  "id": "2011-42",
  "edicao": 2011,
  "numero": 42,
  "enunciado": "Ao medir o desempenho de um certo sistema, verificou-se que este passava muito tempo com a CPU ociosa e tinha um alto volume de acessos a disco. \n\nAssinale a alternativa que apresenta a solução traduzida na melhoria de desempenho desse sistema.",
  "alternativas": [
    "a) Troca da CPU por uma mais rápida.",
    "b) Aumento na capacidade de memória do sistema.",
    "c) Aumento na capacidade de armazenamento do disco.",
    "d) Uso de memória cache.",
    "e) Troca do sistema operacional."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Sistemas Operacionais",
  "subarea": "Gerenciamento de Dispositivos de Entrada/Saída",
  "gabarito": "B",
  "atributo_rag": "fundamentos da computacao - sistemas operacionais - gerenciamento de dispositivos de entrada/saida"
},

{
  "id": "2011-43",
  "edicao": 2011,
  "numero": 43,
  "enunciado": "Um usuário digitou o valor 4 na entrada padrão, ao executar o programa em linguagem C++, a seguir.\n```\n#include <iostream>\nusing namespace std;\nstruct N {\n  int A; int B;\n  N *L;\n};\nint main()\n{\n  N *A, *B, *C;\n  int n;\n  cin >> n;\n  for (int i=0; i<n; i++)\n  if (!i) {\n    C = new N;\n    C->A = i;\n    C->B = i+1;\n    C->L = new N;\n    C->L->A = i+1;\n    C->L->B = i+1;\n    C->L->L = NULL;\n  } else {\n    A = C;\n    B = A->L;\n    while (B) {\n      if (A->B + B->B <= i) {\n        A->L = new N;\n        A->L->A = A->A + B->A;\n        A->L->B = A->B + B->B;\n        A->L->L = B;\n      }end while\n      A = B;\n      B = B->L;\n    }\n  }\n  A = C;\n  while (A) {\n    cout << A->A << \"/\" << A->B << \" \";\n    A = A->L;\n  }\n}\n```\nO resultado obtido foi:",
  "alternativas": [
    "a) 0/1 0/2 0/3 0/4 0/5",
    "b) 0/1 1/2 1/3 1/2 0/1",
    "c) 0/1 1/3 0/1 1/3 0/1",
    "d) 0/1 1/3 1/2 2/3 1/1",
    "e) 0/1 1/2 2/3 3/4 4/5"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens de Programação",
  "subarea": "Paradigmas de Linguagens de Programação",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - linguagens de programacao - paradigmas de linguagens de programacao"
},

{
  "id": "2011-44",
  "edicao": 2011,
  "numero": 44,
  "enunciado": "Qual a quantidade mínima de arestas que se deve remover do grafo completo com 6 vértices, $K_6$, para se obter um grafo planar?",
  "alternativas": [
    "a) 1",
    "b) 2",
    "c) 3",
    "d) 4",
    "e) 5"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Teoria dos Grafos",
  "subarea": "Planaridade",
  "gabarito": "C",
  "atributo_rag": "fundamentos da computacao - teoria dos grafos - planaridade"
},

{
  "id": "2011-45",
  "edicao": 2011,
  "numero": 45,
  "enunciado": "Arquivos são um mecanismo de abstração que permite a manipulação de dados de maneira persistente, concorrente e em grandes quantidades. \\\nSobre o assunto, considere as afirmativas a seguir.\n\nI. Em arquivos restritos a acesso sequencial, a operação *rewind* é irrelevante e, quando presente, apenas equivale a uma operação *seek* apontando para o início do arquivo. \\\nII. Uma maneira comum de estruturar arquivos é a sequência de bytes não estruturada. Nesse modelo, um arquivo não é organizado em registros e campos, e quaisquer significados aos seus dados devem ser feitos pelos programas de usuário. Sua vantagem é permitir a máxima flexibilidade. \\\nIII. Todo sistema operacional armazena um certo conjunto de informações junto a cada arquivo, conhecidas como atributos ou metadados. Dentre as informações armazenadas pelos metadados de um arquivo em um sistema, podem estar: identificador do arquivo; hora da criação; último acesso; última mudança; visibilidade; tipo de arquivo. \\\nIV. Alguns sistemas suportam arquivos estruturados em árvores. Nesse tipo de arquivo, cada registro possui uma chave. A árvore é organizada no campo de chaves do arquivo para possibilitar uma busca rápida pelos registros. \n\nAssinale a alternativa correta.",
  "alternativas": [
    "a) Somente as afirmativas I e II são corretas.",
    "b) Somente as afirmativas I e IV são corretas.",
    "c) Somente as afirmativas III e IV são corretas.",
    "d) Somente as afirmativas I, II e III são corretas.",
    "e) Somente as afirmativas II, III e IV são corretas."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Sistemas Operacionais",
  "subarea": "Gerenciamento de Arquivos",
  "gabarito": "E",
  "atributo_rag": "fundamentos da computacao - sistemas operacionais - gerenciamento de arquivos"
},

{
  "id": "2011-46",
  "edicao": 2011,
  "numero": 46,
  "enunciado": "Considere o algoritmo de codificação RSA, utilizado para criptografia e assinatura digital. Ele se baseia na utilização de dois números primos grandes aleatórios, $p$ e $q$, para gerar os valores $n$, $e$ e $d$. Tais valores compõem as chaves pública e privada, $P = (e, n)$ e $S = (d, n)$, respectivamente. \n\nCom base nos conhecimentos sobre o tema, assinale a alternativa correta.",
  "alternativas": [
    "a) O procedimento para o envio de uma mensagem envolve os seguintes passos: o destinatário $D$ disponibiliza uma chave pública $P_D$ para quem quer lhe enviar uma mensagem; o remetente $R$ utiliza a chave pública para cifrar a mensagem $M$, tal que $C_R = P_D(M)$; após receber $C_R$ , o destinatário utiliza sua chave privada $S_D$, para decifrar a mensagem, tal que $M = S_D(C_R)$.",
    "b) O procedimento para assinatura digital envolve os seguintes passos: o destinatário $D$ disponibiliza uma chave pública $P_D$ para quem quer lhe enviar uma mensagem assinada; o remetente $R$ utiliza a chave pública paracifrar a mensagem $M$, tal que $C_R = P_D(M)$; após receber $C_R$, o destinatário utiliza sua chave privada $S_D$, para decifrar a mensagem, tal que $M = S_D (C_R)$.",
    "c) A codificação RSA é considerada segura, pois, a partir de uma cifra $C$, é impossível obter a mensagem $M$ sem conhecer a chave privada $S = (d, n)$.",
    "d) Do ponto de vista do desempenho computacional, o algoritmo RSA pode ser considerado um dos melhores, pois, com ele, a cifragem e a decifragem são mais rápidas e computacionalmente menos intensivas que outras técnicas que não envolvem chaves públicas.",
    "e) Um dos problemas em se utilizar o algoritmo RSA para assinatura digital é o fato de ser obrigatória a existência de um agente certificador de confiança, cuja função é criar e atribuir as chaves públicas e privadas às pessoas certas. Se o agente não for de confiança, o sistema é comprometido."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Algoritmos e Estrutura de Dados",
  "subarea": "Modularidade e Abstração",
  "gabarito": "A",
  "atributo_rag": "fundamentos da computacao - algoritmos e estrutura de dados - modularidade e abstracao"
},

{
  "id": "2011-47",
  "edicao": 2011,
  "numero": 47,
  "enunciado": "Seja G um grafo conexo. Considere a notação a seguir.\n- $c_v$ é o número cromático em vértices de $G$.\n- $c_e$ é o número cromático em arestas de $G$.\n- $g_{min}$ é o grau mínimo de $G$.\n- $g_{max}$ é o grau máximo de $G$.\n- $w$ é a quantidade de vértices do maior subgrafo completo de $G$.\n\nAssinale a alternativa correta.",
  "alternativas": [
    "a) $c_v \\leq c_e$",
    "b) $c_v \\leq w$",
    "c) $c_e \\leq g_{max}$",
    "d) $c_v \\leq g_{max} + 1$",
    "e) $c_v \\geq g_{min}$"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Teoria dos Grafos",
  "subarea": "Coloração",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - teoria dos grafos - coloracao"
},

{
  "id": "2011-48",
  "edicao": 2011,
  "numero": 48,
  "enunciado": "Observe a função recursiva a seguir, desenvolvida na linguagem Pascal.\n```\nfunction Prova (N : integer) : integer;\nbegin\n  if N = 0 then Prova := 0\n  else Prova := N * 2 - 1 + Prova (N - 1);\nend;\n```\nConsiderando-se que essa função sempre será chamada com variável `N` contendo inteiros positivos, o seu valor de retorno será:",
  "alternativas": [
    "a) O fatorial do valor armazenado em `N`.",
    "b) O valor armazenado em `N` elevado ao quadrado.",
    "c) O somatório dos `N` primeiros números inteiros positivos.",
    "d) O somatório dos `N` primeiros números pares positivos.",
    "e) 2 elevado ao valor armazenado em `N`."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Algoritmos e Estrutura de Dados",
  "subarea": "Recursividade: Conceito e Implementação",
  "gabarito": "B",
  "atributo_rag": "fundamentos da computacao - algoritmos e estrutura de dados - recursividade: conceito e implementacao"
},

{
  "id": "2011-49",
  "edicao": 2011,
  "numero": 49,
  "enunciado": "Em organização de arquivos e dados, os diretórios foram criados para organizar e controlar outros arquivos. \n\nCom base nos conhecimentos sobre o tema, considere as afirmativas a seguir.\n\nI. Um diretório geralmente contém várias entradas, sendo uma por arquivo diretamente subordinado. Cada entrada é composta pelo nome do arquivo, seus atributos e os endereços do disco onde estão armazenados. Alternativamente, após o nome do arquivo, pode haver um ponteiro para uma estrutura de dados com os atributos e os endereços. \\\nII. Em um sistema de diretórios hierárquicos, se o diretório atual, ou diretório de trabalho, de um processo for “`/usr/bin/.”`, para acessar o arquivo chamado cache, localizado em “`/tmp/`”, pode ser usado o nome de caminho absoluto “`/tmp/cache`”. Alternativamente, pode ser usado o nome de caminho relativo “`./../../tmp/cache`”. \\\nIII. Para os usuários, uma das vantagens de sistemas com um diretório por usuário em relação a sistemas de diretório único é poder organizar os arquivos em subgrupos.\nIV. Em sistemas que suportam diretórios hierárquicos, como Windows e UNIX, há três entradas especiais em cada diretório. Elas são ‘`.`’ (ponto), ‘`..`’ (ponto-ponto) e ‘`~`’ (til): o primeiro serve para voltar um nível na hierarquia; o segundo, para avançar um nível; o terceiro, para referenciar o diretório reservado ao administrador, quando utilizado em caminhos relativos. \n\nAssinale a alternativa correta.",
  "alternativas": [
    "a) Somente as afirmativas I e II são corretas.",
    "b) Somente as afirmativas I e IV são corretas.",
    "c) Somente as afirmativas III e IV são corretas.",
    "d) Somente as afirmativas I, II e III são corretas.",
    "e) Somente as afirmativas II, III e IV são corretas."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Organização de Arquivos e Dados",
  "subarea": "Diretórios: Conteúdo e Estrutura",
  "gabarito": "A",
  "atributo_rag": "fundamentos da computacao - organizacao de arquivos e dados - diretorios: conteudo e estrutura"
},

{
  "id": "2011-50",
  "edicao": 2011,
  "numero": 50,
  "enunciado": "Seja $G$ um grafo conexo com $n$ vértices. Considere duas rotulações dos vértices de $G$ obtidas por duas buscas em $G$, uma em largura, $l()$, e outra em profundidade, $p()$, ambas iniciadas no vértice $v$. Em cada rotulação, os vértices receberam um número de 1 a $n$, o qual representa a ordem em que foram alcançados na busca em questão. Assim, $l(v) = p(v) = 1$; enquanto $l(x) > 1$ e $p(x) > 1$ para todo vértice $x$ diferente de $v$. Considere dois vértices $u$ e $w$ de $G$ e denote por $d(u, w)$ a distância em $G$ de $u$ até $w$. \n\nCom base nesses dados, assinale a alternativa correta.",
  "alternativas": [
    "a) Se $l(u) < l(w)$ e $p(u) < p(w)$, então $d(v, u) < d(v, w)$.",
    "b) Se $l(u) < l(w)$ e $p(u) > p(w)$, então $d(v, u) = d(v, w)$.",
    "c) Se $l(u) > l(w)$ e $p(u) < p(w)$, então $d(v, u) \\leq d(v, w).$",
    "d) Se $l(u) > l(w)$ e $p(u) > p(w)$, então $d(v, u) < d(v, w)$.",
    "e) Se $l(u) < l(w)$ e $p(u) > p(w)$, então $d(v, u) \\leq d(v, w)$."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Teoria dos Grafos",
  "subarea": "Busca em Largura e Profundidade",
  "gabarito": "E",
  "atributo_rag": "fundamentos da computacao - teoria dos grafos - busca em largura e profundidade"
},

{
  "id": "2012-21",
  "edicao": 2012,
  "numero": 21,
  "enunciado": "O algoritmo $ALGSORT$ ordena vetores de números inteiros distintos usando apenas comparações. Nesse algoritmo, a função $menor(V, i, j)$ retorna o índice $l$, tal que $V [l]$ é o menor número no vetor $V [i..j]$. O custo de tempo de pior caso de $menor(V, i, j)$ é igual a $j - i$ comparações. De forma similar, a função $maior(V, i, j)$ retorna um índice $g$, tal que $V [g]$ é o maior número no vetor $V [i..j]$, também com custo de execução de $j - i$ comparações no pior caso. Para ordenar o vetor $X[1..n]$, $ALGSORT(V, i, j)$ é chamado com os parâmetros, $V = X$, $i = 1$ e $j = n$.\n\n```\nALGSORT (V,i,j);\n(1) Se j-i=0 então retorne;\n(2) Se j-i=1 então\n       Se V[j] < V[i] então\n           Troque(V[j],V[i]);\n       Fim;\n       retorne;\n   Fim;\n(3) l = menor(V,i,j);\n(4) Troque(V[i],V[l]);\n(5) g = maior(V,i,j);\n(6) Troque(V[j],V[g]);\n(7) ALGSORT (V,i+1,j-1);\n```\n\nA função que caracteriza o custo de tempo de pior caso, $T (n)$, para a chamada $ALGSORT (X, 1, n)$ é dada por:",
  "alternativas": [
    "a) $T (n) = T (n - 1) + 2n - 2$",
    "b) $T (n) = T (n - 2) + 2n - 2$",
    "c) $T (n) = T (n - 2) + n - 1$",
    "d) $T (n) = T (n - 2) + (n - 1)^2$",
    "e) $T (n) = T(\\frac{n}{2})+ 2n$"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Análise de Algoritmos",
  "subarea": "O Uso de Relações de Recorrência para Análise de Algoritmos Recursivos",
  "gabarito": "B",
  "atributo_rag": "fundamentos da computacao - analise de algoritmos - o uso de relacoes de recorrencia para analise de algoritmos recursivos"
},

{
  "id": "2012-22",
  "edicao": 2012,
  "numero": 22,
  "enunciado": "O algoritmo $ALGSORT$ ordena vetores de números inteiros distintos usando apenas comparações. Nesse algoritmo, a função $menor(V, i, j)$ retorna o índice $l$, tal que $V [l]$ é o menor número no vetor $V [i..j]$. O custo de tempo de pior caso de $menor(V, i, j)$ é igual a $j - i$ comparações. De forma similar, a função $maior(V, i, j)$ retorna um índice $g$, tal que $V [g]$ é o maior número no vetor $V [i..j]$, também com custo de execução de $j - i$ comparações no pior caso. Para ordenar o vetor $X[1..n]$, $ALGSORT(V, i, j)$ é chamado com os parâmetros, $V = X$, $i = 1$ e $j = n$.\n\n```\nALGSORT (V,i,j);\n(1) Se j-i=0 então retorne;\n(2) Se j-i=1 então\n       Se V[j] < V[i] então\n           Troque(V[j],V[i]);\n       Fim;\n       retorne;\n   Fim;\n(3) l = menor(V,i,j);\n(4) Troque(V[i],V[l]);\n(5) g = maior(V,i,j);\n(6) Troque(V[j],V[g]);\n(7) ALGSORT (V,i+1,j-1);\n```\n\nCom relação ao projeto do algoritmo $ALGSORT$, assinale a alternativa correta.",
  "alternativas": [
    "a) O custo de combinação de $ALGSORT$ é $O(n)$ em função do tamanho da entrada para a chamada \n $ ALGSORT(X, 1, n)$.",
    "b) Modificando o trecho das linhas de (3) a (6) de $ALGSORT$, é possível obter um algoritmo assintoticamente menos custoso.",
    "c) O tempo de execução para a chamada $ALGSORT (X, 1, n)$ em função de $n$ é $O(n \\log n)$.",
    "d) O tempo de execução de $ALGSORT$ é $\\Theta(n^2)$ em função de $n$ para a chamada $ALGSORT (X, 1, n)$.",
    "e) O custo do caso base $n = 1$ para a chamada $ALGSORT (X, 1, n)$ em função de $n$ é $T (n) = 1$."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Análise de Algoritmos",
  "subarea": "O Uso de Relações de Recorrência para Análise de Algoritmos Recursivos",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - analise de algoritmos - o uso de relacoes de recorrencia para analise de algoritmos recursivos"
},

{
  "id": "2012-23",
  "edicao": 2012,
  "numero": 23,
  "enunciado": "Em relação à pesquisa sequencial e binária, assinale a alternativa correta.",
  "alternativas": [
    "a) A pesquisa binária em média percorre a metade dos elementos do vetor.",
    "b) A pesquisa binária percorre no pior caso $\\log_2n$ elementos.",
    "c) A pesquisa binária pode ser feita sobre qualquer distribuição dos elementos.",
    "d) A pesquisa sequencial exige que os elementos estejam completamente ordenados.",
    "e) A pesquisa sequencial percorre todos os elementos para encontrar a chave."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Algoritmos e Estrutura de Dados",
  "subarea": "Algoritmos para Pesquisa e Ordenação",
  "gabarito": "B",
  "atributo_rag": "fundamentos da computacao - algoritmos e estrutura de dados - algoritmos para pesquisa e ordenacao"
},

{
  "id": "2012-24",
  "edicao": 2012,
  "numero": 24,
  "enunciado": "Um problema das árvores binárias de buscas convencionais é que a disposição dos elementos pode ficar semelhante à de uma estrutura linear, na qual as árvores criam uma profundidade maior que sua largura, como ocorre, por exemplo, em inserção de chaves em ordem crescente. Em árvores com essa característica, não há ganho substancial quanto ao tempo de busca de uma lista, por exemplo. As árvore AVL e SBB são árvores projetadas para evitar esse problema e balancear o tempo de busca a seus elementos. \n\nQuanto às árvores AVL e SBB, assinale a alternativa que apresenta, corretamente, suas características.",
  "alternativas": [
    "a) Árvores AVL utilizam altura das subárvores como critério de balanceamento, enquanto árvores SBB utilizam orientação vertical e horizontal dos “apontadores” dos nós.",
    "b) Árvores AVL utilizam quatro tipos diferentes de algoritmos de balanceamento, enquanto árvores SBB utilizam apenas dois tipos genéricos (direita e esquerda), levando em consideração a origem e a propagação de uma violação.",
    "c) Árvores SBB utilizam alturas das subárvores como critério de balanceamento, enquanto árvores AVL utilizam orientação vertical e horizontal dos “apontadores” dos nós.",
    "d) Árvores SBB utilizam quatro tipos diferentes de algoritmos de balanceamento, enquanto árvores AVL utilizam apenas dois tipos genéricos (direita e esquerda), levando em consideração a origem e a propagação de uma violação.",
    "e) As árvores AVL e SBB possuem diferença quanto à estrutura dos nós e à composição das chaves e das funções de busca, de inserção e de remoção."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Algoritmos e Estrutura de Dados",
  "subarea": "Árvores e suas Generalizações: Árvores Binárias, Árvores de Busca e Árvores Balanceadas",
  "gabarito": "A",
  "atributo_rag": "fundamentos da computacao - algoritmos e estrutura de dados - arvores e suas generalizacoes: arvores binarias, arvores de busca e arvores balanceadas"
},

{
  "id": "2012-25",
  "edicao": 2012,
  "numero": 25,
  "enunciado": "Seja $V$ um vetor de $n$ inteiros não negativos, tal que o maior valor encontrado em $V$ é $m > 0$. \\\nCom relação à ordenação de $V$, considere as afirmativas a seguir.\n\nI. O tempo de execução dos algoritmos Quicksort e Mergesort para ordenar $V$ é $\\Omega(n lg n)$ para qualquer valor de m. \\\nII. Quando $m = O(n)$, é possível ordenar $V$ em tempo de execução $O(n)$ no pior caso. \\\nIII. O tempo de execução de pior caso do Quicksort para ordenar $V$ é $O(n lg n)$ quando $m = O(n)$. \\\nIV. Para instâncias onde $n = O(m)$, o algoritmo Countingsort é mais eficiente que o Mergesort, em função de $n$. \n\nAssinale a alternativa correta.",
  "alternativas": [
    "a) Somente as afirmativas I e II são corretas.",
    "b) Somente as afirmativas I e IV são corretas.",
    "c) Somente as afirmativas III e IV são corretas.",
    "d) Somente as afirmativas I, II e III são corretas.",
    "e) Somente as afirmativas II, III e IV são corretas."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Análise de Algoritmos",
  "subarea": "Análise de Algoritmos Iterativos e Recursivos",
  "gabarito": "A",
  "atributo_rag": "fundamentos da computacao - analise de algoritmos - analise de algoritmos iterativos e recursivos"
},

{
  "id": "2012-26",
  "edicao": 2012,
  "numero": 26,
  "enunciado": "Com base nos paradigmas de projeto de algoritmos, relacione a coluna da esquerda com a coluna da direita.\n```\n(I) Tentativa e Erro.\n(II) Divisão e Conquista.\n(III) Balanceamento.\n(IV) Algoritmos Aproximados.\n(V) Programação Dinâmica.\n-------------------------------------------------------------------------------------\n(A) Solução com garantia de distância da ótima.\n(B) Subdivisão de problemas em partes menores, de tamanho semelhante.\n(C) Calcula a solução para os subproblemas, dos problemas menores para os maiores, armazenando os resultados parciais durante o processo, reutilizando-os assim que possível.\n(D) Geralmente exaurem-se todas as possibilidades para se encontrar uma solução. Todos os passos em direção à solução final são registrados. Se alguns dos passos não estiverem relacionados com a solução final, podem ser apagados.\n(E) Divide problema em partes menores e combina sua solução em uma solução global.\n```\nAssinale a alternativa que contém a associação correta.",
  "alternativas": [
    "a) I-A, II-D, III-B, IV-C, V-E.",
    "b) I-B, II-A, III-C, IV-E, V-D.",
    "c) I-B, II-A, III-E, IV-D, V-C.",
    "d) I-C, II-A, III-D, IV-B, V-E.",
    "e) I-D, II-E, III-B, IV-A, V-C."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Algoritmos e Estrutura de Dados",
  "subarea": "Técnicas de Projeto de Algoritmos: Método da Força Bruta, Pesquisa Exaustiva, Algoritmo Guloso, Dividir e Conquistar, “Backtracking” e Heurísticas",
  "gabarito": "E",
  "atributo_rag": "fundamentos da computacao - algoritmos e estrutura de dados - tecnicas de projeto de algoritmos: metodo da forca bruta, pesquisa exaustiva, algoritmo guloso, dividir e conquistar, “backtracking” e heuristicas"
},

{
  "id": "2012-27",
  "edicao": 2012,
  "numero": 27,
  "enunciado": "Devido ao volume de informações produzido atualmente e, principalmente, à necessidade de proteger várias dessas informações, técnicas de criptografia têm sido desenvolvidas ou aprimoradas. Uma abordagem criptográfica bastante simples é aquela que consiste na substituição de determinados símbolos por outros. O programa, a seguir, desenvolvido na linguagem C, possui uma função que realiza a criptografia de uma determinada cadeia de caracteres (string), referenciada através de um ponteiro de `char`.\n\n```\n#include <stdio.h>\nvoid Cripto (char *inout, int i) {\n  char *sibl, c;\n  while (*inout) {\n    sibl = inout+1;\n    if (!sibl)\n      break;\n    if (*inout >= ’A’ && *inout <= ’Z’)\n      *inout += i;\n    c = *sibl;\n    *sibl = *inout;\n    *inout = c;\n    inout = sibl+1;\n  }\n}\n```\n\n```\nint main() {\n  char str[30];\n  int i;\n  scanf(\"%s %d\", str, &i);\n  Cripto(str, i);\n  printf(\"%s\\n\", str);\n  return 0;\n}\n```\nAssinale a alternativa que apresenta, corretamente, o resultado desse programa quando ele for executado com a entrada a seguir.\n```\nPosCOMP2012x 3\n```",
  "alternativas": [
    "a) `PosCOMP2012x`",
    "b) `OscVmr2S10x2`",
    "c) `oSCsMR2S10x2`",
    "d) `x2012PosComp`",
    "e) `SosCRMS2012x`"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Algoritmos e Estrutura de Dados",
  "subarea": "Cadeias e Processamento de Cadeias",
  "gabarito": "C",
  "atributo_rag": "fundamentos da computacao - algoritmos e estrutura de dados - cadeias e processamento de cadeias"
},

{
  "id": "2012-28",
  "edicao": 2012,
  "numero": 28,
  "enunciado": "Nas linguagens de programação, uma questão importante é o escopo das declarações. Por exemplo, o escopo de uma declaração de `x` é a região do programa em que os usos de `x` se referem a essa declaração. Nesse sentido, a ligação de um nome a um escopo pode ser estática ou dinâmica. No programa C, a seguir, o identificador `x` é uma macro composta pela expressão `++y`. Por ser uma macro, a resolução de `x` não é realizada somente em termos do texto do programa.\n```\n#include<stdio.h>\n#define x ++y int y = 2;\nvoid M() { int y = 1; printf (\"%d \", x); }\nvoid N() { printf(\"%d \", x); }\nint main() {\n  M();\n  N();\n  return 0;\n}\n```\nCom base nessa execução, assinale a alternativa que apresenta, corretamente, a saída desse programa.",
  "alternativas": [
    "a) 1 1",
    "b) 1 2",
    "c) 1 3",
    "d) 2 2",
    "e) 2 3"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens de Programação",
  "subarea": "Paradigmas de Linguagens de Programação",
  "gabarito": "E",
  "atributo_rag": "fundamentos da computacao - linguagens de programacao - paradigmas de linguagens de programacao"
},

{
  "id": "2012-29",
  "edicao": 2012,
  "numero": 29,
  "enunciado": "Um ponteiro é um elemento que proporciona maior controle sobre a memória do computador, principalmente por ser utilizado em conjunto com mecanismos de alocação dinâmica de memória. Dessa forma, o domínio sobre este tipo de dado é muito importante. O código, a seguir, foi escrito na linguagem C++ e trabalha com ponteiros e estruturas dinâmicas.\n```\n#include <iostream>\nusing namespace std;\nstruct No {\n  int Dado; No* Prox;\n};\nint main()\n{\n  No *L, *i; int n;\n  cin >> n;\n  if (n == 0) L = NULL;\n  else {\n    L = new No;\n    L->Dado = n--;\n    L->Prox = NULL;\n    for ( ; n > 0 ; ) {\n      i = new No;\n      i->Dado = n--;\n      i->Prox = L;\n      L = i;\n    }\n  }\n  while (L != NULL) {\n    cout << L->Dado << \" \";\n    L = L->Prox;\n  }\n  return 0;\n}\n```\nSe, durante a execução desse código, a variável `n` receber o valor 6, a saída do programa será:",
  "alternativas": [
    "a) 0 1 2 3 4 5 6",
    "b) 1 2 3 4 5 6",
    "c) 6 5 4 3 2 1",
    "d) 6 5 4 3 2 1 0",
    "e) 1 2 3 4 5"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Algoritmos e Estrutura de Dados",
  "subarea": "Estruturas de Dados Lineares e suas Generalizações: Listas Ordenadas, Listas Encadeadas, Pilhas e Filas",
  "gabarito": "B",
  "atributo_rag": "fundamentos da computacao - algoritmos e estrutura de dados - estruturas de dados lineares e suas generalizacoes: listas ordenadas, listas encadeadas, pilhas e filas"
},

{
  "id": "2012-30",
  "edicao": 2012,
  "numero": 30,
  "enunciado": "O encapsulamento dos dados tem como objetivo ocultar os detalhes da implementação de um determinado módulo. Em linguagens orientadas a objeto, o ocultamento de informação é tornado explícito requerendo-se que todos os métodos e atributos em uma classe tenham um nível particular de visibilidade com relação às suas subclasses e às classes clientes.\n\nEm relação aos atributos de visibilidade, assinale a alternativa correta.",
  "alternativas": [
    "a) Um atributo ou método público é visível a qualquer classe cliente e subclasse da classe a que ele pertence.",
    "b) Um atributo ou método protegido é visível somente à classe a que ele pertence, mas não às suas subclasses ou aos seus clientes.",
    "c) Um atributo ou método privado é vísivel somente às subclasses da classe a que ele pertence.",
    "d) Um método protegido não pode acessar os atributos privados declarados na classe a que ele pertence, sendo necessária a chamada de outro método privado da classe.",
    "e) Um método público pode acessar somente atributos públicos declarados na classe a que ele pertence."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens de Programação",
  "subarea": "Paradigmas de Linguagens de Programação",
  "gabarito": "A",
  "atributo_rag": "fundamentos da computacao - linguagens de programacao - paradigmas de linguagens de programacao"
},

{
  "id": "2012-31",
  "edicao": 2012,
  "numero": 31,
  "enunciado": "Um tipo especial de sub-rotina é aquela que contém, em sua descrição, uma ou mais chamadas a si mesma. Uma rotina dessa natureza é denominada recursiva. A função recursiva, a seguir, foi desenvolvida na *Linguagem C*.\n```\nint PosComp (int num, int f) {\n  int aux1, aux2;\n  if (num < f)\n    return PosComp (num, f / 10);\n  if (num) {\n    aux1 = num / f;\n    num = num % f;\n    f = f / 10;\n    aux2 = PosComp (num, f);\n    return aux2 * 10 + aux1;\n  }\n  else return num;\n}\n```\nSe for realizada uma chamada dessa função com o comando \\\n`printf (\"%d\\n\",PosComp(12345,10000));` \\\no resultado apresentado no dispositivo de saída será:",
  "alternativas": [
    "a) 0",
    "b) 10000",
    "c) 12345",
    "d) 54321",
    "e) 12300"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Algoritmos e Estrutura de Dados",
  "subarea": "Recursividade: Conceito e Implementação",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - algoritmos e estrutura de dados - recursividade: conceito e implementacao"
},

{
  "id": "2012-32",
  "edicao": 2012,
  "numero": 32,
  "enunciado": "Em linguagens de programação declarativas, em especial aquelas que seguem o paradigma funcional, a lista é uma estrutura de dados fundamental. Uma lista representa coleções de objetos de um único tipo, sendo composta por dois elementos: a cabeça (*head*) e o corpo (*tail*), exceto quando está vazia. A cabeça é sempre o primeiro elemento e o corpo é uma lista com os elementos da lista original, excetuando-se o primeiro elemento. O programa Haskell, a seguir, apresenta uma função que utiliza essa estrutura de dados.\n```\n  poscomp :: [Int] -> [Int]\n  poscomp [] = []\n  poscomp [x] = [x]\n  poscomp (a:b:c) | a > b = b : (a : poscomp c)\n                  | otherwise = a : (b : poscomp c)\n```\nUma chamada a esta função através da consulta\n```\nposcomp [5,3,4,5,2,1,2,3,4]\n```\nproduzirá o resultado:",
  "alternativas": [
    "a) [1,2,2,3,3,4,4,5,5]",
    "b) [3,5,4,5,1,2,2,3,4]",
    "c) [5,3,4,5,2,1,2,3,4]",
    "d) [5,4,3,2,1]",
    "e) [5,3,4,2,1]"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens de Programação",
  "subarea": "Paradigmas de Linguagens de Programação",
  "gabarito": "B",
  "atributo_rag": "fundamentos da computacao - linguagens de programacao - paradigmas de linguagens de programacao"
},

{
  "id": "2012-33",
  "edicao": 2012,
  "numero": 33,
  "enunciado": "Arquivos são organizados em sequência de dados ou registros que são mapeados para o armazenamento em blocos no disco.\n\nSobre os métodos de acesso a arquivos, assinale a alternativa correta.",
  "alternativas": [
    "a) O método de acesso sequencial é simples, pois consiste em acessar os dados de maneira aleatória, o que faz com que seja rápido e eficiente.",
    "b) O método de acesso sequencial é simples, pois consiste em acessar os dados através de uma estrutura de índice, o que faz com que seja rápido e eficiente.",
    "c) O método de acesso direto é simples, pois consiste em acessar todos os dados do arquivo do início ao fim, na sequência em que foram armazenados.",
    "d) O método de acesso direto é simples, pois consiste em acessar todos os dados do arquivo diretamente, o que faz com que seja lento e pouco eficiente.",
    "e) O método de acesso sequencial é simples, pois consiste em acessar os dados na ordem em que estão armazenados, porém não é o método mais rápido."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Organização de Arquivos e Dados",
  "subarea": "Organização, Estrutura e Operação de Arquivos",
  "gabarito": "E",
  "atributo_rag": "fundamentos da computacao - organizacao de arquivos e dados - organizacao, estrutura e operacao de arquivos"
},

{
  "id": "2012-34",
  "edicao": 2012,
  "numero": 34,
  "enunciado": "Arquivos são organizados em sequência de dados ou registros, que são mapeados para blocos de armazenamento secundário. Existem três tipos de arquivos: sequencial, direto e indexado.\n\nSobre arquivos indexados, considere as afirmativas a seguir.\n\nI. Em um índice denso, existe um registro para cada valor de chave no arquivo principal. \\\nII. Em um índice esparso, existe um registro para cada conjunto de valores de chave no arquivo principal. \\\nIII. Com o índice denso, o tempo para localizar dados no arquivo principal é menor do que com o índice esparso. \\\nIV. Com o índice esparso, o espaço utilizado com o arquivo de índice é maior do que com índice denso. \n\nAssinale a alternativa correta.",
  "alternativas": [
    "a) Somente as afirmativas I e II são corretas.",
    "b) Somente as afirmativas I e IV são corretas.",
    "c) Somente as afirmativas III e IV são corretas.",
    "d) Somente as afirmativas I, II e III são corretas.",
    "e) Somente as afirmativas II, III e IV são corretas."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Organização de Arquivos e Dados",
  "subarea": "Organização, Estrutura e Operação de Arquivos",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - organizacao de arquivos e dados - organizacao, estrutura e operacao de arquivos"
},

{
  "id": "2012-35",
  "edicao": 2012,
  "numero": 35,
  "enunciado": "Concernente aos algoritmos em grafos, relacione a coluna da esquerda com a da direita.\n```\n(I) Ordenação Topológica (Topsort).\n(II) Árvore Geradora Minimal (Prim).\n(III) Caminhos mais curtos (Dijkstra). \n(IV) Componentes fortemente conexas(CFC).\n(V) Árvore Geradora Minimal (Kruskal).\n--------------------------------------------------------------------------------------------------------------------------------------------\n(A) Toma como entrada um grafo orientado, utiliza basicamente a busca em profundidade e o conceito de grafo transposto para resolver o problema.\n(B) Toma como entrada um grafo não orientado com pesos nas arestas, ordena as arestas por peso e escolhe as arestas de forma a não fechar ciclos para resolver o problema.\n(C) Toma como entrada um grafo orientado acíclico, utiliza basicamente busca em profundidade e rotulação de vértices para resolver o problema.\n(D) Toma como entrada um grafo não orientado com pesos nas arestas, utiliza basicamente busca em largura escolhendo arestas de menor peso para resolver o problema\n(E) Toma como entrada um grafo não orientado com pesos nas arestas, utiliza basicamente busca em largura escolhendo distâncias acumuladas de menor peso para resolver o problema.\n```\nAssinale a alternativa que contém a associação correta.",
  "alternativas": [
    "a) I-A, II-B, III-C, IV-D, V-E.",
    "b) I-C, II-D, III-E, IV-A, V-B.",
    "c) I-C, II-E, III-B, IV-A, V-D.",
    "d) I-D, II-B, III-A, IV-C, V-E.",
    "e) I-D, II-E, III-A, IV-B, V-C."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Teoria dos Grafos",
  "subarea": "Algoritmos em grafos",
  "gabarito": "B",
  "atributo_rag": "fundamentos da computacao - teoria dos grafos - algoritmos em grafos"
},

{
  "id": "2012-36",
  "edicao": 2012,
  "numero": 36,
  "enunciado": "Seja $G = (V, E)$ um grafo em que $V$ é o conjunto de vértices e E é o conjunto de arestas. \n\nCom base nesse grafo, considere as afirmativas a seguir.\n\nI. Se $G$ é o $K_{3,3}$ então o número cromático de $G$ é $3$. \\\nII. Se $G$ é o $K_{3,3}$ então, retirando-se uma aresta de $G$, o grafo se torna planar. \\\nIII. Se $G$ é o $K_{2,2}$ então $G$ é um grafo euleriano e hamiltoniano ao mesmo tempo. \\\nIV. Se $G$ é um $K_{n,n}$ então $G$ tem um conjunto independente máximo igual a $n$. \n\nAssinale a alternativa correta.",
  "alternativas": [
    "a) Somente as afirmativas I e II são corretas.",
    "b) Somente as afirmativas I e IV são corretas.",
    "c) Somente as afirmativas III e IV são corretas.",
    "d) Somente as afirmativas I, II e III são corretas.",
    "e) Somente as afirmativas II, III e IV são corretas."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Teoria dos Grafos",
  "subarea": "Coloração",
  "gabarito": "E",
  "atributo_rag": "fundamentos da computacao - teoria dos grafos - coloracao"
},

{
  "id": "2012-37",
  "edicao": 2012,
  "numero": 37,
  "enunciado": "Arquivos são organizados em dados ou registros, que são mapeados para o armazenamento em blocos no disco. Arquivos podem ser organizados em estruturas de diretórios.\n\nSobre diretórios, assinale a alternativa correta.",
  "alternativas": [
    "a) Um diretório informa quais arquivos estão no disco (ou unidade de armazenamento) e pode ser entendido como um conjunto de referências a arquivos.",
    "b) Um diretório contém ponteiros para seus arquivos. A forma mais simples e eficiente de organizar os arquivos de um sistema é colocá-los em um único diretório.",
    "c) Um diretório linear é aquele que contém todos os arquivos de um sistema e é ideal para sistemas de grande capacidade de armazenamento e multiusuários.",
    "d) Um diretório formado por vários diretórios pode ser organizado em forma de árvore, em que cada diretório possui um subdiretório raiz.",
    "e) Um diretório organizado em forma de árvore contém vários arquivos, os quais possuem caminhos absolutos, ou seja, caminhos relativos à raiz do sistema."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Organização de Arquivos e Dados",
  "subarea": "Organização, Estrutura e Operação de Arquivos",
  "gabarito": "A",
  "atributo_rag": "fundamentos da computacao - organizacao de arquivos e dados - organizacao, estrutura e operacao de arquivos"
},

{
  "id": "2012-38",
  "edicao": 2012,
  "numero": 38,
  "enunciado": "Sejam $G = (V, E)$ um grafo conexo não orientado com pesos distintos nas arestas e $e \\in E$ uma aresta fixa, em que $|V| = n$ é o número de vértices e $|E| = m$ é o número de arestas de $G$, com $n \\leq m$.\n\nCom relação à geração da árvore de custo mínimo de $G$, $AGM_G$, assinale a alternativa correta.",
  "alternativas": [
    "a) Quando $e$ tem o peso da aresta com o ($n - 1$)-ésimo menor peso de $G$ então $e$ garantidamente estará numa $AGM_G$.",
    "b) Quando $e$ tem o peso da aresta com o maior peso em $G$ então $e$ garantidamente não estará numa $AGM_G$.",
    "c) Quando $e$ tem o peso maior ou igual ao da aresta com o $n$-ésimo menor peso em $G$ então e pode estar numa $AGM_G$.",
    "d) Quando $e$ tem o peso distinto do peso de qualquer outra aresta em $G$ então pode existir mais de uma $AGM_G$.",
    "e) Quando $e$ está num ciclo em $G$ e tem o peso da aresta de maior peso neste ciclo então $e$ garantidamente não estará numa $AGM_G$."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Teoria dos Grafos",
  "subarea": "Árvore Geradora",
  "gabarito": "C",
  "atributo_rag": "fundamentos da computacao - teoria dos grafos - arvore geradora"
},

{
  "id": "2012-39",
  "edicao": 2012,
  "numero": 39,
  "enunciado": "Com relação a técnicas de pesquisa em arquivos, assinale a alternativa correta.",
  "alternativas": [
    "a) Para a pesquisa binária funcionar, o arquivo precisa estar ordenado de acordo com algum campo aleatório.",
    "b) Para a pesquisa sequencial funcionar, o arquivo precisa estar ordenado.",
    "c) Para a pequisa binária funcionar, o arquivo precisa estar ordenado de acordo com o campo de busca.",
    "d) Para as pesquisas sequencial e binária funcionarem, o arquivo precisa estar ordenado de acordo com o campo de busca.",
    "e) Para as pesquisas sequencial e binária funcionarem, o arquivo não precisa estar ordenado."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Organização de Arquivos e Dados",
  "subarea": "Técnicas de Pesquisa",
  "gabarito": "C",
  "atributo_rag": "fundamentos da computacao - organizacao de arquivos e dados - tecnicas de pesquisa"
},

{
  "id": "2012-40",
  "edicao": 2012,
  "numero": 40,
  "enunciado": "Sobre gramáticas e linguagens, considere as afirmativas a seguir.\n\nI. Uma gramática na Forma Normal de Chomsky pode ser ambígua. \\\nII. Uma gramática ambígua pode gerar uma linguagem inerentemente não ambígua. \\\nIII. Uma gramática na Forma Normal de Greibach pode ser convertida para a Forma Normal de Chomsky. \\\nIV. O algoritmo de conversão de Gramática Livre de Contexto para Gramática na Forma Normal de Chomsky pode ser diretamamente aplicado a uma gramática que não seja $\\lambda$-livre. \n\nAssinale a alternativa correta.",
  "alternativas": [
    "a) Somente as afirmativas I e II são corretas.",
    "b) Somente as afirmativas I e IV são corretas.",
    "c) Somente as afirmativas III e IV são corretas.",
    "d) Somente as afirmativas I, II e III são corretas.",
    "e) Somente as afirmativas II, III e IV são corretas."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens Formais, Autômatos e Computabilidade",
  "subarea": "Linguagens Regulares, Livres-de-Contexto e Sensíveis-ao-Contexto",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - linguagens formais, automatos e computabilidade - linguagens regulares, livres-de-contexto e sensiveis-ao-contexto"
},

{
  "id": "2012-41",
  "edicao": 2012,
  "numero": 41,
  "enunciado": "Seja um Autômato Finito Não Determinístico (AFN) com 6 estados. Aplicando-se o algoritmo de conversão de um AFN para um Autômato Finito Determinístico (AFD), em quantos estados, no máximo, resultaria o AFD considerando-se os estados inúteis?",
  "alternativas": [
    "a) 12",
    "b) 36",
    "c) 64",
    "d) 1024",
    "e) 46656"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens Formais, Autômatos e Computabilidade",
  "subarea": "Autômatos de Estados Finitos Determinístico e não Determinístico",
  "gabarito": "C",
  "atributo_rag": "fundamentos da computacao - linguagens formais, automatos e computabilidade - automatos de estados finitos deterministico e nao deterministico"
},

{
  "id": "2012-42",
  "edicao": 2012,
  "numero": 42,
  "enunciado": "Assinale a alternativa que apresenta, corretamente, uma expressão regular que denota todas as *strings* de $a$’s e $b$’s que têm pelo menos dois $b$’s consecutivos.",
  "alternativas": [
    "a) $(a^*+bb)(a+ba)^*(a+b)^*$",
    "b) $(a+ba)^*bb(ba+a)^*$",
    "c) $(a+b)^*ba^*b(a+b)^*$",
    "d) $(a+bb)^*(bb+a)^*$",
    "e) $(a+ba)^*bb(a+b)^*$"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens Formais, Autômatos e Computabilidade",
  "subarea": "Linguagens Regulares, Livres-de-Contexto e Sensíveis-ao-Contexto",
  "gabarito": "E",
  "atributo_rag": "fundamentos da computacao - linguagens formais, automatos e computabilidade - linguagens regulares, livres-de-contexto e sensiveis-ao-contexto"
},

{
  "id": "2012-44",
  "edicao": 2012,
  "numero": 44,
  "enunciado": "Uma máquina M1 opera a 1400 MHz e possui 3 tipos de instruções: A, B e C, que gastam 1, 2 e 4 ciclos, respectivamente. Um determinado programa P executado nessa máquina utilizou 20% de instruções do tipo A, 30% de instruções do tipo B e 50% de instruções do tipo C. Uma máquina M2 possui também 3 tipos de instruções: D, E e F, que gastam 3, 4 e 5 ciclos, respectivamente. O programa P, ao ser executado em M2, utilizou 30% de instruções do tipo D, 40% de instruções do tipo E e 30% de instruções do tipo F. \n\nAssinale a alternativa que apresenta, corretamente, a frequência de operação que a máquina M2 deve ter para que o programa P execute no mesmo tempo em ambas as máquinas.",
  "alternativas": [
    "a) 1,6 GHz",
    "b) 1,8 GHz",
    "c) 2,0 GHz",
    "d) 2,2 GHz",
    "e) 2,3 GHz"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Arquitetura e Organização de Computadores",
  "subarea": "Organização de Computadores: Memórias, Unidades Centrais de Processamento, Entrada e Saída",
  "gabarito": "C",
  "atributo_rag": "fundamentos da computacao - arquitetura e organizacao de computadores - organizacao de computadores: memorias, unidades centrais de processamento, entrada e saida"
},

{
  "id": "2012-46",
  "edicao": 2012,
  "numero": 46,
  "enunciado": "Com relação a processadores, considere as afirmativas a seguir.\n\nI. Arquiteturas Superescalares podem executar instruções concorrentemente em *pipelines* diferentes. \\\nII. O *superpipeline* permite a execução de duas tarefas em um único ciclo de *clock* do processador. \\\nIII. Multiprocessadores simétricos compartilham a utilização da memória principal. \\\nIV. A utilização de uma memória cache L2 compartilhada em processadores *multicore* é vantajosa em *threads* que possuem alta localidade. \n\nAssinale a alternativa correta.",
  "alternativas": [
    "a) Somente as afirmativas I e II são corretas.",
    "b) Somente as afirmativas I e IV são corretas.",
    "c) Somente as afirmativas III e IV são corretas.",
    "d) Somente as afirmativas I, II e III são corretas.",
    "e) Somente as afirmativas II, III e IV são corretas."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Arquitetura e Organização de Computadores",
  "subarea": "Processadores Superescalares e Superpipeline",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - arquitetura e organizacao de computadores - processadores superescalares e superpipeline"
},

{
  "id": "2012-47",
  "edicao": 2012,
  "numero": 47,
  "enunciado": "O fenômeno de *thrashing* de um sistema é caracterizado por:",
  "alternativas": [
    "a) Excesso de processos executando no sistema.",
    "b) Impossibilidade de uso de memória virtual.",
    "c) Execução excessiva de coleta de lixo (*garbage collection*) na memória.",
    "d) Falhas eventuais no atendimento ao princípio da localidade na memória.",
    "e) Uso de algoritmos de paginação que causem a anomalia de Belady."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Sistemas Operacionais",
  "subarea": "Gerenciamento de Memória: Memória Virtual, Paginação, Segmentação e “Swap”",
  "gabarito": "A",
  "atributo_rag": "fundamentos da computacao - sistemas operacionais - gerenciamento de memoria: memoria virtual, paginacao, segmentacao e “swap”"
},

{
  "id": "2012-48",
  "edicao": 2012,
  "numero": 48,
  "enunciado": "Com relação a barramento, atribua V (verdadeiro) ou F (falso) às afirmativas a seguir.\n\n( ) Um barramento possui linhas de controle, de dados e de endereço. \\\n( ) Um barramento síncrono permite a melhor utilização de dispositivos com diferentes taxas de transferência. \\\n( ) A arbitração de um barramento pode ser centralizada ou distribuída. \\\n( ) A largura do barramento de endereço determina a quantidade de bits que podem ser transferidos de cada vez. \\\n( ) Um barramento multiplexado permite uma menor disputa de acesso por parte dos dispositivos do sistema. \n\nAssinale a alternativa que contém, de cima para baixo, a sequência correta.",
  "alternativas": [
    "a) V, F, V, F, F.",
    "b) V, F, F, V, V.",
    "c) F, V, V, V, F.",
    "d) F, V, F, V, V.",
    "e) F, F, V, F, V."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Arquitetura e Organização de Computadores",
  "subarea": "Barramento, Comunicações, Interfaces e Periféricos",
  "gabarito": "A",
  "atributo_rag": "fundamentos da computacao - arquitetura e organizacao de computadores - barramento, comunicacoes, interfaces e perifericos"
},

{
  "id": "2012-49",
  "edicao": 2012,
  "numero": 49,
  "enunciado": "O gerenciamento de memória virtual (MV) pressupõe a existência de tabelas de páginas e mecanismos para ranqueamento de páginas, além da existência do princípio da localidade.\n\nConsiderando que o algoritmo de MV, utilizado em um dado sistema, permite que as páginas envolvidas na operação de *swapping* sejam de conjuntos residentes diferentes, assinale a alternativa que apresenta, corretamente, o impacto disso sobre os processos em execução.",
  "alternativas": [
    "a) Deve piorar a taxa de faltas de páginas por não respeitar o princípio da localidade.",
    "b) Pode criar a ocorrência de *deadlocks* entre os processos que usam os conjuntos residentes envolvidos.",
    "c) Deve melhorar a taxa de faltas de páginas por ajustar o tamanho dos vários conjuntos residentes.",
    "d) Não altera a taxa de faltas de páginas pois essas não dependem dos conjuntos residentes.",
    "e) Força o bloqueio desnecessário de um processo que não teve falta de página enquanto o *swapping* estava sendo realizado."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Sistemas Operacionais",
  "subarea": "Gerenciamento de Memória: Memória Virtual, Paginação, Segmentação e “Swap”",
  "gabarito": "C",
  "atributo_rag": "fundamentos da computacao - sistemas operacionais - gerenciamento de memoria: memoria virtual, paginacao, segmentacao e “swap”"
},

{
  "id": "2012-50",
  "edicao": 2012,
  "numero": 50,
  "enunciado": "O projetista de um sistema operacional percebeu, após medições de desempenho, que o sistema apresentava problemas no acesso ao disco, com um tempo de espera médio bastante elevado.\n\nAssinale a alternativa que apresenta, correta e respectivamente, uma causa plausível e sua solução.",
  "alternativas": [
    "a) Algoritmo para escalonamento de disco ineficiente; troca para algum algoritmo do tipo menor distância primeiro.",
    "b) Controle de dispositivo baseado em fila; troca para controle de dispositivo baseado em prioridade.",
    "c) Controle de dispositivo baseado em prioridade; troca para controle de dispositivo baseado em fila.",
    "d) Algoritmo para escalonamento de disco ineficiente; troca para algum algoritmo do tipo varredura.",
    "e) Controle de dispositivo baseado em pilha; troca para controle de dispositivo baseado em prioridade."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Sistemas Operacionais",
  "subarea": "Gerenciamento de Dispositivos de Entrada/Saída",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - sistemas operacionais - gerenciamento de dispositivos de entrada/saida"
},

{
  "id": "2013-22",
  "edicao": 2013,
  "numero": 22,
  "enunciado": "Sobre arquivos e a alocação contígua em disco, considere as afirmativas a seguir.\n\nI. Exige que se armazene o número do primeiro bloco do arquivo.\\\nII. Fornece um desempenho excelente em operações de leitura.\\\nIII. Melhora o desempenho de acesso aleatório aos arquivos.\\\nIV. Minimiza a fragmentação de disco.\n\nAssinale a alternativa correta.",
  "alternativas": [
    "a) Somente as afirmativas I e II são corretas.",
    "b) Somente as afirmativas I e IV são corretas.",
    "c) Somente as afirmativas III e IV são corretas.",
    "d) Somente as afirmativas I, II e III são corretas.",
    "e) Somente as afirmativas II, III e IV são corretas."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Sistemas Operacionais",
  "subarea": "Gerenciamento de Arquivos",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - sistemas operacionais - gerenciamento de arquivos"
},

{
  "id": "2013-24",
  "edicao": 2013,
  "numero": 24,
  "enunciado": "Sobre arquivos, considere as afirmativas a seguir.\n\nI. A alocação de arquivos por lista encadeada utiliza a primeira palavra de cada bloco como ponteiro para o próximo bloco.\\\nII. A alocação de arquivos por lista encadeada faz com que a leitura aleatória do arquivo seja lenta.\\\nIII. Na alocação de arquivos por lista encadeada, os blocos de dados armazenam uma quantidade de informação que é um múltiplo de 2.\\\nIV. Na alocação de arquivos por lista encadeada, para manter uma entrada de diretório, é suficiente armazenar a quantidade de blocos que o arquivo ocupa.\n\nAssinale a alternativa correta.",
  "alternativas": [
    "a) Somente as afirmativas I e II são corretas.",
    "b) Somente as afirmativas I e IV são corretas.",
    "c) Somente as afirmativas III e IV são corretas.",
    "d) Somente as afirmativas I, II e III são corretas.",
    "e) Somente as afirmativas II, III e IV são corretas."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Organização de Arquivos e Dados",
  "subarea": "Organização, Estrutura e Operação de Arquivos",
  "gabarito": "A",
  "atributo_rag": "fundamentos da computacao - organizacao de arquivos e dados - organizacao, estrutura e operacao de arquivos"
},

{
  "id": "2013-25",
  "edicao": 2013,
  "numero": 25,
  "enunciado": "As Estruturas de Dados (ED) são representadas classicamente por Tipos Abstratos de Dados (TAD), que permitem definir e especificar estas estruturas. Cada TAD pode ter diferentes tipos de operações, mas há três operações que são básicas e devem existir em qualquer TAD (além da definição de tipo de dado).\n\nAssinale a alternativa que apresenta, corretamente, essas três operações básicas.",
  "alternativas": [
    "a) TAD de Pilha: Definição do dado (tipo utilizado) e as operações de inclusão inserção (empilhamento), remoção (desempilhamento) e impressão (apresentação dos dados).",
    "b) TAD de Pilha: Definição do dado (tipo utilizado) e as operações de inserção, remoção e impressão (apresentação dos dados).",
    "c) TAD de Fila: Definição do dado (tipo utilizado) e as operações de inserção, remoção e inicialização (criação) da estrutura.",
    "d) TAD de Fila: Definição do dado (tipo utilizado) e as operações de inicialização (criação), inserção e impressão\n(apresentação dos dados).",
    "e) TAD de Lista: Definição do dado (tipo utilizado) e as operações de inicialização (criação), inserção numa posição da Lista e remoção de todos os elementos da Lista (destruição da lista)."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Algoritmos e Estrutura de Dados",
  "subarea": "Estruturas de Dados Lineares e suas Generalizações: Listas Ordenadas, Listas Encadeadas, Pilhas e Filas",
  "gabarito": "C",
  "atributo_rag": "fundamentos da computacao - algoritmos e estrutura de dados - estruturas de dados lineares e suas generalizacoes: listas ordenadas, listas encadeadas, pilhas e filas"
},

{
  "id": "2013-26",
  "edicao": 2013,
  "numero": 26,
  "enunciado": "Sobre sistemas de arquivos virtuais, considere as afirmativas a seguir.\n\nI. Fornece suporte a sistemas de arquivos remotos.\\\nII. Possui uma interface superior com os arquivos do sistema.\\\nIII. Sua ideia principal é abstrair a parte comum aos diversos sistemas de arquivo.\\\nIV. Tenta integrar diferentes sistemas de arquivos em uma estrutura ordenada.\n\nAssinale a alternativa correta.",
  "alternativas": [
    "a) Somente as afirmativas I e II são corretas.",
    "b) Somente as afirmativas I e IV são corretas.",
    "c) Somente as afirmativas III e IV são corretas.",
    "d) Somente as afirmativas I, II e III são corretas.",
    "e) Somente as afirmativas II, III e IV são corretas."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Sistemas Operacionais",
  "subarea": "Gerenciamento de Arquivos",
  "gabarito": "ANULADA",
  "atributo_rag": "fundamentos da computacao - sistemas operacionais - gerenciamento de arquivos"
},

{
  "id": "2013-27",
  "edicao": 2013,
  "numero": 27,
  "enunciado": "Em relação aos conceitos e paradigmas de linguagens de programação, considere as afirmativas a seguir.\n\nI. A programação funcional oferece recursos de linguagem para processamento de listas, cuja necessidade surgiu a partir das primeiras aplicações na área de inteligência artificial.\\\nII. A programação imperativa classifica os problemas que utilizam modelos conexionistas para a modelagem e representação dos dados de entrada e saída do conjunto de treinamento.\\\nIII. A programação orientada a objetos trabalha com tipos de dados abstratos, vinculação dinâmica e herança, o que faz com que esse paradigma seja lento e impróprio para problemas reais.\\\nIV. O cálculo de predicado é a notação usada na programação lógica. Nesse paradigma, os programas não declaram exatamente como um resultado deve ser computado, em vez disso, descrevem a forma do resultado. \n\nAssinale a alternativa correta.",
  "alternativas": [
    "a) Somente as afirmativas I e II são corretas.",
    "b) Somente as afirmativas I e IV são corretas.",
    "c) Somente as afirmativas III e IV são corretas.",
    "d) Somente as afirmativas I, II e III são corretas.",
    "e) Somente as afirmativas II, III e IV são corretas."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens de Programação",
  "subarea": "Paradigmas de Linguagens de Programação",
  "gabarito": "B",
  "atributo_rag": "fundamentos da computacao - linguagens de programacao - paradigmas de linguagens de programacao"
},

{
  "id": "2013-28",
  "edicao": 2013,
  "numero": 28,
  "enunciado": "Com base nos conhecimentos sobre programação, relacione as linguagens ou pseudolinguagens de programação, na coluna da esquerda, com seus principais tipos de dados básicos, na coluna da direita.\\\n**(I) C**\\\n**(II) C#**\\\n**(III) Java**\\\n**(IV) Pascal**\\\n**(V) VisuAlg**\\\n---------------------------------------------------\\\n**(A) caracter, logico, inteiro, real.**\\\n**(B) char, boolean, integer, real.**\\\n**(C) char, int, boolean, float, double.**\\\n**(D) char, int, bool, float, double.**\\\n**(E) char, int, float, double.**\n\nAssinale a alternativa que contém a associação correta.",
  "alternativas": [
    "a) I-A, II-B, III-C, IV-D, V-E.",
    "b) I-A, II-C, III-E, IV-D, V-B.",
    "c) I-B, II-C, III-D, IV-E, V-A.",
    "d) I-B, II-D, III-A, IV-C, V-E.",
    "e) I-E, II-D, III-C, IV-B, V-A."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens de Programação",
  "subarea": "Paradigmas de Linguagens de Programação",
  "gabarito": "E",
  "atributo_rag": "fundamentos da computacao - linguagens de programacao - paradigmas de linguagens de programacao"
},

{
  "id": "2013-29",
  "edicao": 2013,
  "numero": 29,
  "enunciado": "Em relação aos conceitos de verificação e tipos de uma linguagem de programação, considere as afirmativas a seguir.\n\nI. A verificação de tipos é a atividade de assegurar que os operandos de um operador sejam de tipos compatíveis. Um tipo compatível é aquele válido para o operador ou com permissão, nas regras da linguagem, para ser convertido pelo código gerado pelo compilador para um tipo válido. \\\nII. É melhor detectar erros durante a execução do que na compilação de um programa, pois no processo de compilação de um algoritmo deve-se dar prioridade a questões mais complexas da análise semântica do programa. \\\nIII. Quando uma linguagem permite que uma dada célula de memória armazene valores de diferentes tipos em diversos momentos durante a execução, a verificação de tipos torna-se desnecessária, pois não há como realizar um controle de tipos em iterações diferentes do algoritmo. \\\nIV. Se todas as vinculações de variáveis a tipos forem estáticas em uma linguagem, a verificação de tipos quase sempre poderá ser feita estaticamente. A vinculação dinâmica de tipos requer a verificação destes em tempo de execução, o que é chamado de verificação dinâmica de tipos.\n\nAssinale a alternativa correta.",
  "alternativas": [
    "a) Somente as afirmativas I e II são corretas.",
    "b) Somente as afirmativas I e IV são corretas.",
    "c) Somente as afirmativas III e IV são corretas.",
    "d) Somente as afirmativas I, II e III são corretas.",
    "e) Somente as afirmativas II, III e IV são corretas."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens de Programação",
  "subarea": "Verificação e Inferência de Tipos",
  "gabarito": "B",
  "atributo_rag": "fundamentos da computacao - linguagens de programacao - verificacao e inferencia de tipos"
},

{
  "id": "2013-30",
  "edicao": 2013,
  "numero": 30,
  "enunciado": "Considere o trecho de código em linguagem de programação C a seguir.\n```\nmain()\n  {\n    int myCount = 0;\n    while (myCount < 10)\n    {\n      printf(\"%d\",myCount+1);\n    }\n    system(\"pause\");\n}\n```\nAssinale a alternativa que apresenta, corretamente, o que esse trecho de código fará ao ser executado.",
  "alternativas": [
    "a) Mostrará na tela os valores de 0 a 9.",
    "b) Mostrará na tela os valores de 1 a 10.",
    "c) Escreverá na tela `myCount` por 10 vezes.",
    "d) Escreverá na tela 0 por 10 vezes.",
    "e) Entrará em looping infinito."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens de Programação",
  "subarea": "Paradigmas de Linguagens de Programação",
  "gabarito": "E",
  "atributo_rag": "fundamentos da computacao - linguagens de programacao - paradigmas de linguagens de programacao"
},

{
  "id": "2013-31",
  "edicao": 2013,
  "numero": 31,
  "enunciado": "Entre as linguagens de programação mais comumente encontradas nas mais diversas aplicações, tem-se Java e C++. Sobre essas duas linguagens, atribua V (verdadeiro) ou F (falso) às afirmativas a seguir. \\\n\n( ) A linguagem C++ é uma extensão da linguagem C. \\\n( ) A linguagem Java é interpretada e C++ é compilada. \\\n( ) A linguagem Java possui tratamento de exceções. \\\n( ) Ambas possuem tipagem dinâmica. \\\n( ) O coletor de lixo de Java é automático e o de C++ é manual.\n\nAssinale a alternativa que contém, de cima para baixo, a sequência correta.",
  "alternativas": [
    "a) V, V, F, F, V.",
    "b) V, F, V, F, V.",
    "c) V, F, F, V, F.",
    "d) F, V, V, V, F.",
    "e) F, F, F, V, V."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens de Programação",
  "subarea": "Paradigmas de Linguagens de Programação",
  "gabarito": "B",
  "atributo_rag": "fundamentos da computacao - linguagens de programacao - paradigmas de linguagens de programacao"
},

{
  "id": "2013-32",
  "edicao": 2013,
  "numero": 32,
  "enunciado": "Analise os trechos de código em linguagem de programação C a seguir.\n\n**Trecho 1**\n```\nmain()\n{\n  int mat[2][2] = {{1,2},{3,4}};\n  int i,j;\n  for (i=0;i<2;i++)\n    for (j=0;j<2;j++)\n    printf(\"%d\\n\",mat[i][j]);\n  system(\"pause\");\n}\n```\n\n**Trecho 2**\n```\nmain()\n{\n  int mat[2][2] = {{1,2},{3,4}};\n  int *p = &mat[0][0];\n  int i;\n  for (i=0;i<4;i++)\n    printf(\"%d\\n\",*(p+i));\n  system(\"pause\");\n}\n```\nCom base nesses trechos, assinale a alternativa correta.",
  "alternativas": [
    "a) O Trecho 1 imprimirá os valores da matriz mat e o Trecho 2 indicará um erro de sintaxe na inicialização do ponteiro.",
    "b) O Trecho 1 imprimirá os valores da matriz mat e o Trecho 2 indicará um erro de sintaxe no laço de repetição.",
    "c) O Trecho 1 imprimirá os valores da matriz mat e o Trecho 2 imprimirá valores desconhecidos alocados na memória.",
    "d) Ambos os trechos de código imprimirão o mesmo conteúdo na tela.",
    "e) Ambos os trechos de código indicarão erro de sintaxe na inicialização da matriz mat."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens de Programação",
  "subarea": "Paradigmas de Linguagens de Programação",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - linguagens de programacao - paradigmas de linguagens de programacao"
},

{
  "id": "2013-33",
  "edicao": 2013,
  "numero": 33,
  "enunciado": "Considere o algoritmo a seguir.\n```\nMERGESORT(V, i, j)\n(1) Se (i<j) então\n(2)    m = (i+j)/2;\n(3)    MERGESORT(v, i, m);\n(4)    MERGESORT(v, m+1, j);\n(5)    MESCLAR(v, i, m, j);\n(6) Fim;\n```\nSobre o comportamento assintótico do algoritmo de ordenação *Merge Sort*, assinale a alternativa que apresenta, corretamente, sua complexidade.",
  "alternativas": [
    "a) $O(\\log n)$",
    "b) $O(n \\log n)$",
    "c) $O(n^2)$",
    "d) $O(n^3)$",
    "e) $O(2^n)$"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Análise de Algoritmos",
  "subarea": "O Uso de Relações de Recorrência para Análise de Algoritmos Recursivos",
  "gabarito": "B",
  "atributo_rag": "fundamentos da computacao - analise de algoritmos - o uso de relacoes de recorrencia para analise de algoritmos recursivos"
},

{
  "id": "2013-35",
  "edicao": 2013,
  "numero": 35,
  "enunciado": "Quanto ao fechamento para linguagens livres de contexto, atribua V (verdadeiro) ou F (falso) às operações a seguir.\n\n( ) Concatenação.\\\n( ) Complemento.\\\n( ) Homomorfismo.\\\n( ) Interseção.\\\n( ) Reverso.\n\nAssinale a alternativa que contém, de cima para baixo, a sequência correta.",
  "alternativas": [
    "a) V, V, F, F, V.",
    "b) V, F, V, V, F.",
    "c) V, F, V, F, V.",
    "d) F, V, V, F, F.",
    "e) F, V, F, V, F."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens Formais, Autômatos e Computabilidade",
  "subarea": "Propriedades das Linguagens",
  "gabarito": "C",
  "atributo_rag": "fundamentos da computacao - linguagens formais, automatos e computabilidade - propriedades das linguagens"
},

{
  "id": "2013-36",
  "edicao": 2013,
  "numero": 36,
  "enunciado": "Sobre a escolha adequada para um algoritmo de ordenação, considere as afirmativas a seguir.\n\nI. Quando os cenários de pior caso for a preocupação, o algoritmo ideal é o Heap Sort.\\\nII. Quando o vetor apresenta a maioria dos elementos ordenados, o algoritmo ideal é o Insertion Sort.\\\nIII. Quando o interesse for um bom resultado para o médio caso, o algoritmo ideal é o Quick Sort.\\\nIV. Quando o interesse é o melhor caso e o pior caso de mesma complexidade, o algoritmo ideal é o Bubble Sort.\n\nAssinale a alternativa correta.",
  "alternativas": [
    "a) Somente as afirmativas I e II são corretas.",
    "b) Somente as afirmativas I e IV são corretas.",
    "c) Somente as afirmativas III e IV são corretas.",
    "d) Somente as afirmativas I, II e III são corretas.",
    "e) Somente as afirmativas II, III e IV são corretas."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Algoritmos e Estrutura de Dados",
  "subarea": "Algoritmos para Pesquisa e Ordenação",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - algoritmos e estrutura de dados - algoritmos para pesquisa e ordenacao"
},

{
  "id": "2013-38",
  "edicao": 2013,
  "numero": 38,
  "enunciado": "Sobre o Lema do Bombeamento (*pumping lemma*) para linguagens regulares, considere as afirmativas a seguir.\n\nI. Se o alfabeto $\\sum = \\{a, b\\}$, então pode-se provar por absurdo, por meio do Bombeamento, que a linguagem $L_1 = \\{w \\in \\sum^* \\mid w \\text{ termina com } b\\}$ não é regular.\\\nII. Se o alfabeto $\\sum = \\{a, b\\}$, então pode-se provar por absurdo, por meio do Bombeamento, que a linguagem $L_2 = \\{(a^n)^2 \\mid n \\geq 1\\}$ não é regular.\\\nIII. Se o alfabeto $\\sum = \\{a, b\\}$, então pode-se provar por absurdo, por meio do Bombeamento, que as linguagens $L_3 = \\{a^{n!} \\mid n \\geq 1\\}$, $L_4 = \\{a^n ba^m ba^{n+m} \\mid n, m \\geq 1\\}$ e $L_5 = \\{a^{m+1} b^{n+1} \\mid 2 \\leq n \\leq m \\leq 3n\\}$\nnão são regulares.\\\nIV. Se a linguagem for do tipo 3, então aplica-se o Bombeamento.\n\nAssinale a alternativa correta.",
  "alternativas": [
    "a) Somente as afirmativas I e II são corretas.",
    "b) Somente as afirmativas I e IV são corretas.",
    "c) Somente as afirmativas III e IV são corretas.",
    "d) Somente as afirmativas I, II e III são corretas.",
    "e) Somente as afirmativas II, III e IV são corretas."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens Formais, Autômatos e Computabilidade",
  "subarea": "Linguagens Regulares, Livres-de-Contexto e Sensíveis-ao-Contexto",
  "gabarito": "E",
  "atributo_rag": "fundamentos da computacao - linguagens formais, automatos e computabilidade - linguagens regulares, livres-de-contexto e sensiveis-ao-contexto"
},

{
  "id": "2013-39",
  "edicao": 2013,
  "numero": 39,
  "enunciado": "Quanto à análise de algoritmos, considere as afirmativas a seguir.\n\nI. A programação dinâmica pode levar a soluções eficientes para algoritmos recursivos com complexidade exponencial.\\\nII. Os algoritmos tentativa e erro são impraticáveis com solução recursiva, pois são aplicados exaustivamente.\\\nIII. Um algoritmo recursivo tem tempo de execução inferior à codificação iterativa para a solução do mesmo problema.\\\nIV. Uma árvore binária de pesquisa é adequada para a solução de problemas de natureza recursiva.\n\nAssinale a alternativa correta.",
  "alternativas": [
    "a) Somente as afirmativas I e II são corretas.",
    "b) Somente as afirmativas I e IV são corretas.",
    "c) Somente as afirmativas III e IV são corretas.",
    "d) Somente as afirmativas I, II e III são corretas.",
    "e) Somente as afirmativas II, III e IV são corretas."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Análise de Algoritmos",
  "subarea": "Análise de Algoritmos Iterativos e Recursivos",
  "gabarito": "B",
  "atributo_rag": "fundamentos da computacao - analise de algoritmos - analise de algoritmos iterativos e recursivos"
},

{
  "id": "2013-41",
  "edicao": 2013,
  "numero": 41,
  "enunciado": "Se o estado inicial for também estado final em um autômato finito, então esse autômato",
  "alternativas": [
    "a) não aceita a cadeia vazia.",
    "b) não tem outros estados finais.",
    "c) é determinístico.",
    "d) aceita a cadeia vazia.",
    "e) é não determinístico."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens Formais, Autômatos e Computabilidade",
  "subarea": "Autômatos de Estados Finitos Determinístico e não Determinístico",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - linguagens formais, automatos e computabilidade - automatos de estados finitos deterministico e nao deterministico"
},

{
  "id": "2013-42",
  "edicao": 2013,
  "numero": 42,
  "enunciado": "Um programa $P$ é executado em um computador $C_1$, que possui velocidade de 2 GHz, em 5 segundos. Deseja-se projetar um computador $C_2$ de tal modo que o mesmo programa $P$ seja executado em 3 segundos em $C_2$. No projeto de $C_2$, verificou-se que, para atingir o objetivo, o programa $P$ irá gastar 50% mais ciclos de clock em $C_2$ do que em $C_1$.\n\nAssinale a alternativa que apresenta, corretamente, a frequência que $C_2$ deve ter para que $P$ seja executado em 3 segundos.",
  "alternativas": [
    "a) 3 GHz",
    "b) 4 GHz",
    "c) 5 GHz",
    "d) 6 GHz",
    "e) 7 GHz"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Arquitetura e Organização de Computadores",
  "subarea": "Organização de Computadores: Memórias, Unidades Centrais de Processamento, Entrada e Saída",
  "gabarito": "C",
  "atributo_rag": "fundamentos da computacao - arquitetura e organizacao de computadores - organizacao de computadores: memorias, unidades centrais de processamento, entrada e saida"
},

{
  "id": "2013-43",
  "edicao": 2013,
  "numero": 43,
  "enunciado": "Um dos componentes vitais em um sistema operacional é a estrutura que armazena dados sobre os processos em execução, muitas vezes chamada Bloco de Controle de Processos (BCP). Essa estrutura é manipulada por todos os mecanismos de gerenciamento do SO, o que evidentemente cria problemas de condição de corrida nesse acesso.\n\nConsiderando essas informações, assinale a alternativa que apresenta, corretamente, o tratamento do acesso ao BCP em um SO.",
  "alternativas": [
    "a) A condição de corrida para acesso ao BCP inexiste em sistemas operacionais multithreaded.",
    "b) O controle do acesso ao BCP é possível apenas com o uso de semáforos, mesmo com o risco de ocorrência de deadlocks.",
    "c) O controle de acesso ao BCP pode tratar exclusão mútua por inibição de interrupções sem prejuízo de desempenho.",
    "d) O controle de acesso ao BCP tem que ser feito sem bloqueio dos mecanismos de gerenciamento, independentemente de condições de corrida.",
    "e) Os mecanismos de gerenciamento de memória e de entrada/saída não tratam condição de corrida, pois não necessitam alterar dados no BCP."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Sistemas Operacionais",
  "subarea": "Comunicação, Concorrência e Sincronização de Processos",
  "gabarito": "C",
  "atributo_rag": "fundamentos da computacao - sistemas operacionais - comunicacao, concorrencia e sincronizacao de processos"
},

{
  "id": "2013-45",
  "edicao": 2013,
  "numero": 45,
  "enunciado": "A memória do computador é organizada em níveis. Assinale a alternativa que apresenta, corretamente, as estruturas encontradas no nível mais alto dessa hierarquia.",
  "alternativas": [
    "a) Cache L1.",
    "b) Cache L2.",
    "c) Disco rígido.",
    "d) Memória DRAM.",
    "e) Registradores do processador."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Arquitetura e Organização de Computadores",
  "subarea": "Organização de Memória",
  "gabarito": "E",
  "atributo_rag": "fundamentos da computacao - arquitetura e organizacao de computadores - organizacao de memoria"
},

{
  "id": "2013-46",
  "edicao": 2013,
  "numero": 46,
  "enunciado": "Apesar de a alocação de memória em blocos implicar em um mecanismo mais complexo para a conversão entre endereços virtuais e endereços físicos, é a partir do seu conceito que o gerenciamento de memória evoluiu para o que se tem hoje, com o uso de memória cache e memória virtual.\n\nCom base nessas informações, considere as afirmativas a seguir.\n\nI. O endereçamento é facilitado por hardware especializado.\\\nII. O uso de páginas de tamanho igual a potência de 2 permite um melhor gerenciamento.\\\nIII. O uso de memória cache elimina a necessidade de endereçamento, pois trata as informações como linhas de cache.\\\nIV. Endereços virtuais não são necessários se não se usar memória virtual.\n\nAssinale a alternativa correta.",
  "alternativas": [
    "a) Somente as afirmativas I e II são corretas.",
    "b) Somente as afirmativas I e IV são corretas.",
    "c) Somente as afirmativas III e IV são corretas.",
    "d) Somente as afirmativas I, II e III são corretas.",
    "e) Somente as afirmativas II, III e IV são corretas."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Arquitetura e Organização de Computadores",
  "subarea": "Organização de Computadores: Memórias, Unidades Centrais de Processamento, Entrada e Saída",
  "gabarito": "A",
  "atributo_rag": "fundamentos da computacao - arquitetura e organizacao de computadores - organizacao de computadores: memorias, unidades centrais de processamento, entrada e saida"
},

{
  "id": "2013-48",
  "edicao": 2013,
  "numero": 48,
  "enunciado": "Sobre memória cache, considere as afirmativas a seguir.\n\nI. No mapeamento associativo, cada bloco da memória principal pode ser carregado em qualquer linha da cache.\\\nII. No mapeamento direto, cada bloco da memória principal é mapeado a apenas uma linha de cache.\\\nIII. No mapeamento direto, o acesso repetido a diferentes blocos de memória mapeados na mesma linha de cache resultará em uma alta taxa de acerto.\\\nIV. A técnica de mapeamento associativo é simples e pouco dispendiosa para se implementar.\n\nAssinale a alternativa correta.",
  "alternativas": [
    "a) Somente as afirmativas I e II são corretas.",
    "b) Somente as afirmativas I e IV são corretas.",
    "c) Somente as afirmativas III e IV são corretas.",
    "d) Somente as afirmativas I, II e III são corretas.",
    "e) Somente as afirmativas II, III e IV são corretas."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Arquitetura e Organização de Computadores",
  "subarea": "Organização de Computadores: Memórias, Unidades Centrais de Processamento, Entrada e Saída",
  "gabarito": "A",
  "atributo_rag": "fundamentos da computacao - arquitetura e organizacao de computadores - organizacao de computadores: memorias, unidades centrais de processamento, entrada e saida"
},

{
  "id": "2013-49",
  "edicao": 2013,
  "numero": 49,
  "enunciado": "Um analista de suporte percebeu que o servidor de arquivos da empresa apresentava lentidão em determinados períodos do dia.\n\nAssinale a alternativa que apresenta, correta e respectivamente, uma causa plausível e sua solução ótima.",
  "alternativas": [
    "a) Algoritmo para escalonamento de disco ineficiente, devendo-se trocá-lo por outro algoritmo.",
    "b) Aparecimento de fenômeno de thrashing, devendo-se restringir o número de usuários simultâneos.",
    "c) Aparecimento de fenômeno de thrashing, devendo-se aumentar a quantidade de memória no servidor.",
    "d) Aparecimento de fenômenos de rajada, devendo-se separar os serviços oferecidos entre mais de um servidor.",
    "e) Aparecimento de fenômenos de rajada, devendo-se restringir o número de usuários simultâneos."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Sistemas Operacionais",
  "subarea": "Gerenciamento de Dispositivos de Entrada/Saída",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - sistemas operacionais - gerenciamento de dispositivos de entrada/saida"
},

{
  "id": "2014-21",
  "edicao": 2014,
  "numero": 21,
  "enunciado": "Considere o pseudocódigo a seguir.\n\n```\n    HUFFMAN(C)\n(1) n = |C|\n(2) Q = C\n(3) for i=1 to n-1\n(4)    alocar um novo nó z\n(5)    z.esquerda = x = EXTRAIR_MIN(Q)\n(6)    z.direita = y = EXTRAIR_MIN(Q)\n(7)    z.freq = x.freq + y.freq\n(8)    INSERIR(Q, z)\n(9) return EXTRAIR_MIN(Q) //retorna a raiz da árvore\n```\n\nSobre o pseudocódigo, é correto afirmar que é um algoritmo",
  "alternativas": [
    "a) aproximado.",
    "b) divisão-e-conquista.",
    "c) guloso.",
    "d) recursivo.",
    "e) tentativa e erro."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Algoritmos e Estrutura de Dados",
  "subarea": "Árvores e suas Generalizações: Árvores Binárias, Árvores de Busca e Árvores Balanceadas",
  "gabarito": "C",
  "atributo_rag": "fundamentos da computacao - algoritmos e estrutura de dados - arvores e suas generalizacoes: arvores binarias, arvores de busca e arvores balanceadas"
},

{
  "id": "2014-22",
  "edicao": 2014,
  "numero": 22,
  "enunciado": "Considere o pseudocódigo a seguir.\n\n```\n    HUFFMAN(C)\n(1) n = |C|\n(2) Q = C\n(3) for i=1 to n-1\n(4)    alocar um novo nó z\n(5)    z.esquerda = x = EXTRAIR_MIN(Q)\n(6)    z.direita = y = EXTRAIR_MIN(Q)\n(7)    z.freq = x.freq + y.freq\n(8)    INSERIR(Q, z)\n(9) return EXTRAIR_MIN(Q) //retorna a raiz da árvore\n```\nSobre o comportamento assintótico desse pseudocódigo, é correto afirmar que sua complexidade é",
  "alternativas": [
    "a) $O (n^2)$",
    "b) $O (n^3)$",
    "c) $O (2^n)$",
    "d) $O (2n)$",
    "e) $O (n \\log n)$"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Análise de Algoritmos",
  "subarea": "Medidas de Complexidade, Análise Assintótica de Limites de Complexidade, Técnicas de Prova de Cotas Inferiores",
  "gabarito": "E",
  "atributo_rag": "fundamentos da computacao - analise de algoritmos - medidas de complexidade, analise assintotica de limites de complexidade, tecnicas de prova de cotas inferiores"
},

{
  "id": "2014-23",
  "edicao": 2014,
  "numero": 23,
  "enunciado": "Sobre pilhas, lista e filas, considere as afirmativas a seguir.\n\nI. As estruturas de dados pilhas, filas e listas armazenam coleções de itens. A característica que as distinguem é a ordem em que podem ser retirados os itens dessas coleções em relação à ordem em que foram inseridos.\\\nII. Considere que os itens A, B, C, D, E foram inseridos nessa ordem em uma fila. Necessariamente, o primeiro elemento a ser removido dessa fila é o elemento A.\\\nIII. Considere que os itens A, B, C, D, E foram inseridos nessa ordem em uma pilha. Necessariamente, o último elemento a ser removido dessa pilha é o elemento E.\\\nIV. Considere que os itens A, B, C, D, E foram inseridos nessa ordem em uma lista. Necessariamente, o primeiro elemento a ser removido dessa lista é o elemento A. \n\nAssinale a alternativa correta.",
  "alternativas": [
    "a) Somente as afirmativas I e II são corretas.",
    "b) Somente as afirmativas I e IV são corretas.",
    "c) Somente as afirmativas III e IV são corretas.",
    "d) Somente as afirmativas I, II e III são corretas.",
    "e) Somente as afirmativas II, III e IV são corretas."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Algoritmos e Estrutura de Dados",
  "subarea": "Estruturas de Dados Lineares e suas Generalizações: Listas Ordenadas, Listas Encadeadas, Pilhas e Filas",
  "gabarito": "A",
  "atributo_rag": "fundamentos da computacao - algoritmos e estrutura de dados - estruturas de dados lineares e suas generalizacoes: listas ordenadas, listas encadeadas, pilhas e filas"
},

{
  "id": "2014-24",
  "edicao": 2014,
  "numero": 24,
  "enunciado": "Sejam uma árvore AVL $A$, $r$ a raiz de uma subárvore  $S$  de  $A$  e  $a_d$  e $a_e$, respectivamente, as alturas das subárvores direita e esquerda de S.\n\nEm relação a esse tema, assinale a alternativa correta.",
  "alternativas": [
    "a) $a_e = a_d$",
    "b) $\\frac{a_e + a_d}{2} = 2a_e$",
    "c) Considere que $a_e < a_d$, portanto o valor de $a_d$ pode ser qualquer valor no intervalo $[a_e, 2a_e]$.",
    "d) Considere que $a_e < a_d$, portanto o valor de $a_d$ pode ser qualquer valor no intervalo $[a_e, 2^{a_e}]$.",
    "e) $|a_e - a_d| = 1$"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Algoritmos e Estrutura de Dados",
  "subarea": "Árvores e suas Generalizações: Árvores Binárias, Árvores de Busca e Árvores Balanceadas",
  "gabarito": "ANULADA",
  "atributo_rag": "fundamentos da computacao - algoritmos e estrutura de dados - arvores e suas generalizacoes: arvores binarias, arvores de busca e arvores balanceadas"
},

{
  "id": "2014-25",
  "edicao": 2014,
  "numero": 25,
  "enunciado": "Em relação ao limite assintótico de notação $O$, atribua V (verdadeiro) ou F (falso) às afirmativas a seguir.\n\n( ) Em uma estrutura de laço duplamente aninhado, tem-se imediatamente um limite superior $O(n^2)$.\\\n( ) Em uma estrutura de laço duplamente aninhado, o custo de cada iteração do laço interno é de limite superior $O(1)$.\\\n( ) Em uma estrutura de laço triplamente aninhado, o custo de cada iteração do laço interno é de limite superior $O(n^3)$.\\\n( ) O limite $O(n^2)$ para o tempo de execução do pior caso de execução aplica-se para qualquer entrada.\\\n( ) $f(n) = O(g(n))$ é uma afirmação de que algum múltiplo constante de $g(n)$ é de limite assintótico inferior.\n\nAssinale a alternativa que contém, de cima para baixo, a sequência correta.",
  "alternativas": [
    "a) V, V, F, V, F.",
    "b) V, F, V, F, V.",
    "c) F, V, V, F, F.",
    "d) F, F, V, V, F.",
    "e) F, F, F, V, V."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Análise de Algoritmos",
  "subarea": "Notação “Big O”, “Little o”, “Omega” e “Theta”",
  "gabarito": "A",
  "atributo_rag": "fundamentos da computacao - analise de algoritmos - notacao “big o”, “little o”, “omega” e “theta”"
},

{
  "id": "2014-26",
  "edicao": 2014,
  "numero": 26,
  "enunciado": "Sobre árvores binárias, considere as afirmativas a seguir.\n\nI. Qualquer nó de uma árvore binária é raiz de, no máximo, outras duas subárvores comumente denominadas subárvore direita e subárvore esquerda.\\\nII. Uma dada árvore binária $A$ armazena números inteiros e nela foram inseridos 936 valores não repetidos. Para determinar se um número $x$ está entre os elementos dessa árvore, tal número será comparado, no máximo, com 10 números contidos na árvore $A$.\\\nIII. Uma dada árvore binária de busca $A$ armazena números inteiros e nela foram inseridos 936 valores não repetidos. Para determinar se um número $x$ está entre os elementos dessa árvore, serão feitas, no máximo, 10 comparações.\\\nIV. Uma dada árvore binária de busca $A$ armazena números inteiros e nela foram inseridos 936 valores não repetidos. Supondo que $r$ seja o nó raiz da árvore $A$ e que sua subárvore esquerda contenha 460 elementos e sua subárvore direita possua 475 elementos. Para determinar se um número $x$ pertence a essa árvore, serão feitas, no máximo, 476 comparações. \n\nAssinale a alternativa correta.",
  "alternativas": [
    "a) Somente as afirmativas I e II são corretas.",
    "b) Somente as afirmativas I e IV são corretas.",
    "c) Somente as afirmativas III e IV são corretas.",
    "d) Somente as afirmativas I, II e III são corretas.",
    "e) Somente as afirmativas II, III e IV são corretas."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Algoritmos e Estrutura de Dados",
  "subarea": "Árvores e suas Generalizações: Árvores Binárias, Árvores de Busca e Árvores Balanceadas",
  "gabarito": "B",
  "atributo_rag": "fundamentos da computacao - algoritmos e estrutura de dados - arvores e suas generalizacoes: arvores binarias, arvores de busca e arvores balanceadas"
},

{
  "id": "2014-27",
  "edicao": 2014,
  "numero": 27,
  "enunciado": "Sobre linguagens puramente funcionais, considere as afirmativas a seguir.\n\nI. Programas são definições de funções e de especificações de aplicações dessas funções. A execução desses programas consiste em avaliar tais funções.\\\nII. A avaliação de uma função sempre produz o mesmo resultado, quando invocada com os mesmos argumentos.\\\nIII. A passagem de parâmetros para uma função pode ocorrer de duas formas: por valor ou por referência.\\\nIV. O estado interno de uma função é definido por seus parâmetros formais e por variáveis locais estáticas. Estas últimas podem armazenar valores calculados em invocações anteriores da função. \n\nAssinale a alternativa correta.",
  "alternativas": [
    "a) Somente as afirmativas I e II são corretas.",
    "b) Somente as afirmativas I e IV são corretas.",
    "c) Somente as afirmativas III e IV são corretas.",
    "d) Somente as afirmativas I, II e III são corretas.",
    "e) Somente as afirmativas II, III e IV são corretas."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens de Programação",
  "subarea": "Paradigmas de Linguagens de Programação",
  "gabarito": "A",
  "atributo_rag": "fundamentos da computacao - linguagens de programacao - paradigmas de linguagens de programacao"
},

{
  "id": "2014-29",
  "edicao": 2014,
  "numero": 29,
  "enunciado": "Sobre a estrutura de arquivos, considere as afirmativas a seguir.\n\nI. Um arquivo organizado como uma árvore fornece a máxima flexibilidade.\\\nII. Um arquivo organizado em registros utiliza registros de tamanho fixo.\\\nIII. Um arquivo organizado em árvore utiliza registros de tamanhos variáveis.\\\nIV. Um arquivo pode ser uma sequência de bytes, uma sequência de registros ou uma árvore. \n\nAssinale a alternativa correta.",
  "alternativas": [
    "a) Somente as afirmativas I e II são corretas.",
    "b) Somente as afirmativas I e IV são corretas.",
    "c) Somente as afirmativas III e IV são corretas.",
    "d) Somente as afirmativas I, II e III são corretas.",
    "e) Somente as afirmativas II, III e IV são corretas."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Organização de Arquivos e Dados",
  "subarea": "Organização, Estrutura e Operação de Arquivos",
  "gabarito": "E",
  "atributo_rag": "fundamentos da computacao - organizacao de arquivos e dados - organizacao, estrutura e operacao de arquivos"
},

{
  "id": "2014-30",
  "edicao": 2014,
  "numero": 30,
  "enunciado": "Considere o algoritmo a seguir.\n```\nAlgoritmo\n    declare valor, i, x, D, N, j, termo numérico;\n    valor ← 1;\n    i ← 2;\n    x ← 2\n    repita\n        N ← x^i;\n        j ← 1;\n        D ← 2;\n        repita\n            D ← D * j;\n            j ← j + 1;\n            se j >= i então\n                interrompa;\n            fim_se\n        fim_repita\n        termo ← (-1)^(i+1) * N/D;\n        valor ← valor + termo;\n        i ← i + 1;\n        se i > 5 então\n            interrompa;\n        fim_se\n    fim_repita\n    escreva “Valor =”, valor;\nFim Algoritmo.\n```\n\nAssinale a alternativa que apresenta, corretamente, o conteúdo da variável “valor” ao final da execução do algoritmo.",
  "alternativas": [
    "a) 0,2220",
    "b) 0,3330",
    "c) 1,2220",
    "d) 1,3330",
    "e) 3,1416"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Análise de Algoritmos",
  "subarea": "Análise de Algoritmos Iterativos e Recursivos",
  "gabarito": "B",
  "atributo_rag": "fundamentos da computacao - analise de algoritmos - analise de algoritmos iterativos e recursivos"
},

{
  "id": "2014-31",
  "edicao": 2014,
  "numero": 31,
  "enunciado": "Sobre LISP, considere a avaliação da expressão a seguir.\n```\n(car (cdr (car (cdr ’((A B C) (D E F) G)))))\n```\n\nAssinale a alternativa que apresenta, corretamente, o resultado dessa expressão.",
  "alternativas": [
    "a) `A`",
    "b) `C`",
    "c) `D`",
    "d) `E`",
    "e) `(D E F)`"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens de Programação",
  "subarea": "Paradigmas de Linguagens de Programação",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - linguagens de programacao - paradigmas de linguagens de programacao"
},

{
  "id": "2014-32",
  "edicao": 2014,
  "numero": 32,
  "enunciado": "Sobre grafos, considere as afirmativas a seguir.\n\nI. A busca em profundidade em um grafo não dirigido irá produzir arestas de árvore e de cruzamento.\\\nII. A busca em profundidade decompõe um grafo dirigido em suas componentes fortemente conexas.\\\nIII. Um grafo dirigido é acíclico quando uma busca em profundidade não produzir arestas de retorno.\\\nIV. Uma ordenação topológica de um grafo é uma ordenação linear de seus vértices. \n\nAssinale a alternativa correta.",
  "alternativas": [
    "a) Somente as afirmativas I e II são corretas.",
    "b) Somente as afirmativas I e IV são corretas.",
    "c) Somente as afirmativas III e IV são corretas.",
    "d) Somente as afirmativas I, II e III são corretas.",
    "e) Somente as afirmativas II, III e IV são corretas."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Teoria dos Grafos",
  "subarea": "Busca em Largura e Profundidade",
  "gabarito": "ANULADA",
  "atributo_rag": "fundamentos da computacao - teoria dos grafos - busca em largura e profundidade"
},

{
  "id": "2014-33",
  "edicao": 2014,
  "numero": 33,
  "enunciado": "Considere o algoritmo, apresentado na forma de uma pseudolinguagem (Português Estruturado), a seguir. As variáveis N e Y devem assumir valores positivos.\n```\nAlgoritmo\n    declare N, X, Y, i numérico;\n    leia N;\n    leia Y;\n    i ← 1;\n    X ← Y / 2;\n    repita\n        X ← (X^2 + Y) / (2 * X);\n        i ← i + 1;\n        se i > N então\n            interrompa;\n        fim se\n    fim repita\n    escreva “X =”, X;\nFim Algoritmo.\n```\n\nAssinale a alternativa que apresenta, corretamente, a relação existente entre os valores das variáveis X e Y.",
  "alternativas": [
    "a) $X = Y \\div N$",
    "b) $X = Y \\times N$",
    "c) $X = \\sqrt{Y}$",
    "d) $X = e^Y$",
    "e) $X = Y \\div 2$"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Análise de Algoritmos",
  "subarea": "Análise de Algoritmos Iterativos e Recursivos",
  "gabarito": "ANULADA",
  "atributo_rag": "fundamentos da computacao - analise de algoritmos - analise de algoritmos iterativos e recursivos"
},

{
  "id": "2014-34",
  "edicao": 2014,
  "numero": 34,
  "enunciado": "Sobre os metadados de um arquivo, assinale a alternativa correta.",
  "alternativas": [
    "a) A flag de arquivamento indica se um arquivo deve ser apagado pelo sistema.",
    "b) Atributos de momento são utilizados para indicar arquivos temporários.",
    "c) Flags são bits ou campos pequenos que controlam alguma característica específica.",
    "d) O atributo “tamanho do registro” indica o número de bytes no campo chave.",
    "e) Sistemas operacionais modernos implementam todos os atributos possíveis a um arquivo."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Organização de Arquivos e Dados",
  "subarea": "Dados e Metadados",
  "gabarito": "C",
  "atributo_rag": "fundamentos da computacao - organizacao de arquivos e dados - dados e metadados"
},

{
  "id": "2014-35",
  "edicao": 2014,
  "numero": 35,
  "enunciado": "Sobre operações com arquivos, assinale a alternativa correta.",
  "alternativas": [
    "a) *Append* é a versão mais ampla da chamada *Write*.",
    "b) *Close* força a escrita do último bloco de um arquivo.",
    "c) *Create* altera os atributos modificados de um arquivo.",
    "d) *Delete* apaga blocos de dados iniciando da posição atual do arquivo.",
    "e) *Seek* lê dados de qualquer posição do arquivo."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Técnicas de Programação",
  "subarea": "Comandos de uma Linguagem de programação",
  "gabarito": "B",
  "atributo_rag": "fundamentos da computacao - tecnicas de programacao - comandos de uma linguagem de programacao"
},

{
  "id": "2014-36",
  "edicao": 2014,
  "numero": 36,
  "enunciado": "Considerando que um grafo possui $n$ vértices e $m$ arestas, assinale a alternativa que apresenta, corretamente, um grafo planar.",
  "alternativas": [
    "a) $n = 5$, $m = 10$",
    "b) $n = 6$, $m = 15$",
    "c) $n = 7$, $m = 21$",
    "d) $n = 8$, $m = 12$",
    "e) $n = 9$, $m = 22$"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Teoria dos Grafos",
  "subarea": "Planaridade",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - teoria dos grafos - planaridade"
},

{
  "id": "2014-37",
  "edicao": 2014,
  "numero": 37,
  "enunciado": "Assinale a alternativa que apresenta, corretamente, o algoritmo utilizado para determinar o caminho mínimo entre todos os pares de vértices de um grafo.",
  "alternativas": [
    "a) Bellman-Ford.",
    "b) Floyd-Warshall.",
    "c) Dijkstra.",
    "d) Kruskal.",
    "e) Prim."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Teoria dos Grafos",
  "subarea": "Algoritmos do Menor Caminho",
  "gabarito": "B",
  "atributo_rag": "fundamentos da computacao - teoria dos grafos - algoritmos do menor caminho"
},

{
  "id": "2014-38",
  "edicao": 2014,
  "numero": 38,
  "enunciado": "Considere o trecho de algoritmo, apresentado na forma de uma pseudolinguagem (Português Estruturado), a seguir. Assuma que no comando “`leia A, B, C, D;`” os valores lidos são, respectivamente, 12, 25, 96 e 15 e a função `RESTO (x,y)` apresenta o resto da divisão de `x` por `y`.\n```\nleia A, B, C, D;\nresp ← 1;\ni ← 2;\nrepita\n    se (RESTO(A, i) = 0 ou RESTO(B, i) = 0 ou RESTO(C, i) = 0 ou RESTO(D, i) = 0) então\n        resp ← resp * i;\n        se (RESTO(A, i) = 0) então\n            A ← A / i;\n        fim se\n        se (RESTO(B, i) = 0) então\n            B ← B / i;\n        fim se\n        se (RESTO(C, i) = 0) então\n            C ← C / i;\n        fim se\n        se (RESTO(D, i) = 0) então\n            D ← D / i;\n        fim se\n    senão\n        i ← i + 1;\n    fim se\n\n    se (A = 1 e B = 1 e C = 1 e D = 1) então\n        interrompa;\n    fim se\n fim repita\n escreva “Resposta =”, resp;\nfim repita\n```\n\nAssinale a alternativa que apresenta, corretamente, o conteúdo da variável `resp`, impresso no comando “`escreva “Resposta =”, resp;`”.",
  "alternativas": [
    "a) 480",
    "b) 800",
    "c) 1200",
    "d) 2400",
    "e) 12000"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Algoritmos e Estrutura de Dados",
  "subarea": "Metodologia de Desenvolvimento de Algoritmos",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - algoritmos e estrutura de dados - metodologia de desenvolvimento de algoritmos"
},

{
  "id": "2014-39",
  "edicao": 2014,
  "numero": 39,
  "enunciado": "Observe a gramática a seguir.\n$$\n\\begin{align*}\n& S → aAbba \\\\\n& aAb → aabbbA \\mid ab \\\\\n& bAb → bbA \\\\\n& bAa → Bbaa \\\\\n& bB → Bb \\\\\n& aB → aA\n\\end{align*}\n$$\nSobre essa gramática, assinale a alternativa correta.",
  "alternativas": [
    "a) É irrestrita e aceita a linguagem $\\{a^nb^{2n+1}a^n \\mid n \\geq 1\\}$.",
    "b) É irrestrita e aceita a linguagem $\\{a^nb^{2n}a^n \\mid n \\geq 1\\}$.",
    "c) É sensível ao contexto e aceita a linguagem $\\{a^nb^{2n+1}a^n \\mid n \\geq 1\\}$.",
    "d) É sensível ao contexto e aceita a linguagem $\\{a^nb^{2n}a^n \\mid n \\geq 1\\}$.",
    "e) É livre de contexto e aceita a linguagem $\\{a^nb^{2n+1}a^n \\mid n \\geq 1\\}$."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens Formais, Autômatos e Computabilidade",
  "subarea": "Linguagens Regulares, Livres-de-Contexto e Sensíveis-ao-Contexto",
  "gabarito": "B",
  "atributo_rag": "fundamentos da computacao - linguagens formais, automatos e computabilidade - linguagens regulares, livres-de-contexto e sensiveis-ao-contexto"
},

{
  "id": "2014-40",
  "edicao": 2014,
  "numero": 40,
  "enunciado": "Sobre o lema do bombeamento (*pumping lemma*) para linguagens regulares, considere as afirmativas a seguir.\n\nI. Seja o alfabeto $\\sum = \\{a, b\\}$. Pode-se provar por absurdo, através do bombeamento, que a linguagem $ L_1 = \\{w \\in \\sum^* \\mid w \\text{ termina com } b\\} $ não é regular.\\\nII. Seja o alfabeto $\\sum = \\{a, b\\}$. Pode-se provar por absurdo, através do bombeamento, que a linguagem $ L_2 = \\{(a^n)^2 \\mid n \\geq 1\\} $ não é regular.\\\nIII. Seja o alfabeto $\\sum = \\{a, b\\}$. Pode-se provar por absurdo, através do bombeamento, que as linguagens $L_3 = \\{a^{n!} \\mid n \\geq 1\\}$, $L_4 = \\{a^n b^a m^b a^{n+m} \\mid n, m \\geq 1\\}$ e $L_5 = \\{a^{m+1} b^n a^{n+1} \\mid 2 \\leq n \\leq m \\leq 3n\\}$ não são regulares.\\\nIV. Se a linguagem for do tipo 3, pode-se aplicar o bombeamento.\n\nAssinale a alternativa correta.",
  "alternativas": [
    "a) Somente as afirmativas I e II são corretas.",
    "b) Somente as afirmativas I e IV são corretas.",
    "c) Somente as afirmativas III e IV são corretas.",
    "d) Somente as afirmativas I, II e III são corretas.",
    "e) Somente as afirmativas II, III e IV são corretas."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens Formais, Autômatos e Computabilidade",
  "subarea": "Linguagens Regulares, Livres-de-Contexto e Sensíveis-ao-Contexto",
  "gabarito": "E",
  "atributo_rag": "fundamentos da computacao - linguagens formais, automatos e computabilidade - linguagens regulares, livres-de-contexto e sensiveis-ao-contexto"
},

{
  "id": "2014-41",
  "edicao": 2014,
  "numero": 41,
  "enunciado": "Sobre as linguagens regulares, considere as afirmativas a seguir.\n\nI. As linguagens regulares podem ser expressas por máquinas de Moore e de Mealy.\\\nII. As linguagens regulares podem ser expressas por um autômato finito.\\\nIII. Se $A$ e $B$ são linguagens regulares, então $A \\cap B$ também é.\\\nIV. Seja $B = \\{ba, na\\}$. Pode-se dizer que $B^* = \\{ \\lambda, ba, na, ab, an, baba, bana, naba, anab, nana, aban, bababa, babana, banaba, banana, nababa, nabana, nanaba, nanana, abanba, babababa, \\dots \\}$. \n\nAssinale a alternativa correta.",
  "alternativas": [
    "a) Somente as afirmativas I e II são corretas.",
    "b) Somente as afirmativas I e IV são corretas.",
    "c) Somente as afirmativas III e IV são corretas.",
    "d) Somente as afirmativas I, II e III são corretas.",
    "e) Somente as afirmativas II, III e IV são corretas."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens Formais, Autômatos e Computabilidade",
  "subarea": "Linguagens Regulares, Livres-de-Contexto e Sensíveis-ao-Contexto",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - linguagens formais, automatos e computabilidade - linguagens regulares, livres-de-contexto e sensiveis-ao-contexto"
},

{
  "id": "2014-44",
  "edicao": 2014,
  "numero": 44,
  "enunciado": "Sobre os métodos de acesso das unidades de dados, considere as afirmativas a seguir.\n\nI. No acesso sequencial, a informação de endereçamento armazenada é usada para separar registros e auxiliar no processo de recuperação.\\\nII. No acesso direto, os blocos têm um endereçamento exclusivo, baseado no local físico.\\\nIII. No acesso aleatório, o tempo para acessar um determinado local é constante.\\\nIV. No acesso associativo, uma palavra é recuperada com base em uma parte do seu endereço. \n\nAssinale a alternativa correta.",
  "alternativas": [
    "a) Somente as afirmativas I e II são corretas.",
    "b) Somente as afirmativas I e IV são corretas.",
    "c) Somente as afirmativas III e IV são corretas.",
    "d) Somente as afirmativas I, II e III são corretas.",
    "e) Somente as afirmativas II, III e IV são corretas."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Organização de Arquivos e Dados",
  "subarea": "Organização, Estrutura e Operação de Arquivos",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - organizacao de arquivos e dados - organizacao, estrutura e operacao de arquivos"
},

{
  "id": "2014-45",
  "edicao": 2014,
  "numero": 45,
  "enunciado": "Considere uma memória paginada, com espaço de endereçamento lógico de 8 páginas, cada uma com 4096 endereços. Nesse caso, a memória física possui 64 quadros.\n\nCom relação ao tamanho dos endereços lógicos e físicos, assinale a alternativa correta.",
  "alternativas": [
    "a) Endereço Lógico possui 15 bits e Endereço Físico possui 18 bits.",
    "b) Endereço Lógico possui 15 bits e Endereço Físico possui 12 bits.",
    "c) Endereço Lógico possui 13 bits e Endereço Físico possui 18 bits.",
    "d) Endereço Lógico possui 12 bits e Endereço Físico possui 18 bits.",
    "e) Endereço Lógico possui 12 bits e Endereço Físico possui 12 bits."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Arquitetura e Organização de Computadores",
  "subarea": "Organização de Memória",
  "gabarito": "A",
  "atributo_rag": "fundamentos da computacao - arquitetura e organizacao de computadores - organizacao de memoria"
},

{
  "id": "2014-48",
  "edicao": 2014,
  "numero": 48,
  "enunciado": "Em relação aos conjuntos de instruções, atribua V (verdadeiro) ou F (falso) às afirmativas a seguir.\n\n( ) O código de operação especifica a operação a ser realizada.\\\n( ) Referências de operandos especificam um registrador ou memória.\\\n( ) O estilo *little-endian* armazena o *byte* mais significativo no endereço mais baixo.\\\n( ) Pilhas podem ou não ser visíveis ao programador.\\\n( ) Pilhas crescem de endereços menores para endereços maiores. \n\nAssinale a alternativa que contém, de cima para baixo, a sequência correta.",
  "alternativas": [
    "a) V, V, F, V, F.",
    "b) V, F, V, F, F.",
    "c) F, V, V, V, F.",
    "d) F, V, F, F, V.",
    "e) F, F, V, V, V."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Arquitetura e Organização de Computadores",
  "subarea": "Modos de Endereçamento, Conjunto de Instruções",
  "gabarito": "A",
  "atributo_rag": "fundamentos da computacao - arquitetura e organizacao de computadores - modos de enderecamento, conjunto de instrucoes"
},

{
  "id": "2014-49",
  "edicao": 2014,
  "numero": 49,
  "enunciado": "Sobre *pipelines*, assinale a alternativa correta.",
  "alternativas": [
    "a) Cada estágio do *pipeline* possui seu próprio tempo de duração.",
    "b) Um *pipeline* precisa de registradores para armazenar dados entre estágios.",
    "c) Dependências de dados irão paralisar o *pipeline*.",
    "d) O *pipeline* é paralisado ao executar uma instrução de desvio.",
    "e) O tempo de leitura de uma instrução é maior que o tempo de execução."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Arquitetura e Organização de Computadores",
  "subarea": "Pipeline",
  "gabarito": "B",
  "atributo_rag": "fundamentos da computacao - arquitetura e organizacao de computadores - pipeline"
},

{
  "id": "2014-50",
  "edicao": 2014,
  "numero": 50,
  "enunciado": "Em relação ao gerenciamento de processos, atribua V (verdadeiro) ou F (falso) às afirmativas a seguir.\n\n( ) Na espera ocupada, o processo é transferido para estado de bloqueado até que sua fatia de tempo termine e então ele retorna para fila de prontos.\\\n( ) O bloco de controle de processos (BCP – *Process Control Block*) é utilizado para armazenar informações sobre processos, e essas informações são utilizadas na troca de contexto de processos.\\\n( ) *Threads* apresentam menor custo de criação quando comparadas aos processos, pois compartilham alguns elementos do processo, como espaço de endereçamento.\\\n( ) Um processo pode estar nos seguintes estados: pronto, aguardando execução, em execução e bloqueado.\\\n( ) Um processo pode ser criado por uma chamada de sistema *fork ()*, nesse caso, o processo gerado (conhecido como “filho”) é uma cópia exata do processo original, com os mesmos valores de variáveis em memória, diferenciando-se apenas no identificador do processo. \n\nAssinale a alternativa que contém, de cima para baixo, a sequência correta.",
  "alternativas": [
    "a) V, V, F, V, F.",
    "b) V, F, V, F, F.",
    "c) V, F, F, F, V.",
    "d) F, V, V, F, V.",
    "e) F, F, F, V, V."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Sistemas Operacionais",
  "subarea": "Gerência de Processos/Processador",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - sistemas operacionais - gerencia de processos/processador"
},

{
  "id": "2015-21",
  "edicao": 2015,
  "numero": 21,
  "enunciado": "Muitas das recorrências que acontecem na análise de algoritmos de divisão e conquista têm a forma \n$$\nF(n) = a \\cdot F\\left(\\frac{n}{b}\\right) + c \\cdot n^k\n$$\npara $ F(n) $ assintoticamente não decrescente, $ a, b, k \\in \\mathbb{N} $, $ a \\geq 1, b \\geq 2, k \\geq 0 $, e $ c \\in \\mathbb{R}^{+} $.\n\nNessas condições, de acordo com o Teorema Mestre:\n- Se $ \\frac{\\log a}{\\log b} > k $, então $ F(n) \\in \\Theta(n^{\\log_b a}) $\n- Se $ \\frac{\\log a}{\\log b} = k $, então $ F(n) \\in \\Theta(n^k \\log n) $\n- Se $ \\frac{\\log a}{\\log b} < k $, então $ F(n) \\in \\Theta(n^k) $\n\nConsidere os algoritmos $A$, $B$ e $C$, que são descritos, respectivamente, pelas equações de recorrência:\n$$\nF_A(n) = 8F\\left(\\frac{n}{4}\\right) + n \\\\\nF_B(n) = 4F\\left(\\frac{n}{2}\\right) + n^2 \\\\\nF_C(n) = 2F\\left(\\frac{n}{4}\\right) + n^3\n$$\nDado que $ \\log_2 2 = 1 $, $ \\log_2 4 = 2 $, $ \\log_2 8 = 3 $, como pode-se comparar a ordem de complexidade $ \\Theta $ dos algoritmos $A$, $B$ e $C$?",
  "alternativas": [
    "a) $\\Theta ( {F_A} )> \\Theta ( {F_B} )> \\Theta ( {F_C} )$",
    "b) $\\Theta ( {F_A} )< \\Theta ( {F_B} )< \\Theta ( {F_C} )$",
    "c) $\\Theta ( {F_A} )> \\Theta ( {F_B} )< \\Theta ( {F_C} )$",
    "d) $\\Theta ( {F_A} )< \\Theta ( {F_B} )> \\Theta ( {F_C} )$",
    "e) $\\Theta ( {F_A} ) =\\Theta ( {F_B} )=\\Theta ( {F_C} )$"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Análise de Algoritmos",
  "subarea": "O Uso de Relações de Recorrência para Análise de Algoritmos Recursivos",
  "gabarito": "B",
  "atributo_rag": "fundamentos da computacao - analise de algoritmos - o uso de relacoes de recorrencia para analise de algoritmos recursivos"
},

{
  "id": "2015-22",
  "edicao": 2015,
  "numero": 22,
  "enunciado": "Quais destes algoritmos de ordenação têm a classe de complexidade assintótica, no pior caso, em $O (n \\cdot \\log n )$ ?",
  "alternativas": [
    "a) QuickSort, MergeSort, e HeapSort",
    "b) QuickSort e SelectionSort",
    "c) MergeSort e HeapSort",
    "d) QuickSort e BubbleSort",
    "e) QuickSort, MergeSort e SelectionSort"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Análise de Algoritmos",
  "subarea": "Medidas de Complexidade, Análise Assintótica de Limites de Complexidade, Técnicas de Prova de Cotas Inferiores",
  "gabarito": "C",
  "atributo_rag": "fundamentos da computacao - analise de algoritmos - medidas de complexidade, analise assintotica de limites de complexidade, tecnicas de prova de cotas inferiores"
},

{
  "id": "2015-23",
  "edicao": 2015,
  "numero": 23,
  "enunciado": "São exemplos de aplicações práticas de listas que seguem o princípio LIFO:",
  "alternativas": [
    "a) a verificação de agrupamentos de tags HTML de abertura e fechamento, implementada em navegadores web; o gerenciamento de trabalhos de impressão realizado pelo processo spooler de impressão.",
    "b) a alocação de uma fatia de tempo de CPU para múltiplas aplicações concorrentes, realizada por um escalonador round-robin;\no gerenciamento de pacotes em redes de computadores, implementado em roteadores.",
    "c) o registro ordenado dos maiores escores obtidos em um jogo de videogame; a verificação da abertura e do fechamento de parênteses em expressões aritméticas.",
    "d) o gerenciamento de endereços visitados mais recentemente, encontrado em navegadores web; o mecanismo de reversão de operações mais recentes, implementado em editores de texto.",
    "e) o cálculo de espaço em disco consumido por um diretório (e seus componentes) em um sistema de arquivos; a procura por padrões em cadeias de caracteres por meio da técnica de força bruta."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Algoritmos e Estrutura de Dados",
  "subarea": "Estruturas de Dados Lineares e suas Generalizações: Listas Ordenadas, Listas Encadeadas, Pilhas e Filas",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - algoritmos e estrutura de dados - estruturas de dados lineares e suas generalizacoes: listas ordenadas, listas encadeadas, pilhas e filas"
},

{
  "id": "2015-24",
  "edicao": 2015,
  "numero": 24,
  "enunciado": "Considere T uma árvore binária cheia, em que $n, n_e , n_i$ e $h$ representam o número de nós, o número de nós externos, o número de nós internos e a altura de T, respectivamente. Portanto, a essa árvore T aplica-se a seguinte propriedade:",
  "alternativas": [
    "a) $n_i = n_e + 1$",
    "b) $h - 1 \\leq n_e \\leq 2^h$",
    "c) $h + 1 \\leq n_i \\leq 2^h$",
    "d) $\\log(n+1) \\leq h \\leq n - 1$",
    "e) $2h + 1 \\leq n \\leq 2^{h+1} - 1$"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Algoritmos e Estrutura de Dados",
  "subarea": "Árvores e suas Generalizações: Árvores Binárias, Árvores de Busca e Árvores Balanceadas",
  "gabarito": "E",
  "atributo_rag": "fundamentos da computacao - algoritmos e estrutura de dados - arvores e suas generalizacoes: arvores binarias, arvores de busca e arvores balanceadas"
},

{
  "id": "2015-25",
  "edicao": 2015,
  "numero": 25,
  "enunciado": "Sejam $T1 (n)=100 \\cdot n+ 15$, $T2  (n)= 10 \\cdot n^2+ 2 \\cdot n$ e $T3 ( n )=0,5 \\cdot n^3+ n^2 + 3$ as equações que descrevem a complexidade de tempo dos algoritmos Alg1, Alg2 e Alg3, respectivamente, para entradas de tamanho n. A respeito da ordem de complexidade desses algoritmos, pode-se concluir que",
  "alternativas": [
    "a) as complexidades assintóticas de Alg1, Alg2 e Alg3 estão, respectivamente, em $O(n)$, $O(n^2)$ e $O(n^3)$.",
    "b) as complexidades assintóticas de Alg1, Alg2 e Alg3 estão, respectivamente, em $O(n)$, $O(n^2)$ e $O(n^2)$.",
    "c) as complexidades assintóticas de Alg1, Alg2 e Alg3 estão, respectivamente, em $O(100)$, $O(10)$ e $O(0,5)$.",
    "d) Alg2 e Alg3 pertencem às mesmas classes de complexidade assintótica.",
    "e) Alg1 e Alg2 pertencem às mesmas classes de complexidade assintótica."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Análise de Algoritmos",
  "subarea": "Notação “Big O”, “Little o”, “Omega” e “Theta”",
  "gabarito": "A",
  "atributo_rag": "fundamentos da computacao - analise de algoritmos - notacao “big o”, “little o”, “omega” e “theta”"
},

{
  "id": "2015-26",
  "edicao": 2015,
  "numero": 26,
  "enunciado": "Analise o seguinte programa descrito na forma de pseudocódigo:\n\n```\n1. algoritmo\n2. declare X[10], n, i, aux, flag numérico\n3. para i ← 1 até 10 faça\n4. leia X[i]\n5. n ← 1\n6. flag ← 1\n7. enquanto (n \\leq 10 E flag = 1) faça\n8. inicio\n9. flag ← 0\n10. para i ← 1 até 9 faça\n11. inicio\n12. se (X[i] < X[i+1]) então\n13. inicio\n14. flag ← 1\n15. aux ← X[i]\n16. X[i] ← X[i+1]\n17. X[i+1] ← aux\n18. fim_se\n19. fim_para\n20. n ← n + 1\n21. fim_enquanto\n22. para i ← 1 até 10 faça\n23. escreva X[i]\n24. fim_algoritmo\n```\nEsse programa realiza a ordenação decrescente de um vetor de números inteiros, que implementa o algoritmo de",
  "alternativas": [
    "a) ordenação rápida.",
    "b) ordenação por troca.",
    "c) ordenação por seleção.",
    "d) ordenação por inserção.",
    "e) ordenação por intercalação."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Algoritmos e Estrutura de Dados",
  "subarea": "Algoritmos para Pesquisa e Ordenação",
  "gabarito": "B",
  "atributo_rag": "fundamentos da computacao - algoritmos e estrutura de dados - algoritmos para pesquisa e ordenacao"
},

{
  "id": "2015-27",
  "edicao": 2015,
  "numero": 27,
  "enunciado": "A linguagem de programação LISP usa o paradigma de:",
  "alternativas": [
    "a) programação procedural.",
    "b) programação de tipos abstratos de dados.",
    "c) programação orientada a objetos.",
    "d) programação funcional.",
    "e) programação declarativa."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens de Programação",
  "subarea": "Paradigmas de Linguagens de Programação",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - linguagens de programacao - paradigmas de linguagens de programacao"
},

{
  "id": "2015-28",
  "edicao": 2015,
  "numero": 28,
  "enunciado": "Considere o seguinte código desenvolvido em Java.\n```\npublic class Animal {\n    int numeroPatas;\n    public void fale (){};\n}\npublic class Cao extends Animal {\n    public void fale() {\n       System.out.println (\"au au\");\n    }\n}\n\npublic class Gato extends Animal {\n    public void fale() {\n        System.out.println (\"miau\");\n    }\n}\n\npublic class GatoPersa extends Gato {\n    public void fale() {\n        System.out.println (\"miauuuu\");\n    }\n}\n\npublic class Tigre extends Gato {\n    public void fale() {\n        super.fale();\n        System.out.println (\"rrrrrr\");\n    }\n}\n\npublic class Principal {\n    public static void main(String[] args) {\n        Gato gato = new GatoPersa();\n        gato.fale();\n        Cao cao = new Cao();\n        cao.fale();\n        Tigre tigre = new Tigre();\n        tigre.fale();\n    }\n}\n```\nAo executar o código, a saída impressa no console é:",
  "alternativas": [
    "a) miauuuu au au miau rrrrrr",
    "b) miauuuuu au au rrrrrr",
    "c) miau au au miau miau",
    "d) miau au au rrrrrr",
    "e) miau au au miau rrrrrr"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens de Programação",
  "subarea": "Teoria dos Tipos: Sistemas de Tipos, Polimorfismo",
  "gabarito": "A",
  "atributo_rag": "fundamentos da computacao - linguagens de programacao - teoria dos tipos: sistemas de tipos, polimorfismo"
},

{
  "id": "2015-29",
  "edicao": 2015,
  "numero": 29,
  "enunciado": "O formato FITS (Flexible Image Transport System) armazena imagens de astronomia. Um cabeçalho FITS é uma coleção de 2.880 bytes contendo registros de 80 bytes ASCII, no qual cada registro contém um metadado. O FITS utiliza o formato ASCII para o cabeçalho e o formato binário para os dados primários. Nesse caso, a inclusão de metadados junto aos dados",
  "alternativas": [
    "a) desfavorece a portabilidade, pois dificulta a conversão entre padrões.",
    "b) favorece a portabilidade, embora dificulte a conversão entre padrões.",
    "c) favorece o acesso ao arquivo por terceiros, por possuir conteúdo autoexplicativo.",
    "d) desfavorece o acesso ao arquivo por terceiros.",
    "e) é adequada ao emprego de etiquetas e palavras-chave."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Organização de Arquivos e Dados",
  "subarea": "Dados e Metadados",
  "gabarito": "C",
  "atributo_rag": "fundamentos da computacao - organizacao de arquivos e dados - dados e metadados"
},

{
  "id": "2015-30",
  "edicao": 2015,
  "numero": 30,
  "enunciado": "Considere o seguinte código em linguagem C.\n```\nint y = 12, z = -4, w = 0, x;\nfor (x = 0; x<9; x=x+3)\n{\n    while (w<3){\n       y = z + w++;\n    }\n    if (x % 2 == 0)\n      y = z + x;\n    else\n      y++;\n    z++;\n    printf (\"x:%d y:%d z:%d \\n\", x, y, z);\n}\n```\nAo executar o código, qual é a saída impressa na tela?",
  "alternativas": [
    "a) x:0 y:-3 z:3\nx:3 y:-4 z:2\nx:4 y:4 z:1",
    "b) x:0 y:-4 z:-3\nx:3 y:-2 z:-2\nx:5 y:4 z:1",
    "c) x:0 y:-4 z:-2\nx:3 y:-2 z:-2\nx:5 y:2 z:-1",
    "d) x:0 y:-4 z:-3\nx:3 y:-3 z:-1\nx:6 y:4 z:0",
    "e) x:0 y:-4 z:-3\nx:3 y:-3 z:-2\nx:6 y:4 z:-1"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens de Programação",
  "subarea": "Paradigmas de Linguagens de Programação",
  "gabarito": "E",
  "atributo_rag": "fundamentos da computacao - linguagens de programacao - paradigmas de linguagens de programacao"
},

{
  "id": "2015-31",
  "edicao": 2015,
  "numero": 31,
  "enunciado": "Considere o código em linguagem C a seguir.\n```\nvoid funcao (float n) { }\nmain() {\nlong numero;\nfuncao (numero);\n}\n```\nNo referido código, a conversão implícita de tipos é um polimorfismo chamado",
  "alternativas": [
    "a) coerção.",
    "b) sobrecarga.",
    "c) paramétrico.",
    "d) abstração.",
    "e) público."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens de Programação",
  "subarea": "Teoria dos Tipos: Sistemas de Tipos, Polimorfismo",
  "gabarito": "A",
  "atributo_rag": "fundamentos da computacao - linguagens de programacao - teoria dos tipos: sistemas de tipos, polimorfismo"
},

{
  "id": "2015-33",
  "edicao": 2015,
  "numero": 33,
  "enunciado": "O conceito de encapsulamento de programação orientada a objetos pode ser implementado na linguagem Java por meio de",
  "alternativas": [
    "a) métodos estáticos (static) e públicos (public).",
    "b) métodos públicos (public), privados (private) e protegidos (protected).",
    "c) classes abstratas (abstract) e métodos protegidos (protect).",
    "d) interfaces (interface), métodos públicos (public) e métodos protegidos (protect).",
    "e) herança (extends) e métodos estáticos (static)."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens de Programação",
  "subarea": "Paradigmas de Linguagens de Programação",
  "gabarito": "B",
  "atributo_rag": "fundamentos da computacao - linguagens de programacao - paradigmas de linguagens de programacao"
},

{
  "id": "2015-34",
  "edicao": 2015,
  "numero": 34,
  "enunciado": "Índices são estruturas de acesso auxiliares usadas para aumentar a velocidade de recuperação de registros de resposta a certas condições de busca. Nesse sentido, um índice",
  "alternativas": [
    "a) esparso possui uma entrada de índice para cada valor da chave de busca (portanto, para cada registro) do arquivo de dados.\nUm índice denso possui entradas de índice para apenas alguns dos valores da chave de busca.",
    "b) secundário sobre um campo não chave de um arquivo de dados implica que vários registros podem ter o mesmo valor para o campo de indexação. Esse índice pode ser denso, com várias entradas no índice com o mesmo valor, uma para cada registro.",
    "c) secundário sobre um campo não chave de um arquivo de dados implica que vários registros podem ter o mesmo valor para o campo de indexação. Esse índice pode ser esparso, com várias entradas no índice com o mesmo valor, uma para cada registro.",
    "d) secundário serve para ordenar fisicamente os registros no disco; um arquivo de dados pode ter diversos índices primários e, no máximo, um índice secundário. O índice primário pode ser especificado sobre qualquer campo de um arquivo.",
    "e) esparso deve inserir ou eliminar registros no arquivo de dados, resultando na mesma ação sobre o seu índice, à medida que um par chave-ponteiro para esse registro é inserido ou eliminado."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Organização de Arquivos e Dados",
  "subarea": "Organização, Estrutura e Operação de Arquivos",
  "gabarito": "B",
  "atributo_rag": "fundamentos da computacao - organizacao de arquivos e dados - organizacao, estrutura e operacao de arquivos"
},

{
  "id": "2015-35",
  "edicao": 2015,
  "numero": 35,
  "enunciado": "Em organização de arquivos e dados, um diretório é um arquivo mantido pelo sistema de arquivos, que contém uma lista de outros arquivos e, possivelmente, de outros diretórios. Em sistemas de diretório que suportam",
  "alternativas": [
    "(A) diretório único (ou de nível simples), além da raiz do diretório só é possível existir um nível de subdiretórios.",
    "(B) diretório de dois níveis, além da raiz do diretório o sistema prevê um nível onde cada usuário possui o seu diretório e, neste diretório, não existe limite para o número de níveis de subdiretórios.",
    "(C) diretório de dois níveis, além da raiz do diretório o sistema prevê um nível onde cada usuário possui o seu diretório e, neste diretório, o limite para o número de níveis de subdiretórios é dois.",
    "(D) diretórios hierárquicos, não existe limite para o número de níveis de subdiretórios e um arquivo pode ser referenciado por um caminho absoluto ou por um caminho relativo ao diretório corrente (ou diretório do processo).",
    "(E) diretórios hierárquicos, como Windows e UNIX, há três entradas especiais em cada diretório: ‘.’ (ponto), ‘..’ (ponto-ponto) e ‘~’ (til): a primeira volta um nível na hierarquia; a segunda avança um nível; a terceira referencia o diretório reservado ao administrador, quando utilizada em caminhos relativos."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Organização de Arquivos e Dados",
  "subarea": "Organização, Estrutura e Operação de Arquivos",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - organizacao de arquivos e dados - organizacao, estrutura e operacao de arquivos"
},

{
  "id": "2015-37",
  "edicao": 2015,
  "numero": 37,
  "enunciado": "Centenas de problemas computacionais são expressos em termos de grafos, e os algoritmos para resolvê-los são fundamentais para a computação. O algoritmo de busca em",
  "alternativas": [
    "a) largura utiliza pilha, enquanto o de busca em profundidade utiliza fila.",
    "b) largura é o responsável pela definição do vértice inicial.",
    "c) profundidade é utilizado para obter uma ordenação topológica em um dígrafo acíclico.",
    "d) largura explora as arestas a partir do vértice mais recentemente visitado.",
    "e) profundidade expande a fronteira entre vértices conhecidos e desconhecidos uniformemente."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Teoria dos Grafos",
  "subarea": "Busca em Largura e Profundidade",
  "gabarito": "C",
  "atributo_rag": "fundamentos da computacao - teoria dos grafos - busca em largura e profundidade"
},

{
  "id": "2015-39",
  "edicao": 2015,
  "numero": 39,
  "enunciado": "A gramática G = ({S, A, B}, {0, 1}, P, S), onde P é dado pelas regras de produção\n```\nS → 0AB | 1BA\nA → 0AS | 1A | \\epsilon\nB → 0B | 1BS | \\epsilon\n```\ngera uma linguagem que",
  "alternativas": [
    "a) pertence à classe Regular.",
    "b) contém a cadeia vazia $\\epsilon$.",
    "c) pode ser aceita por um autômato com pilha.",
    "d) pode ser denotada por uma expressão regular.",
    "e) é igual ao conjunto de cadeias { x \\in {0, 1}* | x tem quantidade igual de zero (0) e de um (1) }"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens Formais, Autômatos e Computabilidade",
  "subarea": "Linguagens Regulares, Livres-de-Contexto e Sensíveis-ao-Contexto",
  "gabarito": "C",
  "atributo_rag": "fundamentos da computacao - linguagens formais, automatos e computabilidade - linguagens regulares, livres-de-contexto e sensiveis-ao-contexto"
},

{
  "id": "2015-40",
  "edicao": 2015,
  "numero": 40,
  "enunciado": "Considerando as linguagens L = { $0^n1^n2^i$ | n \\geq 0 e i \\geq 0 }$ e M = { $0^i1^n2^n$ | n \\geq 0 e i \\geq 0 }, pode-se afirmar que",
  "alternativas": [
    "a) a linguagem L \\cup M pode ser gerada por uma gramática livre de contexto.",
    "b) a linguagem M pode ser gerada por uma gramática regular.",
    "c) a linguagem L pode ser aceita por um autômato finito determinístico.",
    "d) a linguagem L \\cap M pertence à classe das linguagens livres de contexto.",
    "e) a linguagem M pode ser denotada por uma expressão regular."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens Formais, Autômatos e Computabilidade",
  "subarea": "Linguagens Regulares, Livres-de-Contexto e Sensíveis-ao-Contexto",
  "gabarito": "A",
  "atributo_rag": "fundamentos da computacao - linguagens formais, automatos e computabilidade - linguagens regulares, livres-de-contexto e sensiveis-ao-contexto"
},

{
  "id": "2015-41",
  "edicao": 2015,
  "numero": 41,
  "enunciado": "Considere uma linguagem $ L $ e as classes de problemas $ \\text{IP} $, $ \\text{NP} $ e $ \\text{coNP} $, esta última definida como $\\text{coNP} = \\{ L \\in \\text{NP} \\mid \\overline{L} \\in \\text{NP} \\}$. A sequência de implicações lógicas a seguir corresponde a uma tentativa de prova do teorema \n\"se $ L \\in \\text{IP} $ então $ L \\in \\text{coNP} $\":\n$$\n\\begin{align*}\n& L \\in \\text{IP} \\underset{\\text{I}}{\\Rightarrow} \\overline{L} \\in \\text{IP} \\underset{\\text{II}}{\\Rightarrow} \\overline{L} \\in \\text{INP} \\\\\n& L \\in \\text{IP} \\underset{\\text{III}}{\\Rightarrow} L \\in \\text{INP} \\\\\n& L \\in \\text{INP} \\text{ e } \\overline{L} \\in \\text{INP} \\underset{\\text{IV}}{\\Rightarrow} L \\in \\text{coNP}\n\\end{align*}\n$$",
  "alternativas": [
    "a) a prova não está correta, porque a implicação lógica I é falsa.",
    "b) a prova não está correta, porque a implicação lógica IV é falsa.",
    "c) a prova é correta, porém a implicação lógica III é falsa.",
    "d) a prova é correta, porém a implicação lógica II é falsa.",
    "e) a prova está correta, pois as implicações lógicas são verdadeiras."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens Formais, Autômatos e Computabilidade",
  "subarea": "Classes de Problemas P, NP, NP Completo e NP-Difícil",
  "gabarito": "E",
  "atributo_rag": "fundamentos da computacao - linguagens formais, automatos e computabilidade - classes de problemas p, np, np completo e np-dificil"
},

{
  "id": "2015-43",
  "edicao": 2015,
  "numero": 43,
  "enunciado": "Considere a seguinte função $F(A,B,C) = A*B*C+A*B’*(A’*C’)’$ onde o símbolo ’ representa o complemento. Como soma de produtos, essa função pode ser simplificada da seguinte forma:",
  "alternativas": [
    "a) $A*B*C+A*B’+A*B’*C$",
    "b) $A*B*C$",
    "c) $A*B*C+A*B’*C’+A*B’*C$",
    "d) $(A’+C’)*(A’+B)$",
    "e) $A*C+A*B’$"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Circuitos Digitais",
  "subarea": "Minimização e Otimização de Funções Combinatórias",
  "gabarito": "E",
  "atributo_rag": "fundamentos da computacao - circuitos digitais - minimizacao e otimizacao de funcoes combinatorias"
},

{
  "id": "2015-44",
  "edicao": 2015,
  "numero": 44,
  "enunciado": "Em um computador, o endereço virtual é de 16 bits e as páginas têm tamanho de 2Kb de endereços. O WSL (Working Set List) de um processo qualquer é de quatro páginas, sendo que, inicialmente, nenhuma página está na memória principal. Um programa faz referência a endereços virtuais situados nas páginas 0, 7, 2, 5, 8, 9, 2 e 4. Quantos bits do endereçamento virtual destinam-se, respectivamente, ao número da página e ao deslocamento?",
  "alternativas": [
    "a) 5 bits e 11 bits.",
    "b) 6 bits e 10 bits.",
    "c) 7 bits e 9 bits.",
    "d) 8 bits e 8 bits.",
    "e) 9 bits e 7 bits."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Arquitetura e Organização de Computadores",
  "subarea": "Organização de Memória",
  "gabarito": "A",
  "atributo_rag": "fundamentos da computacao - arquitetura e organizacao de computadores - organizacao de memoria"
},

{
  "id": "2015-45",
  "edicao": 2015,
  "numero": 45,
  "enunciado": "Em um sistema operacional multitarefa, três processos compartilham dois recursos. Cada um destes processos possui, no mínimo,",
  "alternativas": [
    "(A) seis seções críticas.",
    "(B) quatro seções críticas.",
    "(C) três seções críticas.",
    "(D) duas seções críticas.",
    "(E) uma seção crítica."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Sistemas Operacionais",
  "subarea": "Comunicação, Concorrência e Sincronização de Processos",
  "gabarito": "E",
  "atributo_rag": "fundamentos da computacao - sistemas operacionais - comunicacao, concorrencia e sincronizacao de processos"
},

{
  "id": "2015-46",
  "edicao": 2015,
  "numero": 46,
  "enunciado": "Considere um cenário de um sistema operacional que implementa um sistema de arquivos com método de alocação de espaço em disco baseado na alocação encadeada, a exemplo do popular sistema de arquivos FAT ( file allocation table). Em um disco rígido com tamanho de setor igual a 512 bytes, criou-se uma partição e a formatou com esse sistema de arquivos usando 2048 bytes para o tamanho de blocos (clusters). Durante a escrita de dados em diferentes arquivos nessa partição, foi criado o arquivo ARQ.DAT que, após ter todos os seus dados armazenados, totalizou 1024 bytes de tamanho. Nesse cenário, o arquivo ARQ.DAT",
  "alternativas": [
    "a) pode ter seu conteúdo fragmentado no disco, pois já existiam outros arquivos no disco durante a sua criação e gravação, e o sistema de arquivos em uso permite a fragmentação.",
    "b) pode ter seu conteúdo fragmentado no disco, pois seus dados foram armazenados concomitantemente com o armazenamento de dados de outros arquivos, e o sistema de arquivos em uso permite a fragmentação.",
    "c) pode ter seu conteúdo fragmentado no disco, pois seus dados ocupam, no mínimo, dois setores e o sistema de arquivos em uso permite a fragmentação.",
    "d) possui tamanho que não permite que seu conteúdo esteja fragmentado no disco.",
    "e) não possui seu conteúdo fragmentado no disco, pois o sistema de arquivos em uso não permite a fragmentação."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Sistemas Operacionais",
  "subarea": "Gerenciamento de Arquivos",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - sistemas operacionais - gerenciamento de arquivos"
},

{
  "id": "2015-47",
  "edicao": 2015,
  "numero": 47,
  "enunciado": "Considere a função F(A,B,C,D), composta dos termos mínimos (minterm)={1,3,5,7,9} e dos termos não essenciais (don’t care) {6, 12, 13}. Essa função, como produto de somas, pode ser simplificada da seguinte forma:",
  "alternativas": [
    "a) $D’+A*C$",
    "b) $D*(A’+C’)$",
    "c) $(D*A’)+(D*C’)$",
    "d) $D*A’+A*B’*C’*D$",
    "e) $(A’+C’)*(A’+B+C+D)*(A+C+D)*(A+B+C’+D)$"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Circuitos Digitais",
  "subarea": "Minimização e Otimização de Funções Combinatórias",
  "gabarito": "B",
  "atributo_rag": "fundamentos da computacao - circuitos digitais - minimizacao e otimizacao de funcoes combinatorias"
},

{
  "id": "2015-48",
  "edicao": 2015,
  "numero": 48,
  "enunciado": "Computador com um Conjunto Reduzido de Instruções (RISC) é uma linha de arquitetura de processadores que favorece um conjunto simples e pequeno de instruções que levam aproximadamente a mesma quantidade de tempo para ser executadas. São consideradas características típicas da organização RISC:",
  "alternativas": [
    "a) oferecer suporte para linguagens de alto nível e facilitar o desenvolvimento de compiladores.",
    "b) prover o computador com um conjunto complexo de instruções e melhorar a execução de programas.",
    "c) manter poucos registradores e ter registradores especializados.",
    "d) otimizar o *pipeline* de instrução e apresentar um conjunto limitado de instruções com formato fixo.",
    "e) dispor grande conjunto de instruções e apresentar vários modos de endereçamento."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Arquitetura e Organização de Computadores",
  "subarea": "Arquiteturas RISC e CISC",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - arquitetura e organizacao de computadores - arquiteturas risc e cisc"
},

{
  "id": "2015-49",
  "edicao": 2015,
  "numero": 49,
  "enunciado": "Analise o trecho de código em linguagem C a seguir.\n```\nA[12] = h + a[8]\n```\nEm linguagem MIPS, qual é o código de montagem correspondente?",
  "alternativas": [
    "a) lw $t1, 12($s3)\nadd $to, $s2, $t0\nSw $to, 24 ($s3)",
    "b) lw $t0, 32($s3)\nadd $to, $s2, $t0\nSw $to, 48 ($s3)",
    "c) lw $t0, 6($s3)\nadd $to, $s2, $t0\nSw $t1, 12 ($s3)",
    "d) lw $t1, 32($s3)\nadd $to, $s2, $t0\nSw $t1, 48 ($s1)",
    "e) lw $t0, 12($s3)\nadd $to, $s2, $t0\nSw $t1, 36 ($s2)"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Técnicas de Programação",
  "subarea": "Comandos de uma Linguagem de programação",
  "gabarito": "B",
  "atributo_rag": "fundamentos da computacao - tecnicas de programacao - comandos de uma linguagem de programacao"
},

{
  "id": "2015-50",
  "edicao": 2015,
  "numero": 50,
  "enunciado": "Um sistema operacional utiliza o algoritmo Buddy system em seu alocador de memória no espaço do usuário. Este alocador se inicia com um bloco de memória livre de 1024 bytes e utiliza um mapa de bits para controlar a quantidade e a posição da memória alocada. Cada bit no mapa representa uma unidade de alocação de 64 bytes. Neste cenário, considere que um processo, logo após ser criado, execute a seguinte sequência de operações:\n```\nptr1=malloc(64);\nptr2=malloc(192);\nptr4=malloc(64);\nfree(ptr2);\nfree(ptr4);\nptr2=malloc(193);\n```\nApós a execução com sucesso da sequência de operações listadas, a configuração do mapa de bits é:",
  "alternativas": [
    "a) 1111100000000000",
    "b) 1000111100000000",
    "c) 1000011100000000",
    "d) 0000111100000000",
    "e) 0000000011100001"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Sistemas Operacionais",
  "subarea": "Gerenciamento de Memória: Memória Virtual, Paginação, Segmentação e “Swap”",
  "gabarito": "B",
  "atributo_rag": "fundamentos da computacao - sistemas operacionais - gerenciamento de memoria: memoria virtual, paginacao, segmentacao e “swap”"
},

{
  "id": "2016-21",
  "edicao": 2016,
  "numero": 21,
  "enunciado": "Um algoritmo tem complexidade $O(3m^3 + 2mn^2 + n^2 + 10^m + m^2)$. Uma maneira simplificada de representar a complexidade desse algoritmo é:",
  "alternativas": [
    "a) $O(m^3 + mn^2).$",
    "b) $O(m^3).$",
    "c) $O(m^2).$",
    "d) $O(mn^2).$",
    "e) $O(m^3+ n^2).$"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Análise de Algoritmos",
  "subarea": "Notação “Big O”, “Little o”, “Omega” e “Theta”",
  "gabarito": "A",
  "atributo_rag": "fundamentos da computacao - analise de algoritmos - notacao “big o”, “little o”, “omega” e “theta”"
},

{
  "id": "2016-22",
  "edicao": 2016,
  "numero": 22,
  "enunciado": "O tempo de execução T(n) de um algoritmo, em que n é o tamanho da entrada, é dado pela equação de recorrência $T(n) = 8T(n/2)+q*n$ se n > 1. Dado que T(1) = p, e que p e q são constantes arbitrárias, a complexidade do algoritmo é:",
  "alternativas": [
    "a) O(n).",
    "b) O(n log n).",
    "c) O(n^2).",
    "d) O(n^3).",
    "e) O(n^n)."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Análise de Algoritmos",
  "subarea": "O Uso de Relações de Recorrência para Análise de Algoritmos Recursivos",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - analise de algoritmos - o uso de relacoes de recorrencia para analise de algoritmos recursivos"
},

{
  "id": "2016-24",
  "edicao": 2016,
  "numero": 24,
  "enunciado": "A operação de destruição de uma árvore requer um tipo de percurso em que a liberação de um nó é realizada apenas após todos os seus descendentes terem sido também liberados. Segundo essa descrição, a operação de destruição de uma árvore deve ser implementada utilizando o percurso",
  "alternativas": [
    "a) em ordem.",
    "b) pré-ordem.",
    "c) central.",
    "d) simétrico.",
    "e) pós-ordem."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Algoritmos e Estrutura de Dados",
  "subarea": "Árvores e suas Generalizações: Árvores Binárias, Árvores de Busca e Árvores Balanceadas",
  "gabarito": "E",
  "atributo_rag": "fundamentos da computacao - algoritmos e estrutura de dados - arvores e suas generalizacoes: arvores binarias, arvores de busca e arvores balanceadas"
},

{
  "id": "2016-25",
  "edicao": 2016,
  "numero": 25,
  "enunciado": "Em relação ao projeto de algoritmos, relacione a Coluna 1 à Coluna 2. \\\n**Coluna 1**\n1. 1 - Tentativa e Erro.\n2. 2 - Divisão e Conquista.\n3. 3 - Guloso.\n4. 4 - Aproximado.\n5. 5 - Heurística. \\\n**Coluna 2** \\\n( ) O algoritmo decompõe o processo em um número finito de subtarefas parciais que devem ser exploradas exaustivamente. \\\n( ) O algoritmo divide o problema a ser resolvido em partes menores, encontra soluções para as partes e então combina as soluções obtidas em uma solução global. \\\n( ) O algoritmo constrói por etapas uma solução ótima. Em cada passo, após selecionar um elemento da entrada (o melhor), decide se ele é viável (caso em que virá a fazer parte da solução) ou não. Após uma sequência de decisões, uma solução para o problema é alcançada. \\\n( ) O algoritmo gera soluções cujo resultado encontra-se dentro de um limite para a razão entre a solução ótima e a produzida pelo algoritmo. \\\n( ) O algoritmo pode produzir um bom resultado, ou até mesmo obter uma solução ótima, mas pode também não produzir solução nenhuma ou uma solução distante da solução ótima. \n\nA ordem correta de preenchimento dos parênteses, de cima para baixo, é:",
  "alternativas": [
    "a) 1 – 2 – 3 – 4 – 5.",
    "b) 2 – 3 – 4 – 5 – 1.",
    "c) 3 – 4 – 5 – 1 – 2.",
    "d) 4 – 5 – 1 – 2 – 3.",
    "e) 5 – 1 – 2 – 3 – 4."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Algoritmos e Estrutura de Dados",
  "subarea": "Técnicas de Projeto de Algoritmos: Método da Força Bruta, Pesquisa Exaustiva, Algoritmo Guloso, Dividir e Conquistar, “Backtracking” e Heurísticas",
  "gabarito": "A",
  "atributo_rag": "fundamentos da computacao - algoritmos e estrutura de dados - tecnicas de projeto de algoritmos: metodo da forca bruta, pesquisa exaustiva, algoritmo guloso, dividir e conquistar, “backtracking” e heuristicas"
},

{
  "id": "2016-26",
  "edicao": 2016,
  "numero": 26,
  "enunciado": "Uma árvore balanceada T que armazena n chaves é uma árvore binária de pesquisa na qual",
  "alternativas": [
    "a) a diferença entre as alturas de suas subárvores permanece constante em todo o caso, após inserções ou remoções de chaves.",
    "b) as operações de inserção e remoção de chaves em nodos internos v de T seguem um padrão linear de tempo de execução.",
    "c) a propriedade da altura/balanceamento é determinada pela extensão do caminho mais curto entre um nodo interno v até o nodo raiz de T.",
    "d) a variação da altura dos nodos filhos de cada nodo interno v de T é de, no máximo, uma unidade.",
    "e) o tempo de execução para todas as operações fundamentais sobre cada nodo interno v de T se mantém constante."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Algoritmos e Estrutura de Dados",
  "subarea": "Árvores e suas Generalizações: Árvores Binárias, Árvores de Busca e Árvores Balanceadas",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - algoritmos e estrutura de dados - arvores e suas generalizacoes: arvores binarias, arvores de busca e arvores balanceadas"
},

{
  "id": "2016-27",
  "edicao": 2016,
  "numero": 27,
  "enunciado": "Assinale a alternativa correta sobre o Paradigma de Programação Imperativo.",
  "alternativas": [
    "a) É baseado na arquitetura de Von Neumann.",
    "b) Nos métodos e nos atributos, também são definidas as formas de relacionamento com objetos.",
    "c) É baseada na arquitetura MVC (Model-View-Controller).",
    "d) Não existem procedimentos ou funções.",
    "e) Fácil legibilidade e manutenibilidade."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens de Programação",
  "subarea": "Paradigmas de Linguagens de Programação",
  "gabarito": "A",
  "atributo_rag": "fundamentos da computacao - linguagens de programacao - paradigmas de linguagens de programacao"
},

{
  "id": "2016-28",
  "edicao": 2016,
  "numero": 28,
  "enunciado": "Assinale a alternativa que apresenta o nome de uma linguagem de tipagem dinâmica.",
  "alternativas": [
    "A) Java.",
    "B) C.",
    "C) Python.",
    "D) Pascal.",
    "E) C#."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens de Programação",
  "subarea": "Teoria dos Tipos: Sistemas de Tipos, Polimorfismo",
  "gabarito": "C",
  "atributo_rag": "fundamentos da computacao - linguagens de programacao - teoria dos tipos: sistemas de tipos, polimorfismo"
},

{
  "id": "2016-29",
  "edicao": 2016,
  "numero": 29,
  "enunciado": "A organização de arquivo Sorted File mantém registros",
  "alternativas": [
    "a) armazenados em regiões indexados por uma função, enquanto a Heap file mantém registros armazenados em ordem da chave de busca.",
    "b) armazenados em ordem da chave de busca, enquanto a Hashed file mantém registros distribuídos aleatoriamente nas páginas.",
    "c) distribuídos aleatoriamente nas páginas, enquanto a Hashed file mantém registros armazenados em regiões, indexados por uma função.",
    "d) armazenados em ordem da chave de busca, enquanto a Heap file mantém registros distribuídos aleatoriamente nas páginas.",
    "e) distribuídos aleatoriamente nas páginas, enquanto a Heap file mantém registros armazenados em ordem da chave de busca."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Organização de Arquivos e Dados",
  "subarea": "Organização, Estrutura e Operação de Arquivos",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - organizacao de arquivos e dados - organizacao, estrutura e operacao de arquivos"
},

{
  "id": "2016-30",
  "edicao": 2016,
  "numero": 30,
  "enunciado": "Assinale a alternativa que corresponde à saída do programa a seguir:\n```\n\nint i, x = 4, w = 9, q;\nfor (i = -1; i < 20; i+= 3){\n   x++;\n   for (q = 4; q < 11; q++){\n       do {\n           i += 3;\n           w = sizeof(i);\n           i = x + w;\n           x = w + i;\n       } while (x < 15);\n    }\n}\nprintf(\"x: %d, i : %d\", x, i); \n\n```",
  "alternativas": [
    "a) $x: 68, i: 67.$",
    "b) $x: 68, i: 68.$",
    "c) $x: 69, i: 68.$",
    "d) $x: 69, i: 69.$",
    "e) $x: 69, i: 70.$"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens de Programação",
  "subarea": "Paradigmas de Linguagens de Programação",
  "gabarito": "ANULADA",
  "atributo_rag": "fundamentos da computacao - linguagens de programacao - paradigmas de linguagens de programacao"
},

{
  "id": "2016-32",
  "edicao": 2016,
  "numero": 32,
  "enunciado": "A matriz de um grafo G = (V,A) contendo n vértices é uma matriz n x n de bits, em que A[i,j] é 1 (ou verdadeiro, no caso de booleanos) se e somente se existir um arco do vértice i para o vértice j. Essa definição é uma:",
  "alternativas": [
    "a) Matriz de adjacência para grafos não ponderados.",
    "b) Matriz de recorrência para grafos não ponderados.",
    "c) Matriz de incidência para grafos não ponderados.",
    "d) Matriz de adjacência para grafos ponderados.",
    "e) Matriz de incidência para grafos ponderados."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Teoria dos Grafos",
  "subarea": "Grafos orientados e não-orientados",
  "gabarito": "A",
  "atributo_rag": "fundamentos da computacao - teoria dos grafos - grafos orientados e nao-orientados"
},

{
  "id": "2016-33",
  "edicao": 2016,
  "numero": 33,
  "enunciado": "Assinale a alternativa correta em relação ao padrão de projeto Singleton.",
  "alternativas": [
    "a) Possui apenas 2 classes.",
    "b) É instanciado através da chamada de um método público e estático.",
    "c) Possui um membro privado não estático da própria classe.",
    "d) Tem que ter o construtor público para funcionar.",
    "e) Não é um padrão de criação."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Técnicas de Programação",
  "subarea": "Modularidade e abstração",
  "gabarito": "B",
  "atributo_rag": "fundamentos da computacao - tecnicas de programacao - modularidade e abstracao"
},

{
  "id": "2016-34",
  "edicao": 2016,
  "numero": 34,
  "enunciado": "O VFS (Virtual File System) é o mecanismo que permite que chamadas de sistemas genéricas possam ser executadas independentemente do sistema de arquivos usado ou do meio físico. Em relação aos objetos primários do VFS, analise as afirmações abaixo e assinale V, se verdadeiras, ou F, se falsas.\n- ( ) Superbloco é utilizado para armazenar informações sobre um sistema de arquivos específico.\n- ( ) Inode representa um arquivo específico. Cada arquivo é representado por um inode no Sistema de Arquivos.\n- ( ) Dentry representa uma entrada de diretório. O objeto Dentry não corresponde a qualquer estrutura de dados armazenada em disco. \n\nA ordem correta de preenchimento dos parênteses, de cima para baixo, é:",
  "alternativas": [
    "a) F – F – F.",
    "b) F – F – V.",
    "c) F – V – V.",
    "d) V – V – V.",
    "e) V – V – F."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Sistemas Operacionais",
  "subarea": "Gerenciamento de Arquivos",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - sistemas operacionais - gerenciamento de arquivos"
},

{
  "id": "2016-35",
  "edicao": 2016,
  "numero": 35,
  "enunciado": "Quanto às propriedades de cada tipo de índice, ao comparar número de entradas de índice e densidade, é correto afirmar que:",
  "alternativas": [
    "a) O tipo de índice primário possui número de blocos no arquivo de dados e é denso.",
    "b) O tipo de índice agrupamento possui número de valores de campo de índice distintos e é denso.",
    "c) O tipo de índice secundário (chave) possui número de registros no arquivo de dados e não é denso.",
    "d) O tipo de índice secundário (não chave) possui número de valores de campo de índice distintos, no caso de manter as próprias entradas de índice em um tamanho fixo e ter uma única entrada para cada valor de campo de índice, mas criar um nível de indireção extra para lidar com múltiplos ponteiros, e, assim, esse é um índice denso.",
    "e) O tipo de índice secundário (não chave) possui número de registros, no caso de incluir entradas de índice duplicadas com um mesmo valor K(i) – um para cada valor, e, assim, é um índice denso."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Organização de Arquivos e Dados",
  "subarea": "Organização, Estrutura e Operação de Arquivos",
  "gabarito": "E",
  "atributo_rag": "fundamentos da computacao - organizacao de arquivos e dados - organizacao, estrutura e operacao de arquivos"
},

{
  "id": "2016-37",
  "edicao": 2016,
  "numero": 37,
  "enunciado": "Em relação a Teoria dos Grafos, relacione a Coluna 1 à Coluna 2. \\\n**Coluna 1**\n1. 1 - Grafo Completo.\n2. 2 - Hipergrafo.\n3. 3 - Árvore Livre.\n4. 4 - Grafo Planar.\n5. 5 - Grafo não direcionado antirregular.\\\n**Coluna 2**\n- ( ) Grafo não direcionado, no qual todos os pares de vértices são adjacentes entre si.\n- ( ) Grafo não direcionado em que cada aresta conecta um número arbitrário de vértices, ao invés de conectar dois vértices apenas.\n- ( ) Grafo não direcionado acíclico e dirigido.\n- ( ) Grafo em que seu esquema pode ser traçado em um plano, de modo que duas arestas quaisquer se toquem, no máximo, em alguma extremidade.\n- ( ) Grafo que possui o maior número possível de graus diferentes em sua sequência. \n\nA ordem correta de preenchimento dos parênteses, de cima para baixo, é:",
  "alternativas": [
    "a) 1 – 2 – 3 – 4 – 5.",
    "b) 2 – 3 – 4 – 5 – 1.",
    "c) 3 – 4 – 5 – 1 – 2.",
    "d) 4 – 5 – 1 – 2 – 3.",
    "e) 5 – 1 – 2 – 3 – 4."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Teoria dos Grafos",
  "subarea": "Grafos orientados e não-orientados",
  "gabarito": "A",
  "atributo_rag": "fundamentos da computacao - teoria dos grafos - grafos orientados e nao-orientados"
},

{
  "id": "2016-38",
  "edicao": 2016,
  "numero": 38,
  "enunciado": "Assinale a alternativa correta a respeito do algoritmo em Java a seguir.\n\n```\n\nSet<Integer> numeros = new TreeSet<Integer>();\nRandom rand = new Random();\nwhile (numeros.size() < 20){\n    numeros.add(rand.nextInt(101));\n}\nSystem.out.println(\"Números: \" + numeros);\n\n```",
  "alternativas": [
    "a) Os números impressos no console variam de 0 até 100 sem repetição.",
    "b) Os números impressos no console variam de 0 até 101 com repetição.",
    "c) A classe TreeSet garante que os números não se repitam.",
    "d) A classe Set gera números aleatórios.",
    "e) Vinte e um números serão sorteados."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens de Programação",
  "subarea": "Paradigmas de Linguagens de Programação",
  "gabarito": "ANULADA",
  "atributo_rag": "fundamentos da computacao - linguagens de programacao - paradigmas de linguagens de programacao"
},

{
  "id": "2016-40",
  "edicao": 2016,
  "numero": 40,
  "enunciado": " linguagem $ L = \\{a^n b^m \\mid n \\leq m + 3\\}, \\text{ para } n \\geq 0 \\text{ e } m \\geq 0 $, é:",
  "alternativas": [
    "a) Regular e gerada pela gramática $ S \\rightarrow aA, \\, A \\rightarrow baA \\mid \\varepsilon $.",
    "b)  Sensível ao contexto e gerada pela gramática:\n    \n$$\n    \\begin{aligned}\n    &S \\rightarrow aSBC, \\quad S \\rightarrow aBC, \\quad CB \\rightarrow BC, \\quad aB \\rightarrow ab, \\\\\n    &bB \\rightarrow bb, \\quad bC \\rightarrow bc, \\quad cC \\rightarrow cc.\n    \\end{aligned}\n    $$",
    "c) Recursivamente enumerável e gerada por uma gramática sem restrições nas regras de produção.",
    "d) Estrutura de frase e gerada por uma gramática sem restrições nas regras de produção.",
    "e)  Livre de contexto e gerada pela gramática:\n    \n$$\n    S \\rightarrow aaaA, \\quad A \\rightarrow aAb \\mid B, \\quad B \\rightarrow Bb \\mid \\varepsilon.\n    $$"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens Formais, Autômatos e Computabilidade",
  "subarea": "Linguagens Regulares, Livres-de-Contexto e Sensíveis-ao-Contexto",
  "gabarito": "ANULADA",
  "atributo_rag": "fundamentos da computacao - linguagens formais, automatos e computabilidade - linguagens regulares, livres-de-contexto e sensiveis-ao-contexto"
},

{
  "id": "2016-41",
  "edicao": 2016,
  "numero": 41,
  "enunciado": "Considere a linguagem \n$$L = \\{ ww \\mid w \\in \\{a,b\\}^+ \\}\n$$\nsobre a construção e a eficiência de algoritmos para aceitar L sobre uma máquina de Turing padrão e assinale a alternativa correta.",
  "alternativas": [
    "a) Contar o número de símbolos. Se a contagem é feita em unário, a operação tem custo O(n). Emseguida, escrever a primeira metade em outra fita. Essa também é uma operação com custo O(n).\nFinalmente, a comparação pode ser feita em O(n) movimentos.",
    "b) Encontrar o meio da cadeia e voltar para fazer o mathc (casamento) dos símbolos. Ambas as partes são feitas em $O( n^2 )$ movimentos.",
    "c) Adivinhar o meio da cadeia não deterministicamente em um movimento. A correspondência leva $O( n^2 )$ movimentos.",
    "d) Advinhar o meio da cadeia e proceder como em (a). O custo total é O(n) movimentos.",
    "e) Iniciar em uma das extremidades da cadeia e contar até o meio. O custo é $O( n^2 )$movimentos."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens Formais, Autômatos e Computabilidade",
  "subarea": "Máquina de Turing",
  "gabarito": "B",
  "atributo_rag": "fundamentos da computacao - linguagens formais, automatos e computabilidade - maquina de turing"
},

{
  "id": "2016-43",
  "edicao": 2016,
  "numero": 43,
  "enunciado": "Em relação aos circuitos digitais, analise as assertivas abaixo e assinale V, se verdadeiras, ou F, se falsas.\n- ( ) Uma porta NAND (Não-E) é equivalente a uma porta OR (OU) com as entradas e as saídas complementadas.\n- ( ) Qualquer função booleana pode ser representada utilizando somente portas NAND (Não-E) e NOR (Não-Ou).\n- ( ) Os índices do Mapa de Karnaugh são numerados utilizando o Código de Reed-Solomon, o que faz com que as distâncias entre células horizontais e verticais difiram de exatamente um bit. \n\nA ordem correta de preenchimento dos parênteses, de cima para baixo, é:",
  "alternativas": [
    "a) F – V – F.",
    "b) F – F – V.",
    "c) V – F – V.",
    "d) V – V – F.",
    "e) V – F – F."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Circuitos Digitais",
  "subarea": "Representação e Manipulação de Circuitos Combinatórios",
  "gabarito": "A",
  "atributo_rag": "fundamentos da computacao - circuitos digitais - representacao e manipulacao de circuitos combinatorios"
},

{
  "id": "2016-44",
  "edicao": 2016,
  "numero": 44,
  "enunciado": "A representação em complemento de dois é uma representação binária de números com sinal a qual utiliza o bit mais significativo como bit de sinal, o que facilita o teste se um número inteiro é positivo ou negativo. \n\nDe acordo com a regra da representação em complemento de dois, a conversão do número -32658 corresponde ao número:",
  "alternativas": [
    "a) $1000000001010001.$",
    "b) $1001001001001001.$",
    "c) $1111111100100010.$",
    "d) $1011111100010001.$",
    "e) $1000000001101110.$"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Circuitos Digitais",
  "subarea": "Sistemas de Numeração e Códigos",
  "gabarito": "E",
  "atributo_rag": "fundamentos da computacao - circuitos digitais - sistemas de numeracao e codigos"
},

{
  "id": "2016-45",
  "edicao": 2016,
  "numero": 45,
  "enunciado": "Algoritmos de substituição de página são importantes em sistemas operacionais que usam a técnica de memória virtual. Em geral, escolhe-se um algoritmo de substituição de página que resulte em menor taxa de falta de página (page fault). Contudo, alguns algoritmos de substituição de página apresentam a anomalia de Belady (Belady’s anomaly). O que caracteriza essa anomalia é o fato de o número de faltas de página aumentar na medida em que o",
  "alternativas": [
    "a) tempo de execução aumenta.",
    "b) número de páginas alocadas aumenta.",
    "c) número de páginas não alocadas aumenta.",
    "d) tempo de retenção de páginas alocadas aumenta.",
    "e) número de vezes que as páginas alocadas são acessadas."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Sistemas Operacionais",
  "subarea": "Gerenciamento de Memória: Memória Virtual, Paginação, Segmentação e “Swap”",
  "gabarito": "B",
  "atributo_rag": "fundamentos da computacao - sistemas operacionais - gerenciamento de memoria: memoria virtual, paginacao, segmentacao e “swap”"
},

{
  "id": "2016-46",
  "edicao": 2016,
  "numero": 46,
  "enunciado": "Em um sistema computacional multiprocessado, onde o sistema operacional realiza escalonamento de tarefas do tipo preemptivo, três processos (P1, P2 e P3) compartilham recursos (R1, R2 e R3). Os processos P1 e P2 concorrem entre si ao acesso do recurso R1, enquanto P2 e P3 concorrem entre si ao acesso dos recursos R2 e R3. Os recursos R1 e R3 são preemptíveis, ou seja, podem sofrer preempção; R2 é um recurso não preemptível. Todos os três processos usam o mesmo mecanismo de exclusão mútua para garantir acesso exclusivo em suas seções críticas. Com base nesse cenário, é correto afirmar que:",
  "alternativas": [
    "a) Não é possível ocorrer deadlock entre os três processos.",
    "b) É possível ocorrer deadlock entre P1 e P2.",
    "c) É possível ocorrer deadlock entre P2 e P3.",
    "d) É possível ocorrer deadlock entre P1 e P3.",
    "e) É possível ocorrer deadlock com uma espera circular entre P1, P2 e P3."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Sistemas Operacionais",
  "subarea": "Comunicação, Concorrência e Sincronização de Processos",
  "gabarito": "A",
  "atributo_rag": "fundamentos da computacao - sistemas operacionais - comunicacao, concorrencia e sincronizacao de processos"
},

{
  "id": "2016-47",
  "edicao": 2016,
  "numero": 47,
  "enunciado": "Dada a função F(A,B,C,D) composta dos termos mínimos (minterm)={0, 2, 6, 8, 9, 11, 12, 13} e dos termos não essenciais (don’t care)={5, 13}. Simplifique essa função como soma de produtos. O símbolo ’ representa o complemento:",
  "alternativas": [
    "a) AC’+AD+A’CD’+B’C’D’",
    "b) AC’D’+AB’C’+ACD+A’CD’+A’B’D’",
    "c) AC’+AD+A’CD’+A’B’D’+BC’D",
    "d) ACD’+A’D+A’BC’",
    "e) AC’+AD’+ A’CD+ B’C’D’"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Circuitos Digitais",
  "subarea": "Minimização e Otimização de Funções Combinatórias",
  "gabarito": "ANULADA",
  "atributo_rag": "fundamentos da computacao - circuitos digitais - minimizacao e otimizacao de funcoes combinatorias"
},

{
  "id": "2016-48",
  "edicao": 2016,
  "numero": 48,
  "enunciado": "Analise as seguintes definições de *pipeline* de instruções simples, superescalar e *multithreading* simultâneo:\n\nI. *Pipeline* instruções simples: instruções individuais que são executadas através de um *pipeline* de estágios, de maneira que, enquanto uma instrução está sendo executada em um estágio, outra instrução está sendo executada em outro estágio do *pipeline*.\\\nII. Superescalar: um *pipeline* é construído por meio da replicação de recursos de execução, o que permite a execução paralela de instruções em *pipelines* paralelos.\\\nIII. *Multithreading* simultâneo (SMT): bancos de registros são replicados para que múltiplas threads possam compartilhar o uso dos recursos de *pipelines*.\n\nQuais estão corretas?",
  "alternativas": [
    "A) Apenas I.",
    "B) Apenas III.",
    "C) Apenas I e II.",
    "D) Apenas II e III.",
    "E) I, II e III."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Arquitetura e Organização de Computadores",
  "subarea": "Processadores Superescalares e Superpipeline",
  "gabarito": "C",
  "atributo_rag": "fundamentos da computacao - arquitetura e organizacao de computadores - processadores superescalares e superpipeline"
},

{
  "id": "2016-49",
  "edicao": 2016,
  "numero": 49,
  "enunciado": "O protocolo MESI (conhecido também como protocolo de Illinois) é um protocolo de coerência de cache e coerência de memória largamente utilizado. Quais são os quatro estados de linha da memória cache de acordo com o Protocolo MESI e quais seus respectivos significados?",
  "alternativas": [
    "a) Ampliada: a linha da cache foi modificada (é o dobro da memória principal) e está presente em toda cache. Dedicada: a linha da cache é destinada à memória principal e não está presente em nenhuma outra cache. Replicada: a linha da cache é replicada na memória principal e pode estar presente em outra cache. Finita: a linha da cache contém dados válidos apenas na memória principal.",
    "b) Modificada: a linha da cache foi modificada (é diferente da memória principal) e está presente apenas nessa cache. Exclusiva: a linha da cache é igual àquela na memória principal e não está presente em nenhuma outra cache. Compartilhada: a linha da cache é igual àquela na memória principal e pode estar presente em outra cache. Inválida: a linha da cache não contém dados válidos.",
    "c) Ampliada: a linha da cache foi ampliada (é maior que a memória principal) e está presente em toda cache. Exclusiva: a linha da cache é igual àquela na memória principal e não está presente em nenhuma outra cache. Replicada: a linha da cache é replicada na memória principal e pode estar presente em outra cache. Finita: a linha da cache contém dados válidos apenas na principal e a cache é limitada.",
    "d) Modificada: a linha da cache foi duplicada (é diferente da memória principal) e está presente em toda cache. Dedicada: a linha da cache é destinada à memória principal e não está presente em nenhuma outra cache. Compartilhada: a linha da cache é diferente da memória principal e pode estar presente em outra cache. Finita: a linha da cache contém dados válidos apenas na memória principal.",
    "e) Ampliada: a linha da cache foi modificada (é o dobro da memória principal) e está presente em toda cache. Dedicada: a linha da cache é destinada à memória principal e não está presente em nenhuma outra cache. Replicada: a linha da cache é replicada na memória principal e pode estar presente em outra cache. Inválida: a linha da cache não contém dados válidos na memória principal."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Arquitetura e Organização de Computadores",
  "subarea": "Organização de Memória",
  "gabarito": "B",
  "atributo_rag": "fundamentos da computacao - arquitetura e organizacao de computadores - organizacao de memoria"
},

{
  "id": "2016-50",
  "edicao": 2016,
  "numero": 50,
  "enunciado": "Um VSNT (Veículo Submarino Não Tripulado) é usado para monitoramento de plataformas de petróleo marítimas. O VSNT tira uma foto a cada 1 minuto. O tamanho de cada arquivo de foto é padronizado em 5 kB. As fotos são armazenadas em uma partição do disco rígido do VSNT, a qual é formatada com sistema de arquivos FAT32 e tamanho de bloco (cluster) de 4 kB. O tempo de missão do VSNT é de uma hora. Após o término de cada missão, as fotos são copiadas do VSNT para um computador, que utiliza uma partição FAT32 formatada com clusters de 8 kB. Com base nesse cenário, o espaço necessário no computador para armazenar todos os arquivos do VSNT em uma missão é de:\\\n**kB: kilobyte**\\\n**1 kB = 1024 bytes**",
  "alternativas": [
    "A) 240 kB.",
    "B) 300 kB.",
    "C) 360 kB.",
    "D) 480 kB.",
    "E) 600 kB."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Sistemas Operacionais",
  "subarea": "Gerenciamento de Arquivos",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - sistemas operacionais - gerenciamento de arquivos"
},

{
  "id": "2017-21",
  "edicao": 2017,
  "numero": 21,
  "enunciado": "Suponha que, ao invés de dividir em duas partes, foi criada uma versão do merge- sort que divida a entrada em quatro partes, ordene cada quarta-parte, e, finalmente, combine essas quatro partes usando um procedimento O(n). A equação de recorrência que descreve o tempo de execução desse algoritmo é:",
  "alternativas": [
    "a) $T(n) = 4*T(n/4) + O(n)$",
    "b) $T(n) = 4*T(n/2) + 2*O(n)$",
    "c) $T(n) = T(n/4) + 4*O(n)$",
    "d) $T(n) = 4*T(n/4) + 4*O(n)$",
    "e) $T(n) = T(n/4) + O(n)$"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Análise de Algoritmos",
  "subarea": "O Uso de Relações de Recorrência para Análise de Algoritmos Recursivos",
  "gabarito": "ANULADA",
  "atributo_rag": "fundamentos da computacao - analise de algoritmos - o uso de relacoes de recorrencia para analise de algoritmos recursivos"
},

{
  "id": "2017-22",
  "edicao": 2017,
  "numero": 22,
  "enunciado": "A complexidade de tempo da questão 21 é:",
  "alternativas": [
    "a) $O(n^2)$",
    "b) $O(n^4)$",
    "c) $O(4*n)$",
    "d) $O(n log n)$",
    "e) $O(n)$"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Análise de Algoritmos",
  "subarea": "Análise de Algoritmos Iterativos e Recursivos",
  "gabarito": "ANULADA",
  "atributo_rag": "fundamentos da computacao - analise de algoritmos - analise de algoritmos iterativos e recursivos"
},

{
  "id": "2017-23",
  "edicao": 2017,
  "numero": 23,
  "enunciado": "Considere o problema de somar os n elementos de um mesmo arranjo A de inteiros.\nO problema é resolvido da seguinte forma: (i) somam-se recursivamente os elementos da primeira metade de A; (ii) somam-se recursivamente os elementos da segunda metade de A; e (iii) soma-se esses dois valores juntos. Que tipo de recursão foi utilizada para a solução do problema?",
  "alternativas": [
    "a) Linear.",
    "b) Binária.",
    "c) Ternária.",
    "d) Final.",
    "e) Múltipla."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Algoritmos e Estrutura de Dados",
  "subarea": "Recursividade: Conceito e Implementação",
  "gabarito": "B",
  "atributo_rag": "fundamentos da computacao - algoritmos e estrutura de dados - recursividade: conceito e implementacao"
},

{
  "id": "2017-24",
  "edicao": 2017,
  "numero": 24,
  "enunciado": "Em relação às estruturas de dados do tipo lista, analise as assertivas abaixo, assinalando V, se verdadeiras, ou F, se falsas. \\\n( ) Uma implementação de fila por meio de arranjos é circular e delimitada pelos apontadores Frente e Trás. Para enfileirar um item, basta mover o apontador Trás uma posição no sentido horário; para desenfileirar um item, basta mover o apontador Frente no sentido horário. \\\n( ) Em uma lista duplamente encadeada, todas as inserções são realizadas em um extremo da lista, enquanto as exclusões e acessos são realizados no outro extremo da lista. \\\n( ) Filas são utilizadas quando se deseja processar itens de acordo com a ordem “primeiro-que-chega, primeiro-atendido”. \\\n( ) Uma pilha é uma lista linear nas quais inserções, exclusões e acessos a itens ocorrem sempre em um dos extremos da lista.  \nA ordem correta de preenchimento dos parênteses, de cima para baixo, é:",
  "alternativas": [
    "a) V – F – F – V.",
    "b) V – V – F – F.",
    "c) V – F – V – F.",
    "d) F – V – F – V.",
    "e) F – F – V – V."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Algoritmos e Estrutura de Dados",
  "subarea": "Estruturas de Dados Lineares e suas Generalizações: Listas Ordenadas, Listas Encadeadas, Pilhas e Filas",
  "gabarito": "ANULADA",
  "atributo_rag": "fundamentos da computacao - algoritmos e estrutura de dados - estruturas de dados lineares e suas generalizacoes: listas ordenadas, listas encadeadas, pilhas e filas"
},

{
  "id": "2017-25",
  "edicao": 2017,
  "numero": 25,
  "enunciado": "A análise de algoritmos que estabelece um limite superior para o tempo de execução de qualquer entrada é denominada análise",
  "alternativas": [
    "a) do melhor caso.",
    "b) do caso médio.",
    "c) do pior caso.",
    "d) da ordem de crescimento.",
    "e) do tamanho da entrada."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Análise de Algoritmos",
  "subarea": "Análise de Algoritmos Iterativos e Recursivos",
  "gabarito": "C",
  "atributo_rag": "fundamentos da computacao - analise de algoritmos - analise de algoritmos iterativos e recursivos"
},

{
  "id": "2017-26",
  "edicao": 2017,
  "numero": 26,
  "enunciado": "O caminhamento pré-fixado à esquerda para uma Árvore Binária de Pesquisa (ABP) é 44, 30, 12, 26, 36, 33, 92, 64, 46, 98. O caminhamento pré-fixado à direta para a mesma árvore é:",
  "alternativas": [
    "a) 26, 12, 33, 36, 30, 46, 64, 98, 92, 44",
    "b) 44, 92, 98, 64, 46, 30, 36, 33, 12, 26",
    "c) 12, 26, 30, 33, 36, 44, 46, 64, 92, 98",
    "d) 98, 46, 64, 92, 33, 36, 26, 12, 30, 44",
    "e) 98, 92, 64, 46, 44, 36, 33, 30, 26, 12"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Algoritmos e Estrutura de Dados",
  "subarea": "Árvores e suas Generalizações: Árvores Binárias, Árvores de Busca e Árvores Balanceadas",
  "gabarito": "B",
  "atributo_rag": "fundamentos da computacao - algoritmos e estrutura de dados - arvores e suas generalizacoes: arvores binarias, arvores de busca e arvores balanceadas"
},

{
  "id": "2017-27",
  "edicao": 2017,
  "numero": 27,
  "enunciado": "A saída do trecho de código em C abaixo é:\n```\n   int i = 0, j = -9, k = 7, cont;\n\n    for (cont = 4; cont < 11; cont++) {\n        i = cont + 5;\n        while (k > 0) {\n            k = k - 1;\n            j = k + j / 2;\n        }\n    }\n\n    printf(\"i: %d j: %d k: %d \", i, j, k);\n```",
  "alternativas": [
    "a) i: 1 j: 4 k:1",
    "b) i: 15 j: 1 k:0",
    "c) i: 10 j: 14 k:2",
    "d) i: 13 j: 2 k:3",
    "e) i: 3 j: 1 k:4"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens de Programação",
  "subarea": "Paradigmas de Linguagens de Programação",
  "gabarito": "B",
  "atributo_rag": "fundamentos da computacao - linguagens de programacao - paradigmas de linguagens de programacao"
},

{
  "id": "2017-29",
  "edicao": 2017,
  "numero": 29,
  "enunciado": "Analise as assertivas a seguir sobre compressão de dados:\\\nI. A técnica de codificação corrida (do inglês RLE – run-length encoding) é adequada quando existem longas sequências de bits repetidos, pois utiliza contadores representando sequências alternadas de 0s e de 1s.\\\nII. A técnica de compressão de Huffman é baseada em códigos de tamanho variável, tal que os códigos de menor comprimento são atribuídos aos caracteres mais frequentes, e os de maior comprimento aos de menor frequência.\\\nIII. Quando o método LZW (Lempel-Ziv-Welch) é utilizado, a mensagem resultante da compressão inclui também uma representação dos códigos utilizados para a compressão. \\\nIV. Não existe um algoritmo de compressão de dados universal, isto é, que transforme qualquer sequência de bits (bitstream) de entrada em uma outra sequência de bits menor. \n\nQuais estão INCORRETAS?",
  "alternativas": [
    "a) Apenas I.",
    "b) Apenas II.",
    "c) Apenas III.",
    "d) Apenas II e IV.",
    "e) Apenas III e IV."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Organização de Arquivos e Dados",
  "subarea": "Compressão de Dados, Áudio, Imagem e Vídeo",
  "gabarito": "C",
  "atributo_rag": "fundamentos da computacao - organizacao de arquivos e dados - compressao de dados, audio, imagem e video"
},

{
  "id": "2017-30",
  "edicao": 2017,
  "numero": 30,
  "enunciado": "Um dos erros mais comuns que pode ocorrer durante a avaliação de uma expressão aritmética em um programa é quando o resultado de uma operação não pode ser representado na célula de memória para o qual ele foi alocado. Esse erro é chamado de transbordamento (_____________) e transbordamento negativo (_____________), dependendo se o resultado é muito grande ou muito pequeno. \n\nAssinale a alternativa que preenche, correta e respectivamente, as lacunas do trecho acima.",
  "alternativas": [
    "a) big error – small error",
    "b) coerção – sobrecarga",
    "c) encapsulamento – abstração",
    "d) overflow – underflow",
    "e) transparência – efeito colateral"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens de Programação",
  "subarea": "Verificação e Inferência de Tipos",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - linguagens de programacao - verificacao e inferencia de tipos"
},

{
  "id": "2017-31",
  "edicao": 2017,
  "numero": 31,
  "enunciado": "Quando uma expressão contém duas ocorrências adjacentes de operadores com o mesmo nível de precedência, a questão sobre qual deles é avaliado primeiro responde-se pelas regras de:",
  "alternativas": [
    "a) Associatividade.",
    "b) Expressões condicionais.",
    "c) Polimorfismo.",
    "d) Condutividade.",
    "e) Coerção."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens de Programação",
  "subarea": "Conceitos",
  "gabarito": "A",
  "atributo_rag": "fundamentos da computacao - linguagens de programacao - conceitos"
},

{
  "id": "2017-33",
  "edicao": 2017,
  "numero": 33,
  "enunciado": "Relacione a Coluna 1 à Coluna 2, associando as definições dos comandos sobre laços em linguagens de programação. \\\n**Coluna 1**\n1. 1 - break.\n2. 2- continue.\n3. 3 - loop.\n4. 4 - while. \\\n**Coluna 2**\\\n( ) Executa uma instrução ou um bloco de instruções enquanto uma determinada condição for verdadeira. \\\n( ) Termina a execução de um laço, continuando o programa na instrução imediatamente após o laço. \\\n( ) Faz com que uma iteração seja terminada, passando automaticamente à próxima iteração do laço. \\\n( ) Apresenta uma condição de teste verdadeira que nunca termina o laço. \n\nA ordem correta de preenchimento dos parênteses, de cima para baixo, é:",
  "alternativas": [
    "a) 1 – 2 – 3 – 4.",
    "b) 4 – 3 – 2 – 1.",
    "c) 3 – 1 – 4 – 2.",
    "d) 4 – 1 – 2 – 3.",
    "e) 2 – 4 – 3 – 1."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Algoritmos e Estrutura de Dados",
  "subarea": "Comandos de uma Linguagem de Programação",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - algoritmos e estrutura de dados - comandos de uma linguagem de programacao"
},

{
  "id": "2017-34",
  "edicao": 2017,
  "numero": 34,
  "enunciado": "Arquivo direto, também denominado arquivo hash, é uma forma de organização de arquivo baseada em hashing sobre um campo chave (o campo hash). Assinale a alternativa INCORRETA, dentre as afirmações abaixo, sobre arquivos hash.",
  "alternativas": [
    "a) O espaço do endereço-alvo da função hash são buckets, isto é, blocos de disco (ou grupos consecutivos de blocos de disco), cada qual mantendo múltiplos registros.",
    "b) O problema de colisão é resolvido utilizando buckets em áreas de overflow.",
    "c) Arquivos hash possibilitam acesso muito rápido a pesquisas baseadas na igualdade de valor do campo hash.",
    "d) O hashing extensível possui um diretório com profundida global d, que corresponde aos d dígitos mais significativos de um valor de hash. Já cada bucket possui profundidade local d’ possivelmente distinta dos demais buckets, tal que d<=d’.",
    "e) Uma grande vantagem do hashing extensível é que o desempenho do arquivo não degrada conforme o arquivo cresce, em oposição ao hashing estático."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Organização de Arquivos e Dados",
  "subarea": "Organização, Estrutura e Operação de Arquivos",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - organizacao de arquivos e dados - organizacao, estrutura e operacao de arquivos"
},

{
  "id": "2017-35",
  "edicao": 2017,
  "numero": 35,
  "enunciado": "Analise as seguintes assertivas sobre organização primária de arquivos, assinalando V, se verdadeiras, ou F, se falsas. \\\n( ) Em arquivos desordenados (heap), as operações de inserção são bastante eficientes, porque novos registros são acrescentados ao final do arquivo. \\\n( ) Em arquivos ordenados, a busca por registros baseados na chave de ordenação é bastante eficiente, desde que seja comparação por igualdade de valor. \\\n( ) Uma técnica para tornar o desempenho de operações de inserção mais eficientes em arquivos ordenados é utilizar um arquivo desordenado temporário, sendo que o arquivo ordenado passa a ser chamado arquivo principal (ou mestre). \\\n( ) O desempenho da pesquisa baseada em um campo de arquivos desordenados pode ser melhorado através de pesquisa binária. \n\nA ordem correta de preenchimento dos parênteses, de cima para baixo, é",
  "alternativas": [
    "a) V – V – F – V.",
    "b) V – F – F – F.",
    "c) F – F – V – F.",
    "d) F – V – F – V.",
    "e) V – F – V – F."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Organização de Arquivos e Dados",
  "subarea": "Organização, Estrutura e Operação de Arquivos",
  "gabarito": "E",
  "atributo_rag": "fundamentos da computacao - organizacao de arquivos e dados - organizacao, estrutura e operacao de arquivos"
},

{
  "id": "2017-36",
  "edicao": 2017,
  "numero": 36,
  "enunciado": "Sobre percurso em grafos, é correto afirmar que um percurso:",
  "alternativas": [
    "a) É uma família de ligações sucessivas incidentes, cada uma tendo uma extremidade incidente à anterior e à outra subsequente.",
    "b) É fechado, se a última ligação da sucessão for adjacente à primeira.",
    "c) Aberto não pode conter subpercursos fechados.",
    "d) É elementar, se não repetir ligações.",
    "e) É simples, se não repetir vértices."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Teoria dos Grafos",
  "subarea": "Grafos orientados e não-orientados",
  "gabarito": "B",
  "atributo_rag": "fundamentos da computacao - teoria dos grafos - grafos orientados e nao-orientados"
},

{
  "id": "2017-38",
  "edicao": 2017,
  "numero": 38,
  "enunciado": "Analise as seguintes afirmações sobre subprogramas em linguagens de programação:\n\nI. Cada subprograma tem um único ponto de entrada.\\\nII. O controle sempre retorna para o chamador quando a execução do subprograma termina.  \nIII. A unidade chamadora é suspensa durante a execução do subprograma chamado.  \nIV. Uma chamada a um subprograma é a requisição explícita para que ele seja executado.\n\nQuais estão corretas?",
  "alternativas": [
    "a) Apenas I e IV.",
    "b) Apenas II e III.",
    "c) Apenas I, II e III.",
    "d) Apenas II, III e IV.",
    "e) I, II, III e IV."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens de Programação",
  "subarea": "Paradigmas de Linguagens de Programação",
  "gabarito": "E",
  "atributo_rag": "fundamentos da computacao - linguagens de programacao - paradigmas de linguagens de programacao"
},

{
  "id": "2017-39",
  "edicao": 2017,
  "numero": 39,
  "enunciado": "Analise as seguintes assertivas sobre autômatos e linguagens:\n\nI. Autômatos finitos determinísticos e autômatos finitos não determinísticos aceitam o mesmo conjunto de linguagens. \\\nII. Seja L uma linguagem livre de contexto, existe um autômato com duas pilhas determinístico que reconhece L.  \nIII. Toda linguagem enumerável recursivamente é também uma linguagem recursiva. \n\nQuais estão corretas?",
  "alternativas": [
    "a) Apenas I.",
    "b) Apenas II.",
    "c) Apenas I e II.",
    "d) Apenas I e III.",
    "e) Apenas II e III."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens Formais, Autômatos e Computabilidade",
  "subarea": "Autômatos de Estados Finitos Determinístico e não Determinístico",
  "gabarito": "C",
  "atributo_rag": "fundamentos da computacao - linguagens formais, automatos e computabilidade - automatos de estados finitos deterministico e nao deterministico"
},

{
  "id": "2017-40",
  "edicao": 2017,
  "numero": 40,
  "enunciado": "Assinale a alternativa INCORRETA.",
  "alternativas": [
    "a) A união de duas linguagens recursivas é uma linguagem recursiva.",
    "b) Segundo a Tese de Church, a capacidade de computação representada pela máquina de Turing é o limite máximo que pode ser atingido por qualquer modelo de computação.",
    "c) Seja L uma linguagem enumerável recursivamente, se o complemento de L for enumerável recursivamente, então L é uma linguagem recursiva.",
    "d) Um problema X é NP-completo quando X pertence à classe NP e, adicionalmente, X é redutível em tempo polinomial para qualquer outro problema Y na classe NP.",
    "e) Todo problema que está na classe P também está na classe NP."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens Formais, Autômatos e Computabilidade",
  "subarea": "Propriedades das Linguagens",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - linguagens formais, automatos e computabilidade - propriedades das linguagens"
},

{
  "id": "2017-41",
  "edicao": 2017,
  "numero": 41,
  "enunciado": "Considere dois problemas de decisão PA e PB, sendo PA indecidível e PB decidível. Observe também dois problemas de decisão PC e PD, cuja decidibilidade é desconhecida. Suponha que seja possível construir de forma correta as seguintes reduções: \\\n- de PA para PC. \n- de PD para PA.\n- de PD para PB. \n\nCom base no cenário descrito, assinale a alternativa correta.",
  "alternativas": [
    "a) Não se pode afirmar nada sobre a decidibilidade dos problemas PC e PD.",
    "b) Não se pode afirmar nada sobre a decidibilidade de PC, porém PD é decidível.",
    "c) PC é indecidível e PD é decidível.",
    "d) PC e PD são ambos indecidíveis.",
    "e) PC é indecidível, contudo não se pode afirmar nada sobre a decidibilidade de PD."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens Formais, Autômatos e Computabilidade",
  "subarea": "Problemas Indecidíveis",
  "gabarito": "C",
  "atributo_rag": "fundamentos da computacao - linguagens formais, automatos e computabilidade - problemas indecidiveis"
},

{
  "id": "2017-42",
  "edicao": 2017,
  "numero": 42,
  "enunciado": "Um PLD que armazena sua configuração em memórias do tipo SRAM é, segundo sua capacidade de configuração, ________ e, segundo sua capacidade de armazenamento, _______. Um PLD que armazena sua configuração em memórias do tipo EEPROM ou FLASH é, segundo sua capacidade de configuração, ________ e, segundo sua capacidade de armazenamento, ________. \n\nAssinale a alternativa que preenche, correta e respectivamente, as lacunas do trecho acima.",
  "alternativas": [
    "a) reprogramável – não volátil – reprogramável – volátil",
    "b) programável somente uma vez – não volátil – reprogramável – não volátil",
    "c) reprogramável – volátil – reprogramável – volátil",
    "d) reprogramável – volátil – reprogramável – não volátil",
    "e) reprogramável – volátil – programável somente uma vez – não volátil"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Circuitos Digitais",
  "subarea": "Dispositivos Lógicos Programáveis (PLD)",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - circuitos digitais - dispositivos logicos programaveis (pld)"
},

{
  "id": "2017-44",
  "edicao": 2017,
  "numero": 44,
  "enunciado": "Considere que um processador tenha 16 bits de endereçamento de byte. Sua cache possui mapeamento direto com uma capacidade de 128 palavras e blocos de 8 palavras. O endereço se divide em campos para acesso à cache de acordo com a seguinte representação:\n```\n| Nome                         | Símbolo |\n|------------------------------|---------|\n| Etiqueta                     | i       |\n| Índice                       | ii      |\n| Palavra dentro do bloco      | iii     |\n| Byte dentro da palavra       | iv      |\n```\n\nO número de bits de cada um dos campos acima, ou seja, os valores de i, ii, iii e iv são, respectivamente:",
  "alternativas": [
    "a) 12, 6, 5 e 3",
    "b) 8, 4, 3 e 1",
    "c) 8, 6, 5 e 3",
    "d) 12, 4, 3 e 1",
    "e) 12, 6, 3 e 1"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Arquitetura e Organização de Computadores",
  "subarea": "Organização de Computadores: Memórias, Unidades Centrais de Processamento, Entrada e Saída",
  "gabarito": "B",
  "atributo_rag": "fundamentos da computacao - arquitetura e organizacao de computadores - organizacao de computadores: memorias, unidades centrais de processamento, entrada e saida"
},

{
  "id": "2017-45",
  "edicao": 2017,
  "numero": 45,
  "enunciado": "Em um computador com tamanho de quadro de memória de 1024 bytes, o sistema operacional aloca 1 página de memória virtual para armazenar a matriz M do código da Figura 1(linguagem C). A execução desse código resultará em quantas faltas de páginas (page faults)?\n```\nFigura 1 \n\nchar M[512][102 4];\nfor (j=0; j<1024; j++)\n   for (i=0; i<1024; i++)\n```",
  "alternativas": [
    "a) Zero",
    "b) 512",
    "c) 1024",
    "d) 512×512",
    "e) 512×1024"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Sistemas Operacionais",
  "subarea": "Gerenciamento de Memória: Memória Virtual, Paginação, Segmentação e “Swap”",
  "gabarito": "ANULADA",
  "atributo_rag": "fundamentos da computacao - sistemas operacionais - gerenciamento de memoria: memoria virtual, paginacao, segmentacao e “swap”"
},

{
  "id": "2017-46",
  "edicao": 2017,
  "numero": 46,
  "enunciado": "Uma partição de disco rígido é formatada com um sistema de arquivos que utiliza alocação encadeada baseada em tabela de alocação de arquivos (FAT). Após a formatação, a partição possui setores de 512 bytes e tamanho de bloco (cluster) de 2048 bytes. Ao criar um arquivo nessa partição, gravar 1 byte e fechá-lo, qual espaço esse arquivo ocupa na área de dados da partição?",
  "alternativas": [
    "a) 1 byte",
    "b) 2 bytes",
    "c) 512 bytes",
    "d) 2048 bytes",
    "e) 1 setor"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Sistemas Operacionais",
  "subarea": "Gerenciamento de Arquivos",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - sistemas operacionais - gerenciamento de arquivos"
},

{
  "id": "2017-48",
  "edicao": 2017,
  "numero": 48,
  "enunciado": "RAID é um conjunto de discos físicos vistos pelo Sistema Operacional como uma única unidade lógica. O RAID tem as seguintes características:\\\nI. RAID A: Redundante, espelhamento de discos, utiliza o dobro de discos.\\\nII. RAID B: Acesso paralelo, paridade de bit intercalada nos discos, utiliza apenas um disco.\\\nIII. RAID C: Acesso independente, paridade de bloco intercalada e distribuída. \n\nDe acordo com as configurações dos itens I, II e III, os RAID A, B e C são, respectivamente:",
  "alternativas": [
    "a) RAID 0, RAID 2 e RAID 4.",
    "b) RAID 2, RAID 4 e RAID 6.",
    "c) RAID 0, RAID 3 e RAID 5.",
    "d) RAID 1, RAID 3 e RAID 5.",
    "e) RAID 1, RAID 4 e RAID 6."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Sistemas Operacionais",
  "subarea": "Gerenciamento de Dispositivos de Entrada/Saída",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - sistemas operacionais - gerenciamento de dispositivos de entrada/saida"
},

{
  "id": "2017-49",
  "edicao": 2017,
  "numero": 49,
  "enunciado": "Considere o seguinte trecho de programa em linguagem Assembly do MIPS:\n```\n\n          .data 0x10010000 #segmento de dados palavra1: .word 13\npalavra2: .word 0x15\n\n```\nEm hexadecimal, os valores da palavra1 e palavra2 são, respectivamente:",
  "alternativas": [
    "a) 0x10010002 e 0x10010002",
    "b) 0x10010000 e 0x10010004",
    "c) 0x10010002 e 0x10010006",
    "d) 0x10010000 e 0x10010008",
    "e) 0x10010002 e 0x10010010"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Arquitetura e Organização de Computadores",
  "subarea": "Linguagens de Montagem",
  "gabarito": "B",
  "atributo_rag": "fundamentos da computacao - arquitetura e organizacao de computadores - linguagens de montagem"
},

{
  "id": "2017-50",
  "edicao": 2017,
  "numero": 50,
  "enunciado": "Analise o código a seguir:\n```\n...\nvoid thread ( void *ptr ){ while(1); }\n\nint main(){\n   int i; pthread_t tid[10];\n   for(i=0;i<10;i++)\n       pthread_create (&tid[i], NULL, (void *) thread, NULL);\n   getchar();\n}\n```\nAo executar esse programa, o processo criado possuirá quantos fluxos de execução (threads) no instante em que finalizar o laço for(;;)?",
  "alternativas": [
    "a) Um.",
    "b) Dois.",
    "c) Nove.",
    "d) Dez.",
    "e) Onze."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Sistemas Operacionais",
  "subarea": "Comunicação, Concorrência e Sincronização de Processos",
  "gabarito": "E",
  "atributo_rag": "fundamentos da computacao - sistemas operacionais - comunicacao, concorrencia e sincronizacao de processos"
},

{
  "id": "2018-21",
  "edicao": 2018,
  "numero": 21,
  "enunciado": "Dadas as seguintes relações de recorrência:\n\nI. $T(n) = 2T (\\frac{n}{2}) + O(n)$\\\nII. $T(n) = 8T (\\frac{n}{2}) + O(n^2)$\\\nIII. $T(n) = T (\\frac{n}{2}) + O(1)$\n\nAs relações de recorrência I, II, e III pertencem, nessa ordem, às classes de complexidade:",
  "alternativas": [
    "a) $𝛩(n^2), 𝛩(n^3),$ e $𝛩(n)$",
    "b) $𝛩(n), 𝛩(n^2),$ e $𝛩(n^3)$",
    "c) $𝛩(n log n ), 𝛩(n^3),$ e $𝛩(log n)$",
    "d) $𝛩(log n), 𝛩(n log n),$ e $𝛩(n^3)$",
    "e) $𝛩(n^2), 𝛩(n^2),$ e $𝛩(n^2)$"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Análise de Algoritmos",
  "subarea": "O Uso de Relações de Recorrência para Análise de Algoritmos Recursivos",
  "gabarito": "C",
  "atributo_rag": "fundamentos da computacao - analise de algoritmos - o uso de relacoes de recorrencia para analise de algoritmos recursivos"
},

{
  "id": "2018-22",
  "edicao": 2018,
  "numero": 22,
  "enunciado": "Dado o trecho de código\n```\n\n      int i, j, c;\n      c = 1;\n      for (i = 1; i < n; i = i*2){\n            for(j = 1; j <= n; j++){\n                  c=c+1;\n            }\n      }\n\n```\nAssumindo que a instrução $c=c+1$ é $O(1)$, a expressão que melhor define a ordem de complexidade desse trecho é:",
  "alternativas": [
    "a) $O(n$ $\\log n)$",
    "b) $O(\\log n)$",
    "c) $O(n)$",
    "d) $O(n^2)$",
    "e) $O(\\sqrt{n})$"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Análise de Algoritmos",
  "subarea": "Análise de Algoritmos Iterativos e Recursivos",
  "gabarito": "A",
  "atributo_rag": "fundamentos da computacao - analise de algoritmos - analise de algoritmos iterativos e recursivos"
},

{
  "id": "2018-23",
  "edicao": 2018,
  "numero": 23,
  "enunciado": "Selecione o menor item do vetor e, a seguir, troque-o com o item que está na primeira posição do vetor. Repita essas duas operações com os $n - 1$ itens restantes, depois com os $n - 2$ itens, até que reste apenas um elemento. Qual é o método de ordenação descrito?",
  "alternativas": [
    "a) Por seleção.",
    "b) Por inserção.",
    "c) Shellsort.",
    "d) Quicksort.",
    "e) Heapsort."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Algoritmos e Estrutura de Dados",
  "subarea": "Algoritmos para Pesquisa e Ordenação",
  "gabarito": "A",
  "atributo_rag": "fundamentos da computacao - algoritmos e estrutura de dados - algoritmos para pesquisa e ordenacao"
},

{
  "id": "2018-24",
  "edicao": 2018,
  "numero": 24,
  "enunciado": "Sobre árvores binárias, é correto afirmar que:",
  "alternativas": [
    "a) É uma árvore em que todo nó interno contém um registro e, para cada nó, a seguinte propriedade é verdadeira: todos os registros com chaves menores estão na subárvore esquerda e todos os registros com chaves maiores estão na subárvore direta.",
    "b) A altura de um nó é o comprimento do caminho mais longo deste nó até um nó folha. A altura de uma árvore é a altura do nó raiz.",
    "c) Se o nível do nó raiz de uma árvore binária é zero; se um nó está no nível i, a raiz de suas duas subárvores está no nível i+2.",
    "d) O número de subárvores de um nó é chamado de grau. Um nó de grau dois é chamado de nó externo ou nó folha.",
    "e) Para encontrar um registro que contém a chave x em uma árvore binária de pesquisa, primeiro compare-a com a chave que está na raiz. Se é menor, vá para a subárvore da direita; se é maior, vá para a subárvore da esquerda."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Algoritmos e Estrutura de Dados",
  "subarea": "Árvores e suas Generalizações: Árvores Binárias, Árvores de Busca e Árvores Balanceadas",
  "gabarito": "B",
  "atributo_rag": "fundamentos da computacao - algoritmos e estrutura de dados - arvores e suas generalizacoes: arvores binarias, arvores de busca e arvores balanceadas"
},

{
  "id": "2018-25",
  "edicao": 2018,
  "numero": 25,
  "enunciado": "Para medir o custo de execução de um algoritmo, é comum definir uma função de complexidade *f*, em que *f(n)* é a medida de tempo necessário para executar um algoritmo para um problema de tamanho *n*. Considere as afirmações abaixo sobre funções de complexidade:\n\nI. Se *f(n)* é uma medida de quantidade de tempo necessário para executar um algoritmo em um problema de tamanho *n*, então *f* é chamada função de complexidade de tempo.\\\nII. Se *f(n)* é uma medida de quantidade de memória necessária para executar um algoritmo de tamanho *n*, então *f* é chamada função de complexidade de espaço.\\\nIII. A complexidade de tempo não representa o tempo diretamente, mas é estimada pelo número de vezes que determinada operação relevante é executada.\n\nQuais estão corretas?",
  "alternativas": [
    "a) Apenas I.",
    "b) Apenas II.",
    "c) Apenas III.",
    "d) Apenas I e II.",
    "e) I, II e III."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Análise de Algoritmos",
  "subarea": "Medidas de Complexidade, Análise Assintótica de Limites de Complexidade, Técnicas de Prova de Cotas Inferiores",
  "gabarito": "E",
  "atributo_rag": "fundamentos da computacao - analise de algoritmos - medidas de complexidade, analise assintotica de limites de complexidade, tecnicas de prova de cotas inferiores"
},

{
  "id": "2018-26",
  "edicao": 2018,
  "numero": 26,
  "enunciado": "Sobre funções de transformação (hashing), analise as seguintes assertivas:\\\\\nI. Se o número de chaves N e o tamanho da tabela M são iguais, então temos uma função de transformação perfeita mínima, isto é, apenas um acesso à tabela é necessário e não há lugares vazios na tabela.\\\nII. Uma das formas de resolver as colisões é construir uma lista encadeada para cada endereço da tabela, no qual as chaves com o mesmo endereço são encadeadas em uma lista linear.\\\nIII. Uma função transformação linear ocorre quando as chaves são localizadas em um único acesso, não há espaço vazio na tabela e o processamento é realizado na ordem lexicográfica.\n\nQuais estão corretas?",
  "alternativas": [
    "a) Apenas I.",
    "b) Apenas II.",
    "c) Apenas III.",
    "d) Apenas I e II.",
    "e) I, II e III."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Algoritmos e Estrutura de Dados",
  "subarea": "Tabelas Hash",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - algoritmos e estrutura de dados - tabelas hash"
},

{
  "id": "2018-27",
  "edicao": 2018,
  "numero": 27,
  "enunciado": "Considere o seguinte código em Linguagem C:\n```\n\n      int a = 7, b = 9, c = -1;\n      int *ptr, *pty, *ptx;\n         ptr = &a;\n         ptx = &b;\n         pty = &c;\n\n         printf (\"%d %d %d %d %d %d \\n\", a, b, c,\n      *ptr, *pty, *ptx);\n         a = *ptr + *pty;\n         b = *ptx + 1;\n         printf (\"%d %d %d %d %d %d \\n\", a, b, c,\n      *ptr, *pty, *ptx);\n   \n\n```\n\nAssinale a alternativa que corresponde à saída impressa na tela.",
  "alternativas": [
    "a) 7 9 -1 7 -1 9\n   6 10 -1 7 0 9",
    "b) 7 9 -1 7 -1 9\n   6 10 -1 6 -1 10",
    "c) 7 9 -1 7 -1 9\n   6 10 -1 3 -2 9",
    "d) 7 9 -1 7 -1 9\n   6 10 -1 4 -3 10",
    "e) 7 9 -1 7 -1 9\n   6 10 -1 5 -4 10"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens de Programação",
  "subarea": "Paradigmas de Linguagens de Programação",
  "gabarito": "B",
  "atributo_rag": "fundamentos da computacao - linguagens de programacao - paradigmas de linguagens de programacao"
},

{
  "id": "2018-29",
  "edicao": 2018,
  "numero": 29,
  "enunciado": "Um algoritmo de compressão toma como entrada uma sequência de bits (bitstream), e a converte em outro bitstream, representando a entrada comprimida. Analise as assertivas abaixo sobre a técnica de compressão de Huffman:\\\\\nI. É mais eficiente, para compressão de arquivos texto, do que a técnica de codificação corrida (do inglês RLE – run-length encoding).\\\nII. A técnica exige como entradas um bitstream e um conjunto de códigos livres de prefixo, que associa símbolos a um conjunto de bits.\\\nIII. O bitstream comprimido resultante inclui o conjunto de códigos utilizado para realizar a compressão.\n\nQuais estão corretas?",
  "alternativas": [
    "a) Apenas I.",
    "b) Apenas II.",
    "c) Apenas III.",
    "d) Apenas I e II.",
    "e) Apenas I e III."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Organização de Arquivos e Dados",
  "subarea": "Compressão de Dados, Áudio, Imagem e Vídeo",
  "gabarito": "E",
  "atributo_rag": "fundamentos da computacao - organizacao de arquivos e dados - compressao de dados, audio, imagem e video"
},

{
  "id": "2018-30",
  "edicao": 2018,
  "numero": 30,
  "enunciado": "Assinale a alternativa que contém uma estrutura de controle que permite que coleções de instruções, na linguagem de programação C, sejam executadas repetidamente com o controle de execução baseado em uma expressão booleana ao invés de um contador.",
  "alternativas": [
    "a) for",
    "b) if",
    "c) while",
    "d) switch",
    "e) else"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Técnicas de Programação",
  "subarea": "Comandos de uma Linguagem de programação",
  "gabarito": "C",
  "atributo_rag": "fundamentos da computacao - tecnicas de programacao - comandos de uma linguagem de programacao"
},

{
  "id": "2018-31",
  "edicao": 2018,
  "numero": 31,
  "enunciado": "Assinale a alternativa correta em relação ao Paradigma Imperativo de Linguagens de Programação.",
  "alternativas": [
    "a) Não é baseado na arquitetura de Von Neumann.",
    "b) É paradigma de linguagens não tipadas.",
    "c) É paradigma de linguagens orientadas a objeto.",
    "d) É baseado na arquitetura de Harvard.",
    "e) Descreve uma sequência de passos que mudam o estado de um programa."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens de Programação",
  "subarea": "Paradigmas de Linguagens de Programação",
  "gabarito": "E",
  "atributo_rag": "fundamentos da computacao - linguagens de programacao - paradigmas de linguagens de programacao"
},

{
  "id": "2018-32",
  "edicao": 2018,
  "numero": 32,
  "enunciado": "Assinale a alternativa correta sobre as definições básicas de grafos.",
  "alternativas": [
    "a) Um hipergrafo é um grafo direcionado em que cada aresta conecta dois vértices apenas.",
    "b) Um grafo ponderado é um grafo não direcionado no qual todos os pares de vértices são adjacentes entre si.",
    "c) Uma floresta é um grafo não direcionado acíclico e conectado.",
    "d) Uma árvore livre é um grafo não direcionado acíclico, podendo ou não ser conectado.",
    "e) Um grafo direcionado é fortemente conectado se cada dois vértices quaisquer forem alcançáveis a partir um do outro."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Teoria dos Grafos",
  "subarea": "Grafos orientados e não-orientados",
  "gabarito": "E",
  "atributo_rag": "fundamentos da computacao - teoria dos grafos - grafos orientados e nao-orientados"
},

{
  "id": "2018-33",
  "edicao": 2018,
  "numero": 33,
  "enunciado": "Quando um programa precisa classificar uma matriz de objetos de dados numéricos de algum tipo, normalmente usa um subprograma (ou função) para o processo de classificação. No ponto em que o processo de classificação é necessário, uma instrução como sort_int(list, list_len) é colocada no programa. Essa chamada é um exemplo de abstração de:",
  "alternativas": [
    "a) Dados.",
    "b) Encapsulamento.",
    "c) Repetição.",
    "d) Condição.",
    "e) Processo."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Algoritmos e Estrutura de Dados",
  "subarea": "Modularidade e Abstração",
  "gabarito": "E",
  "atributo_rag": "fundamentos da computacao - algoritmos e estrutura de dados - modularidade e abstracao"
},

{
  "id": "2018-34",
  "edicao": 2018,
  "numero": 34,
  "enunciado": "Quanto aos métodos de alocação de espaço em disco para arquivos, analise as afirmações abaixo e assinale V, se verdadeiras, ou F, se falsas.\\\n( ) Na alocação contígua, a alocação de espaço em disco para novos arquivos pode ser dificultada pelo problema de fragmentação externa.\\\n( ) A alocação interligada provê acesso eficiente tanto a arquivos de acesso sequencial quanto de acesso direto.\\\n( ) Na alocação indexada, cada arquivo possui um bloco de índice. Para arquivos grandes, são necessários mecanismos que vinculem diferentes blocos de índices, como índices multinível, por exemplo.\n\nA ordem correta de preenchimento dos parênteses, de cima para baixo, é:",
  "alternativas": [
    "a) V – V – F.",
    "b) F – V – V.",
    "c) V – F – F.",
    "d) F – F – V.",
    "e) V – F – V."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Sistemas Operacionais",
  "subarea": "Gerenciamento de Arquivos",
  "gabarito": "E",
  "atributo_rag": "fundamentos da computacao - sistemas operacionais - gerenciamento de arquivos"
},

{
  "id": "2018-35",
  "edicao": 2018,
  "numero": 35,
  "enunciado": "As árvores B+ são estruturas usadas para indexar campos de pesquisa e tornar eficiente o acesso a registros armazenados com base nos valores destes campos. Analise as afirmações abaixo sobre árvores B+, assinalando V, se verdadeiras, ou F, se falsas.\\\n( ) Os nodos folha são geralmente ligados entre si para proporcionar acesso ordenado aos registros a partir do campo de pesquisa.\\\n( ) Todos os nodos da árvore possuem valores relativos ao campo indexado, bem como ponteiros para o registro correspondente (ou para o bloco que contém o registro).\\\n( ) Alguns valores do campo indexado que aparecem em nós folhas são repetidos em nós não folha da árvore.\n\nA ordem correta de preenchimento dos parênteses, de cima para baixo, é:",
  "alternativas": [
    "a) V – F – F.",
    "b) V – V – F.",
    "c) F – V – V.",
    "d) F – F – F.",
    "e) V – F – V."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Algoritmos e Estrutura de Dados",
  "subarea": "Árvores e suas Generalizações: Árvores Binárias, Árvores de Busca e Árvores Balanceadas",
  "gabarito": "E",
  "atributo_rag": "fundamentos da computacao - algoritmos e estrutura de dados - arvores e suas generalizacoes: arvores binarias, arvores de busca e arvores balanceadas"
},

{
  "id": "2018-36",
  "edicao": 2018,
  "numero": 36,
  "enunciado": "As arestas são exploradas a partir do vértice v mais recentemente descoberto que ainda possui arestas não exploradas saindo dele. Quando todas as arestas adjacentes a v tiverem sido exploradas, a busca anda para trás para explorar vértices que saem do vértice do qual v foi descoberto. O processo continua até que sejam descobertos todos os vértices alcançáveis a partir do vértice original. Qual algoritmo de grafos possui a estratégia descrita acima?",
  "alternativas": [
    "a) Ordenação topológica.",
    "b) Busca em profundidade.",
    "c) Componentes fortemente conectados.",
    "d) Árvore geradora mínima.",
    "e) Busca em largura."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Teoria dos Grafos",
  "subarea": "Busca em Largura e Profundidade",
  "gabarito": "B",
  "atributo_rag": "fundamentos da computacao - teoria dos grafos - busca em largura e profundidade"
},

{
  "id": "2018-37",
  "edicao": 2018,
  "numero": 37,
  "enunciado": "Sobre ordenação topológica em grafos, é correto afirmar que:",
  "alternativas": [
    "a) A busca em largura é utilizada para obter a ordenação topológica de um grafo direcionado acíclico.",
    "b) A ordenação topológica de um grafo pode ser vista como uma ordenação de suas arestas ao longo de uma linha horizontal, de tal forma que todos os vértices estão classificados em ordem crescente.",
    "c) A ordenação topológica de um grafo direcionado acíclico *G=(V,A)* é uma ordenação linear de todos os seus vértices tal que G contém uma aresta *(u, v)*, então u aparece antes de v.",
    "d) A busca binária é utilizada para obter a ordenação topológica de um grafo cíclico não direcionado.",
    "e) O algoritmo para obter a ordenação topológica de um grafo direcionado usa o transposto do grafo que consiste de todas as arestas com as suas direções invertidas."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Teoria dos Grafos",
  "subarea": "Ordenação Topológica",
  "gabarito": "C",
  "atributo_rag": "fundamentos da computacao - teoria dos grafos - ordenacao topologica"
},

{
  "id": "2018-38",
  "edicao": 2018,
  "numero": 38,
  "enunciado": "Sobre tipos de dados, é correto afirmar que:",
  "alternativas": [
    "a) Tipos booleanos são valores que são mantidos fixos pelo compilador.",
    "b) O double é um tipo inteiro duplo com menor precisão do que o tipo inteiro.",
    "c) A faixa de valores dos tipos inteiros tem somente dois elementos: um para verdadeiro e outro para falso.",
    "d) Uma conversão de tipos implícita consiste em uma modificação do tipo de dados executado,\nautomaticamente, pelo compilador.",
    "e) Vetores, matrizes e ponteiros são exemplos de tipos de dados primitivos (básicos)."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens de Programação",
  "subarea": "Teoria dos Tipos: Sistemas de Tipos, Polimorfismo",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - linguagens de programacao - teoria dos tipos: sistemas de tipos, polimorfismo"
},

{
  "id": "2018-39",
  "edicao": 2018,
  "numero": 39,
  "enunciado": "Considere os seguintes formalismos:\\\\\nI. Autômatos finitos.\\\\\nII. Autômatos finitos com uma pilha.\\\\\nIII. Autômatos finitos com duas pilhas.\n\nQuais contêm SOMENTE os formalismos nos quais a variante não determinística reconhece o mesmo conjunto de linguagens que a respectiva versão determinística?",
  "alternativas": [
    "a) Apenas I.",
    "b) Apenas II.",
    "c) Apenas I e III.",
    "d) Apenas II e III.",
    "e) I, II e III."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens Formais, Autômatos e Computabilidade",
  "subarea": "Autômatos de Estados Finitos Determinístico e não Determinístico",
  "gabarito": "C",
  "atributo_rag": "fundamentos da computacao - linguagens formais, automatos e computabilidade - automatos de estados finitos deterministico e nao deterministico"
},

{
  "id": "2018-41",
  "edicao": 2018,
  "numero": 41,
  "enunciado": "Abaixo são apresentadas duas linguagens formais sobre o alfabeto {a,b,c}:\\\nL1 = { $a^nb^n | n>1$ }\\\nL2 = { $b^na^pc^q | n \\geq 0, p \\geq 0, q \\geq 0 $}\\\nConsidere as seguintes afirmações:\\\nI. L1 é uma linguagem regular.\\\nII. L2 é uma linguagem regular.\\\nIII. L2 é uma linguagem livre de contexto.\n\nQuais estão corretas?",
  "alternativas": [
    "a) Apenas I.",
    "b) Apenas II.",
    "c) Apenas I e III.",
    "d) Apenas II e III.",
    "e) I, II e III."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens Formais, Autômatos e Computabilidade",
  "subarea": "Linguagens Regulares, Livres-de-Contexto e Sensíveis-ao-Contexto",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - linguagens formais, automatos e computabilidade - linguagens regulares, livres-de-contexto e sensiveis-ao-contexto"
},

{
  "id": "2018-42",
  "edicao": 2018,
  "numero": 42,
  "enunciado": "Um bit de paridade par ou ímpar pode ser adicionado a uma palavra de N bits para indicar se o número de bits que valem 1 na palavra é par ou ímpar. Sobre paridade e bit de paridade, analise as assertivas abaixo:\\\\\nI. Usa-se normalmente as portas lógicas OR ou NOR para calcular e gerar o bit de paridade.\\\nII. O bit de paridade par da palavra de 8 bits 00011100 é 1.\\\nIII. A palavra de 8 bits 10100011 é enviada por um canal de comunicação de dados com bit de paridade par 0. Se um dos bits da palavra inverter durante a transmissão devido a ruído, a nova paridade calculada desta palavra na chegada da transmissão será 1, e, com isso, detecta-se um erro.\\\nIV. Um bit de paridade em uma palavra de N bits é capaz de detectar até dois bits errados.\n- V. Para calcular a paridade de uma palavra de 4 bits, serão necessárias 3 portas XOR ou 3 portas XNOR.\n\nQuais estão corretas?",
  "alternativas": [
    "a) Apenas I e III.",
    "b) Apenas II e IV.",
    "c) Apenas II e V.",
    "d) Apenas II, III e V.",
    "e) I, II, III, IV e V."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Circuitos Digitais",
  "subarea": "Representação e Manipulação de Circuitos Combinatórios",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - circuitos digitais - representacao e manipulacao de circuitos combinatorios"
},

{
  "id": "2018-44",
  "edicao": 2018,
  "numero": 44,
  "enunciado": "Considere um computador no qual o interpretador do nível 0 (hardware interpretando o microcódigo) gasta 20 nanosegundos ($20$x$10^{-9}$ segundos) por microinstrução, e o interpretador do nível 1 (microcódigo interpretando a linguagem de máquina convencional) necessita de 25 microinstruções para interpretar uma instrução de máquina convencional. Um programa teste, já em linguagem de máquina convencional, leva 50 segundos para executar.\\\na) Quanto tempo levará o programa teste para executar se o tempo para executar uma microinstrução for aumentado para 30 nanosegundos?\\\nb) Quanto tempo levará o programa teste para executar se uma instrução de máquina convencional necessitar de somente 15 microinstruções para ser interpretada?",
  "alternativas": [
    "a) a) T = 60 segundos e b) 15 segundos.",
    "b) a) T = 65 segundos e b) 20 segundos.",
    "c) a) T = 70 segundos e b) 25 segundos.",
    "d) a) T = 75 segundos e b) 30 segundos.",
    "e) a) T = 80 segundos e b) 35 segundos."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Arquitetura e Organização de Computadores",
  "subarea": "Organização de Computadores: Memórias, Unidades Centrais de Processamento, Entrada e Saída",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - arquitetura e organizacao de computadores - organizacao de computadores: memorias, unidades centrais de processamento, entrada e saida"
},

{
  "id": "2018-45",
  "edicao": 2018,
  "numero": 45,
  "enunciado": "Um impasse (deadlock) pode ser definido como a condição em que todo processo, em um conjunto de processos, aguarda por um evento que somente outro processo desse conjunto poderá fazer acontecer. De acordo com Coffman et al. (1971), as condições para que ocorra um impasse (de recurso) são encadeamento circular de dois ou mais processos, exclusão mútua, posse e espera de recursos,",
  "alternativas": [
    "a) Não preempção de recursos; ao menos três destas condições presentes ao mesmo tempo.",
    "b) Não preempção de recursos; todas estas condições presentes ao mesmo tempo.",
    "c) Preempção de recursos; ao menos três destas condições presentes ao mesmo tempo.",
    "d) Preempção de recursos; todas estas condições presentes ao mesmo tempo.",
    "e) Combinação de preempção e não preempção de recursos; todas estas condições presentes ao mesmo tempo."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Sistemas Operacionais",
  "subarea": "Comunicação, Concorrência e Sincronização de Processos",
  "gabarito": "B",
  "atributo_rag": "fundamentos da computacao - sistemas operacionais - comunicacao, concorrencia e sincronizacao de processos"
},

{
  "id": "2018-46",
  "edicao": 2018,
  "numero": 46,
  "enunciado": "No sistema operacional, existem três métodos fundamentais de realizar entrada e saída (E/S). O método mais simples é chamado de E/S _________, em que se tem a CPU realizando todo o trabalho. Na E/S _________, a CPU não fica tão dedicada à rotina de E/S como no método anterior, podendo realizar outras atividades enquanto a operação de E/S está em andamento. Já a\nE/S _________ tem o menor consumo de CPU dentre os três métodos, porém, em geral, tem o menor desempenho.\n\nAssinale a alternativa que preenche, correta e respectivamente, as lacunas do trecho acima.",
  "alternativas": [
    "a) usando interrupção – programada – usando DMA",
    "b) programada – usando interrupção – usando DMA",
    "c) usando interrupção – usando DMA – programada",
    "d) usando DMA – programada – usando interrupção",
    "e) programada – usando DMA – usando interrupção"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Sistemas Operacionais",
  "subarea": "Gerenciamento de Dispositivos de Entrada/Saída",
  "gabarito": "B",
  "atributo_rag": "fundamentos da computacao - sistemas operacionais - gerenciamento de dispositivos de entrada/saida"
},

{
  "id": "2018-48",
  "edicao": 2018,
  "numero": 48,
  "enunciado": "Um computador tem uma cache de dois níveis. Suponha que 80% das referências à informação sejam atendidas pela cache de primeiro nível, 15% pela cache de segundo nível e 5% pela memória principal. Os tempos de acesso são 5 ns, 15 ns e 60 ns, respectivamente. Qual é o tempo médio de acesso do sistema?",
  "alternativas": [
    "a) 09 ns.",
    "b) 11 ns.",
    "c) 15 ns.",
    "d) 21 ns.",
    "e) 25 ns."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Arquitetura e Organização de Computadores",
  "subarea": "Organização de Computadores: Memórias, Unidades Centrais de Processamento, Entrada e Saída",
  "gabarito": "B",
  "atributo_rag": "fundamentos da computacao - arquitetura e organizacao de computadores - organizacao de computadores: memorias, unidades centrais de processamento, entrada e saida"
},

{
  "id": "2018-49",
  "edicao": 2018,
  "numero": 49,
  "enunciado": "Dado um disco com rotação de 2.400 RPM, com 120 cilindros e 6 trilhas por cilindro, cada trilha possui 16 setores e cada setor tem 512 bytes. Considerando que o tempo médio de seek é de 60 ms, o tempo de seek entre cilindros adjacente s é de 10 ms e o tempo de transferência é de 15 ms, quanto tempo será necessário para ler 10 setores?",
  "alternativas": [
    "a) 0,0485 segundos.",
    "b) 0,0685 segundos.",
    "c) 0,0885 segundos.",
    "d) 0,1285 segundos.",
    "e) 0,1485 segundos."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Arquitetura e Organização de Computadores",
  "subarea": "Organização de Computadores: Memórias, Unidades Centrais de Processamento, Entrada e Saída",
  "gabarito": "C",
  "atributo_rag": "fundamentos da computacao - arquitetura e organizacao de computadores - organizacao de computadores: memorias, unidades centrais de processamento, entrada e saida"
},

{
  "id": "2018-50",
  "edicao": 2018,
  "numero": 50,
  "enunciado": "Qual o número total de processos criados com a execução do programa a seguir?\nConsidere que todas as operações executadas serão realizadas com sucesso.\n```\n\n      int main (void){\n         unsigned long int i;\n         for(i=0; i<6;i++)\n            if( fork() >= 0 )\n               continue;\n            else break;\n      }\n\n```",
  "alternativas": [
    "a) Sete.",
    "b) Oito.",
    "c) Trinta e dois.",
    "d) Trinta e três.",
    "e) Sessenta e quatro."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Sistemas Operacionais",
  "subarea": "Gerência de Processos/Processador",
  "gabarito": "E",
  "atributo_rag": "fundamentos da computacao - sistemas operacionais - gerencia de processos/processador"
},

{
  "id": "2019-21",
  "edicao": 2019,
  "numero": 21,
  "enunciado": "Considere os seguintes algoritmos recursivos que resolvem o mesmo problema em uma entrada de tamanho n:\\\n**Algoritmo 1**: Divide o problema em 3 partes de tamanho n/4 cada e gasta um tempo adicional $O(1)$ por chamada.\\\n**Algoritmo 2**: Divide o problema em 3 partes de tamanho n/2 cada e gasta um tempo adicional $O(n^2)$ por chamada.\\\n**Algoritmo 3**: Divide o problema em 3 partes de tamanho n/3 cada e gasta um tempo adicional de\n $O(n)$ por chamada.\n\nA complexidade dos algoritmos 1, 2 e 3 é, respectivamente:",
  "alternativas": [
    "a) $\\Theta(n^{\\log_{4}3}),\\Theta(n^2),\\Theta(n \\log n)$",
    "b) $\\Theta(\\frac{n}{4}),\\Theta(\\frac{n}{2}),\\Theta(\\frac{n}{3})$",
    "c) $\\Theta(1),\\Theta(n^2),\\Theta(n)$",
    "d) $\\Theta(n^4),\\Theta(n^2),\\Theta(n^3)$",
    "e) $\\Theta(n^{\\log_{4}3}),\\Theta(n^{\\log_{2}3}),\\Theta(n^{\\log_{3}3})$"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Análise de Algoritmos",
  "subarea": "O Uso de Relações de Recorrência para Análise de Algoritmos Recursivos",
  "gabarito": "A",
  "atributo_rag": "fundamentos da computacao - analise de algoritmos - o uso de relacoes de recorrencia para analise de algoritmos recursivos"
},

{
  "id": "2019-22",
  "edicao": 2019,
  "numero": 22,
  "enunciado": "Considere as seguintes funções:\n$$\nf(n) = 2^n\n\ng(n) = n!\n\nh(n) = n^{\\log n}\n$$\n\nAssinale a alternativa correta a respeito do comportamento assintótico de $f(n)$, $g(n)$ e $h(n)$.",
  "alternativas": [
    "a) $f(n) = O(g(n)); g(n) = O(h(n)).$",
    "b) $f(n) = 𝛺(g(n)); g(n) = O(h(n)).$",
    "c) $g(n) = O(f(n)); h(n) = O(f(n)).$",
    "d) $h(n) = O(f(n)); g(n) = 𝛺(f(n)).$",
    "e) Nenhuma das anteriores."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Análise de Algoritmos",
  "subarea": "Notação “Big O”, “Little o”, “Omega” e “Theta”",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - analise de algoritmos - notacao “big o”, “little o”, “omega” e “theta”"
},

{
  "id": "2019-23",
  "edicao": 2019,
  "numero": 23,
  "enunciado": "Sobre árvores, é correto afirmar que:",
  "alternativas": [
    "a) Um nodo é interno se não tiver filhos e é externo se tiver um ou mais filhos.",
    "b) O ancestral de um nodo pode ser tanto seu ancestral direto como um ancestral do pai do nodo.",
    "c) Uma árvore é balanceada se existe uma ordem linear definida para cada nodo, isto é, podemos identificar o filho de um nodo como sendo o primeiro, segundo e assim por diante.",
    "d) Uma árvore binária é dita própria se todo nodo interno tiver um ou zero filhos.",
    "e) Se o nodo v é pai do nodo u, então dizemos que v é filho de u."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Algoritmos e Estrutura de Dados",
  "subarea": "Árvores e suas Generalizações: Árvores Binárias, Árvores de Busca e Árvores Balanceadas",
  "gabarito": "B",
  "atributo_rag": "fundamentos da computacao - algoritmos e estrutura de dados - arvores e suas generalizacoes: arvores binarias, arvores de busca e arvores balanceadas"
},

{
  "id": "2019-24",
  "edicao": 2019,
  "numero": 24,
  "enunciado": "Um procedimento recursivo é aquele que contém em sua descrição:",
  "alternativas": [
    "a) Uma prova de indução matemática.",
    "b) Duas ou mais chamadas a procedimentos externos.",
    "c) Uma ou mais chamadas a si mesmo.",
    "d) Somente chamadas externas.",
    "e) Uma ou mais chamadas a procedimentos internos."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Algoritmos e Estrutura de Dados",
  "subarea": "Recursividade: Conceito e Implementação",
  "gabarito": "C",
  "atributo_rag": "fundamentos da computacao - algoritmos e estrutura de dados - recursividade: conceito e implementacao"
},

{
  "id": "2019-25",
  "edicao": 2019,
  "numero": 25,
  "enunciado": "Considere a seguinte função em C:\n```\n\nvoid funcao(int n){\n   int i,j;\n   for (i=1; i<=n; i++)\n      for(j=1; j<log(i); j++)\n         printf(“%d”,i+j)\n}\n\n```\nA complexidade dessa função é:",
  "alternativas": [
    "a) $\\Theta(n)$",
    "b) $\\Theta(n \\log n)$",
    "c) $\\Theta(\\log n)$",
    "d) $\\Theta(n^2)$",
    "e) $\\Theta(n^2 \\log n)$"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Análise de Algoritmos",
  "subarea": "Análise de Algoritmos Iterativos e Recursivos",
  "gabarito": "B",
  "atributo_rag": "fundamentos da computacao - analise de algoritmos - analise de algoritmos iterativos e recursivos"
},

{
  "id": "2019-26",
  "edicao": 2019,
  "numero": 26,
  "enunciado": "Sobre listas, analise as assertivas abaixo:\\\\\nI. Objetos podem ser inseridos em uma pilha a qualquer momento, mas apenas o que foi inserido mais recentemente (isto é, o último) pode ser removido a qualquer momento.\\\nII. Em uma fila, os elementos podem ser inseridos a qualquer momento, mas apenas o elemento que está a mais tempo na fila pode ser removido.\\\nIII. Em uma fila, os elementos são inseridos e removidos de acordo com o princípio “o último que entra é o primeiro que sai”.\n\nQuais estão corretas?",
  "alternativas": [
    "a) Apenas I.",
    "b) Apenas II.",
    "c) Apenas III.",
    "d) Apenas I e II.",
    "e) I, II e III."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Algoritmos e Estrutura de Dados",
  "subarea": "Estruturas de Dados Lineares e suas Generalizações: Listas Ordenadas, Listas Encadeadas, Pilhas e Filas",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - algoritmos e estrutura de dados - estruturas de dados lineares e suas generalizacoes: listas ordenadas, listas encadeadas, pilhas e filas"
},

{
  "id": "2019-27",
  "edicao": 2019,
  "numero": 27,
  "enunciado": "Considere o seguinte código em Linguagem C abaixo:\n```\n\nint x = 3, y = 1, z = -5, w=-2;\nint i;\nfor (i=1; i<x; i++){\n   while (z<0){\n   ++i;\n   z++;\n         do{\n            x = x +3;\n            w++;\n         }while (w<0);\n   }\n}\n   printf(\"%d %d %d %d\", x, y, z, w);\n\n```\n\nAssinale a alternativa que corresponde à saída impressa na tela.",
  "alternativas": [
    "a) 21 1 0 4",
    "b) 3 1 -5 -2",
    "c) 2 0 -4 -1",
    "d) 9 0 -3 -2",
    "e) 1 0 9 2"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens de Programação",
  "subarea": "Paradigmas de Linguagens de Programação",
  "gabarito": "A",
  "atributo_rag": "fundamentos da computacao - linguagens de programacao - paradigmas de linguagens de programacao"
},

{
  "id": "2019-29",
  "edicao": 2019,
  "numero": 29,
  "enunciado": "Em um sistema de arquivos, é necessário gerenciar blocos de discos que estão livres,\npara que possam ser alocados a arquivos e/ou diretórios de que necessitem. Analise as técnicas abaixo:\\\\\nI. Vetor de bits, no qual cada bloco é representado por um bit.\\\nII. Lista encadeada, na qual um ponteiro mantido em memória corresponde ao endereço do primeiro bloco livre, e cada bloco contém um apontador para o próximo bloco livre.\\\nIII. Lista de contadores, em que cada elemento da lista contém um endereço de bloco e um contador representando o número de blocos contíguos a este que estão livres.\n\nQuais implementam a gerência de espaço livre em disco?",
  "alternativas": [
    "a) Apenas I.",
    "b) Apenas II.",
    "c) Apenas III.",
    "d) Apenas I e II.",
    "e) I, II e III."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Organização de Arquivos e Dados",
  "subarea": "Organização, Estrutura e Operação de Arquivos",
  "gabarito": "E",
  "atributo_rag": "fundamentos da computacao - organizacao de arquivos e dados - organizacao, estrutura e operacao de arquivos"
},

{
  "id": "2019-30",
  "edicao": 2019,
  "numero": 30,
  "enunciado": "Considere as afirmações abaixo sobre comandos em linguagens de programação:\\\\\nI. Uma declaração de variável associa um nome a um valor que, geralmente, não pode ser alterado durante a execução do programa.\\\nII. Expressões aritméticas são expressões cujos resultados são valores numéricos, inteiros ou fracionários.\\\nIII. Expressões lógicas são aquelas que têm como resultado um dos dois valores, verdadeiro ou falso.\n\nQuais estão corretas?",
  "alternativas": [
    "a) Apenas I.",
    "b) Apenas II.",
    "c) Apenas III.",
    "d) Apenas II e III.",
    "e) I, II e III."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Técnicas de Programação",
  "subarea": "Comandos de uma Linguagem de programação",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - tecnicas de programacao - comandos de uma linguagem de programacao"
},

{
  "id": "2019-31",
  "edicao": 2019,
  "numero": 31,
  "enunciado": "De acordo com a Teoria de Sistema de Tipos, classifique a função a seguir:\n```\n\nint soma(int x,int y) {\n   return x+y;\n}\n\n```",
  "alternativas": [
    "a) Função Somadora.",
    "b) Função Polimórfica.",
    "c) Função Monomórfica.",
    "d) Função Sobrecarregada.",
    "e) Função Abstrata."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens de Programação",
  "subarea": "Teoria dos Tipos: Sistemas de Tipos, Polimorfismo",
  "gabarito": "C",
  "atributo_rag": "fundamentos da computacao - linguagens de programacao - teoria dos tipos: sistemas de tipos, polimorfismo"
},

{
  "id": "2019-32",
  "edicao": 2019,
  "numero": 32,
  "enunciado": "Sobre grafos, assinale a alternativa correta.",
  "alternativas": [
    "a) Um grafo ponderado é um grafo não direcionado em que todos os pares de vértices são adjacentes,\nisto é, há arestas ligando todos os vértices entre si.",
    "b) Todo grafo completo tem pesos associados às suas arestas.",
    "c) Um caminho em um grafo é complexo se todos os vértices do caminho são distintos.",
    "d) O grau de um vértice em um grafo não direcionado é o número de arestas que incidem nele.",
    "e) Se existir um caminho c de x a y, então x é alcançável a partir de c via y."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Teoria dos Grafos",
  "subarea": "Grafos orientados e não-orientados",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - teoria dos grafos - grafos orientados e nao-orientados"
},

{
  "id": "2019-33",
  "edicao": 2019,
  "numero": 33,
  "enunciado": "Assinale a alternativa que contém uma estrutura de controle que permite que a execução de um trecho de programa dependa do fato de uma condição ser verdadeira, isto é, vinculada à execução de um ou mais comandos ao resultado obtido na avaliação de uma expressão lógica (também denominada condicional).",
  "alternativas": [
    "a) Seleção simples.",
    "b) Seleção dupla.",
    "c) Comando composto.",
    "d) Múltipla escolha.",
    "e) Seleção aninhada."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Técnicas de Programação",
  "subarea": "Desenvolvimento de algoritmos",
  "gabarito": "A",
  "atributo_rag": "fundamentos da computacao - tecnicas de programacao - desenvolvimento de algoritmos"
},

{
  "id": "2019-34",
  "edicao": 2019,
  "numero": 34,
  "enunciado": "Suponha que existem registros lógicos que agregam vários campos (atributos) e que se deseja encontrar registros com base em algum campo de pesquisa, fornecendo algum valor (chave). Considerando estruturas de dados que tornem essa busca eficiente, analise as assertivas abaixo e assinale V, se verdadeiras, ou F, se falsas.\\\n( ) Uma estrutura baseada em hash é bastante eficiente para pesquisas baseadas em chave, pois permite encontrar o(s) registro(s) correspondente(s) à chave em, no máximo, um acesso à estrutura.\\\n( ) As árvores digitais de pesquisa não tratam as chaves como elementos indivisíveis e, por isso, são adequadas em casos em que há interesse em fazer buscas sobre parte do valor da chave (ex .: prefixo).\\\n( ) Árvores binárias de pesquisa, nas quais os nodos correspondem às chaves, sempre permitem uma busca baseada em chave mais eficiente quando comparada às listas ordenadas pelas chaves.\n\nA ordem correta de preenchimento dos parênteses, de cima para baixo, é:",
  "alternativas": [
    "a) V – F – V.",
    "b) F – V – F.",
    "c) F – F – F.",
    "d) F – V – V.",
    "e) V – V – F."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Organização de Arquivos e Dados",
  "subarea": "Organização, Estrutura e Operação de Arquivos",
  "gabarito": "B",
  "atributo_rag": "fundamentos da computacao - organizacao de arquivos e dados - organizacao, estrutura e operacao de arquivos"
},

{
  "id": "2019-35",
  "edicao": 2019,
  "numero": 35,
  "enunciado": "Uma técnica de compressão de dados converte um bitstream de entrada (mensagem de entrada) em outro bitstream comprimido (mensagem comprimida). Algumas técnicas de compressão dependem de uma tabela de símbolos, definida nesse contexto como uma estrutura de dados que associa caracteres (ou sequência de caracteres) a códigos utilizados para representar a mensagem comprimida.\n\nAnalise as seguintes assertivas sobre uso de uma tabela de símbolos na técnica de compressão LZW (Lempel, Ziv e Welch) e assinale V, se verdadeiras, ou F, se falsas.\\\n( ) A tabela de símbolos associa caracteres individuais com códigos de tamanho variável (bitstreams), cujo tamanho está relacionado à frequência de um caractere. Quanto mais frequente for um caractere na mensagem original, menos bits são usados para representá-lo.\\\n( ) A tabela de símbolos é incluída no início da mensagem comprimida. Para descomprimir a mensagem, o primeiro passo é extrair essa tabela de símbolos, para então usá-la na decodificação da mensagem original. \\\n( ) Uma estrutura de dados adequada para implementação da tabela de símbolos na técnica LWZ é uma árvore trie, devido às operações que essa técnica precisa realizar sobre a tabela de símbolos para efetuar a compressão.\n\nA ordem correta de preenchimento dos parênteses, de cima para baixo, é:",
  "alternativas": [
    "a) F – V – V.",
    "b) V – V – F.",
    "c) F – F – F.",
    "d) F – F – V.",
    "e) V – F – V."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Organização de Arquivos e Dados",
  "subarea": "Compressão de Dados, Áudio, Imagem e Vídeo",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - organizacao de arquivos e dados - compressao de dados, audio, imagem e video"
},

{
  "id": "2019-36",
  "edicao": 2019,
  "numero": 36,
  "enunciado": "Um mapa rodoviário é modelado como um grafo em que os vértices representam interseções. As arestas representam segmentos de estrada entre interseções. O peso de cada aresta representa a distância entre interseções. Agora, considere que um motorista deseja obter o caminho mais curto entre duas cidades. Dado um mapa contendo as distâncias entre cada par de interseções adjacentes, como obter o caminho mais curto entre duas cidades?",
  "alternativas": [
    "a) Caminho mais curto com destino único.",
    "b) Caminho gerador mínimo de origem única.",
    "c) Caminho mais curto com origem única.",
    "d) Caminho mais curto entre todos os pares de vértices.",
    "e) Caminho gerador mínimo de origem múltipla."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Teoria dos Grafos",
  "subarea": "Algoritmos do Menor Caminho",
  "gabarito": "C",
  "atributo_rag": "fundamentos da computacao - teoria dos grafos - algoritmos do menor caminho"
},

{
  "id": "2019-37",
  "edicao": 2019,
  "numero": 37,
  "enunciado": "Dado um grafo G e um vértice de origem, qual é o algoritmo de busca que descobre todos os vértices a uma distância K do vértice origem, antes de descobrir qualquer vértice a uma distância K+1?",
  "alternativas": [
    "a) Pré-ordem.",
    "b) Largura.",
    "c) Pós-ordem.",
    "d) Profundidade.",
    "e) Simétrica."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Teoria dos Grafos",
  "subarea": "Busca em Largura e Profundidade",
  "gabarito": "B",
  "atributo_rag": "fundamentos da computacao - teoria dos grafos - busca em largura e profundidade"
},

{
  "id": "2019-38",
  "edicao": 2019,
  "numero": 38,
  "enunciado": "O programa deve ser feito de forma descendente, com a decomposição do problema inicial em módulos, de modo a dividir as ações complexas em uma sequência de ações mais simples. Essa técnica de programação é chamada de programação:",
  "alternativas": [
    "a) Abstrata.",
    "b) Interna.",
    "c) Declarativa.",
    "d) Sequencial.",
    "e) Modular."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Técnicas de Programação",
  "subarea": "Metodologia de desenvolvimento de programas",
  "gabarito": "E",
  "atributo_rag": "fundamentos da computacao - tecnicas de programacao - metodologia de desenvolvimento de programas"
},

{
  "id": "2019-39",
  "edicao": 2019,
  "numero": 39,
  "enunciado": "Seja M uma máquina de Turing sobre alfabeto $\\Sigma$. Denotamos por ACEITA(M) o conjunto de palavras aceitas por M. Uma linguagem $L \\subseteq \\Sigma*$ é denominada Turing-reconhecível quando existe uma Máquina de Turing M tal que L = ACEITA(M). Usaremos TR(L) para denotar que a linguagem L é Turing-reconhecível. Nesse sentido, analise as seguintes afirmações sobre duas linguagens L1 e L2 sobre o alfabeto $\\Sigma$:\\\nI. Se TR(L1) e TR(L2), então TR(L1 \\cup L2).\\\nII. Se TR(L1), então $TR(\\Sigma* \\ L1)$.\\\nIII. Se TR(L1) e TR(L2), então TR(L1 \\cap L2).\n\nQuais estão corretas?",
  "alternativas": [
    "a) Apenas I.",
    "b) Apenas II.",
    "c) Apenas I e III.",
    "d) Apenas II e III.",
    "e) I, II e III."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens Formais, Autômatos e Computabilidade",
  "subarea": "Máquina de Turing",
  "gabarito": "C",
  "atributo_rag": "fundamentos da computacao - linguagens formais, automatos e computabilidade - maquina de turing"
},

{
  "id": "2019-40",
  "edicao": 2019,
  "numero": 40,
  "enunciado": "Considere as seguintes afirmações sobre classes de problemas:\n\nI. O problema de decisão CAM, descrito a seguir, pertence à classe de complexidade P. \\\nCAM (caminho em grafo)\\\nEntrada: uma tripla $(G,a,b)$ em que \n- G é um grafo\n- a e b são nodos de G \\\nPergunta: Existe caminho em G iniciando em a e terminando em b? \\\nII. Um problema X pertence à classe de problemas NP-completos quando satisfaz às seguintes condições:\n- X pertence à classe NP, e\n- todo problema Y da classe NP pode ser reduzido em tempo polinomial a X. \\\nIII. Se um problema de decisão X pertence à classe P, então o complemento do problema X (problema com as mesmas instâncias que X, porém com as respectivas respostas invertidas) pertence à classe NP.\n\nQuais estão corretas?",
  "alternativas": [
    "a) Apenas I.",
    "b) Apenas III.",
    "c) Apenas I e II.",
    "d) Apenas II e III.",
    "e) I, II e III."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens Formais, Autômatos e Computabilidade",
  "subarea": "Classes de Problemas P, NP, NP Completo e NP-Difícil",
  "gabarito": "E",
  "atributo_rag": "fundamentos da computacao - linguagens formais, automatos e computabilidade - classes de problemas p, np, np completo e np-dificil"
},

{
  "id": "2019-43",
  "edicao": 2019,
  "numero": 43,
  "enunciado": "Considerando que determinado microcontrolador utiliza os endereços hexadecimais de $0020_{16}$ (inclusive) até $00FF_{16}$ (inclusive) para acesso a registradores de E/S (Entrada/Saída), a quantidade total de endereços utilizados para acesso aos registradores de E/S é de:",
  "alternativas": [
    "a) 80.",
    "b) 128.",
    "c) 160.",
    "d) 224.",
    "e) 236."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Circuitos Digitais",
  "subarea": "Análise e Síntese de Componentes Sequenciais e de Memória",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - circuitos digitais - analise e sintese de componentes sequenciais e de memoria"
},

{
  "id": "2019-44",
  "edicao": 2019,
  "numero": 44,
  "enunciado": "Utilizando o seu conhecimento sobre a arquitetura RISC, analise as sentenças abaixo:\\\n01. Arquitetura RISC suporta alinhamento arbitrário de dados para operações de leitura/escrita.\\\n02. Nenhum endereçamento indireto que requer um acesso à memória para obter o endereço de um operando na memória é considerado típico de um RISC clássico.\\\n04. Na arquitetura RISC, o número de bits para especificadores registradores inteiros é igual a quatro ou mais. Isso significa que ao menos 16 registradores inteiros podem ser explicitamente referenciados em um momento.\\\n08. Um número menor de modos de endereçamento, normalmente menos de cinco. Este parâmetro é difícil de ser determinado na arquitetura RISC.\\\n16. Arquitetura RISC suporta operação que combina leitura/escrita com aritmética (por exemplo, adicionar da memória, adicionar para memória).\\\n32. Não mais do que um operando endereçado em memória por instrução é específico da arquitetura RISC.\\\n64. Na arquitetura RISC, o tamanho é normalmente de 4 bytes.\\\nO resultado da somatória dos números correspondentes às alternativas corretas é:",
  "alternativas": [
    "a) 117.",
    "b) 110.",
    "c) 106.",
    "d) 102.",
    "e) 95."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Arquitetura e Organização de Computadores",
  "subarea": "Arquiteturas RISC e CISC",
  "gabarito": "C",
  "atributo_rag": "fundamentos da computacao - arquitetura e organizacao de computadores - arquiteturas risc e cisc"
},

{
  "id": "2019-45",
  "edicao": 2019,
  "numero": 45,
  "enunciado": "Considere o programa abaixo escrito em linguagem C. No instante da execução da linha 5, ter-se-á uma hierarquia composta de quantos processos e threads, respectivamente?\n```\n\n1    main(){\n2    int i;\n3    for(i=0;i<3;i++)\n4       fork();\n5    while(1);\n6    }\n\n```",
  "alternativas": [
    "a) 1 e 0.",
    "b) 3 e 0.",
    "c) 4 e 1.",
    "d) 7 e 7.",
    "e) 8 e 8."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Sistemas Operacionais",
  "subarea": "Gerência de Processos/Processador",
  "gabarito": "E",
  "atributo_rag": "fundamentos da computacao - sistemas operacionais - gerencia de processos/processador"
},

{
  "id": "2019-46",
  "edicao": 2019,
  "numero": 46,
  "enunciado": "Um dispositivo de E/S pode acionar o seu software controlador (device driver) para realizar uma tarefa enquanto este esteja realizando o tratamento de outra tarefa do dispositivo. Por exemplo, enquanto o device driver da placa de rede processa um pacote que acabou de chegar, ele é interrompido para tratar a chegada de um novo pacote. Essa característica de um device driver é denominada código:",
  "alternativas": [
    "a) Assíncrono.",
    "b) Assimétrico.",
    "c) Elástico.",
    "d) Reentrante.",
    "e) Recursivo."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Sistemas Operacionais",
  "subarea": "Gerenciamento de Dispositivos de Entrada/Saída",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - sistemas operacionais - gerenciamento de dispositivos de entrada/saida"
},

{
  "id": "2019-47",
  "edicao": 2019,
  "numero": 47,
  "enunciado": "Seja um circuito lógico com três entradas, A, B, C, e uma saída S. Considerando que o valor da saída S é igual ao valor da entrada A quando as entradas B e C estão no mesmo nível lógico, e que o valor da saída S é igual ao inverso do valor da entrada A quando as entradas B e C estão em níveis lógicos opostos, assinale a alternativa que apresenta a expressão lógica correspondente ao circuito.",
  "alternativas": [
    "a) $𝑆 = A \\cdot B \\oplus C$",
    "b) $𝑆 = A  \\oplus  B  \\oplus  C$",
    "c) $𝑆 = \\overline{A}  \\oplus  B  \\oplus  C$",
    "d) $𝑆 = A  \\oplus  \\overline{B  \\oplus  C}$",
    "e) $𝑆 = \\overline{A  \\oplus  B  \\oplus  C}$"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Circuitos Digitais",
  "subarea": "Representação e Manipulação de Circuitos Combinatórios",
  "gabarito": "B",
  "atributo_rag": "fundamentos da computacao - circuitos digitais - representacao e manipulacao de circuitos combinatorios"
},

{
  "id": "2019-48",
  "edicao": 2019,
  "numero": 48,
  "enunciado": "Um cientista da computação precisa avaliar o desempenho de seu computador para calcular o tempo de resposta de um algoritmo. Levando em consideração que todos os setores da trilha 0 são lidos começando do setor 0, então, todos os setores da trilha 1 a partir do setor 0, e assim por diante. O tempo de rotação é de 30 ms, e um seek gasta 20 ms entre cilindros adjacentes e 80 ms para o pior caso. A comutação entre trilhas no mesmo cilindro pode ser feita instantaneamente.\n\nDessa maneira, quanto tempo é gasto para ser lido um disco de 2.400 cilindros, cada um com seis trilhas de 32 setores em segundos?",
  "alternativas": [
    "a) 628,12.",
    "b) 480,06.",
    "c) 320,12.",
    "d) 268,06.",
    "e) 124,12."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Arquitetura e Organização de Computadores",
  "subarea": "Organização de Computadores: Memórias, Unidades Centrais de Processamento, Entrada e Saída",
  "gabarito": "B",
  "atributo_rag": "fundamentos da computacao - arquitetura e organizacao de computadores - organizacao de computadores: memorias, unidades centrais de processamento, entrada e saida"
},

{
  "id": "2019-50",
  "edicao": 2019,
  "numero": 50,
  "enunciado": "Uma partição de disco rígido é formatada com um sistema de arquivos com base em alocação encadeada, usando tabela de alocação. A formatação da partição considerou um tamanho de bloco (cluster) de 4096 bytes. Um programa executado nesse computador cria um arquivo nessa partição e grava os dados do arquivo de acordo com o trecho de código abaixo. Como resultado, o arquivo criado contém ____ bytes e ocupa ____ bytes na área de dados do sistema de arquivos.\n```\n\n...\n05    char dado;\n...\n25    for(i=0;i<1024;i++)\n27       write(fd, &dado, 1);\n28    close(fd);\n\n```\n\nAssinale a alternativa que preenche, correta e respectivamente, as lacunas do trecho acima.",
  "alternativas": [
    "a) 1024 – 1024",
    "b) 1025 – 1025",
    "c) 1024 – 4096",
    "d) 1025 – 4096",
    "e) 4096 – 4096"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Sistemas Operacionais",
  "subarea": "Gerenciamento de Arquivos",
  "gabarito": "C",
  "atributo_rag": "fundamentos da computacao - sistemas operacionais - gerenciamento de arquivos"
},

{
  "id": "2022-21",
  "edicao": 2022,
  "numero": 21,
  "enunciado": "Os algoritmos de ordenação MergeSort, da árvore geradora mínima de Kruskal, e o algoritmo Floyd-Warshall que calcula o caminho mais curto entre todos os pares de vértices de um grafo orientado com peso são, respectivamente, exemplos de algoritmos:",
  "alternativas": [
    "a) Guloso, programação dinâmica e divisão e conquista.",
    "b) Divisão e conquista, programação dinâmica e guloso.",
    "c) Guloso, divisão e conquista e programação dinâmica.",
    "d) Programação dinâmica, divisão e conquista e guloso.",
    "e) Divisão e conquista, guloso e programação dinâmica."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Análise de Algoritmos",
  "subarea": "Análise de Algoritmos Iterativos e Recursivos",
  "gabarito": "E",
  "atributo_rag": "fundamentos da computacao - analise de algoritmos - analise de algoritmos iterativos e recursivos"
},

{
  "id": "2022-22",
  "edicao": 2022,
  "numero": 22,
  "enunciado": "Considere as funções a seguir:\n$$\nf1(n) = O(n)\n\nf2(n) = O(n!)\n\nf3(n) =O(2n)\n\nf4(n) =O(n^2)\n$$\nA ordem dessas funções, por ordem crescente de taxa de crescimento, é:",
  "alternativas": [
    "a) $f2 – f1 – f3 – f4.$",
    "b) $f3 – f2 – f4 – f1.$",
    "c) $f1 – f4 – f3 – f2.$",
    "d) $f1 – f4 – f2 – f3.$",
    "e) $f4 – f3 – f1 – f2.$"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Análise de Algoritmos",
  "subarea": "Análise de Algoritmos Iterativos e Recursivos",
  "gabarito": "C",
  "atributo_rag": "fundamentos da computacao - analise de algoritmos - analise de algoritmos iterativos e recursivos"
},

{
  "id": "2022-23",
  "edicao": 2022,
  "numero": 23,
  "enunciado": "Em relação à lista linear em alocação sequencial, é correto afirmar que:",
  "alternativas": [
    "a) Para as estruturas do tipo pilha, são necessários dois ponteiros, início da pilha (i) e fim da pilha (f).\nPara a adição de um elemento, move-se o ponteiro i; para a retirada, move-se o ponteiro f.",
    "b) O armazenamento sequencial de listas é empregado quando as estruturas, ao longo do tempo, sofrem muitas inserções e remoções, acarretando a movimentação dos elementos da lista.",
    "c) Os nodos de uma lista simplesmente encadeada encontram-se aleatoriamente dispostos na memória e são interligados por ponteiros, que indicam a posição do próximo elemento da lista.",
    "d) Em uma lista sequencial, o último nodo da lista aponta para o primeiro nodo da lista.",
    "e) Para as estruturas do tipo fila, apenas um ponteiro precisa ser considerado, o ponteiro topo, pois as inserções e as remoções são executadas na mesma extremidade da lista."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Algoritmos e Estrutura de Dados",
  "subarea": "Estruturas de Dados Lineares e suas Generalizações: Listas Ordenadas, Listas Encadeadas, Pilhas e Filas",
  "gabarito": "C",
  "atributo_rag": "fundamentos da computacao - algoritmos e estrutura de dados - estruturas de dados lineares e suas generalizacoes: listas ordenadas, listas encadeadas, pilhas e filas"
},

{
  "id": "2022-24",
  "edicao": 2022,
  "numero": 24,
  "enunciado": "Qual é o método de ordenação representado por uma lista linear composta de elementos com chaves $\\text{s}_1, \\dots, \\text{s}_\\text{n},$ satisfazendo a seguinte propriedade:$\\text{s}_\\text{i} \\leq \\text{s}_{[1/2]}$, para $1$ $\\text{i} \\leq \\text{n}$\n?",
  "alternativas": [
    "a) Inserção.",
    "b) Fila de prioridade.",
    "c) Quicksort.",
    "d) Shellsort.",
    "e) Seleção."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Algoritmos e Estrutura de Dados",
  "subarea": "Algoritmos para Pesquisa e Ordenação",
  "gabarito": "B",
  "atributo_rag": "fundamentos da computacao - algoritmos e estrutura de dados - algoritmos para pesquisa e ordenacao"
},

{
  "id": "2022-25",
  "edicao": 2022,
  "numero": 25,
  "enunciado": "O tempo de execução de um algoritmo recursivo é analisado por:",
  "alternativas": [
    "a) Uma equação de recorrência que define restrições matemáticas que o tempo de execução do algoritmo deve seguir.",
    "b) Um logaritmo que se transforma em uma igualdade de potências de mesma base a cada uma das chamadas recursivas.",
    "c) Uma função randomização que define as probabilidades sobre um espaço amostral, definido como o conjunto de todos os possíveis resultados da execução de cada chamada do algoritmo.",
    "d) Uma variável aleatória que define uma função que mapeia o resultado da execução de cada chamada do algoritmo para um espaço amostral a números reais.",
    "e) Somatórios."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Análise de Algoritmos",
  "subarea": "O Uso de Relações de Recorrência para Análise de Algoritmos Recursivos",
  "gabarito": "A",
  "atributo_rag": "fundamentos da computacao - analise de algoritmos - o uso de relacoes de recorrencia para analise de algoritmos recursivos"
},

{
  "id": "2022-26",
  "edicao": 2022,
  "numero": 26,
  "enunciado": "Qual é o método de compressão de texto cujo princípio é atribuir códigos mais curtos a símbolos com frequências altas, no qual um código único é atribuído a cada símbolo diferente do texto?",
  "alternativas": [
    "a) Huffman.",
    "b) Tabela hash.",
    "c) Índice.",
    "d) Lempel-Ziv-Welch.",
    "e) Aproximação de entropia."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Algoritmos e Estrutura de Dados",
  "subarea": "Cadeias e Processamento de Cadeias",
  "gabarito": "A",
  "atributo_rag": "fundamentos da computacao - algoritmos e estrutura de dados - cadeias e processamento de cadeias"
},

{
  "id": "2022-28",
  "edicao": 2022,
  "numero": 28,
  "enunciado": "Analise o código em Linguagem C (Compilador Ansi C) abaixo e assinale a alternativa que corresponde a saída na tela.\n```\n\nint *p, **r, a = -1, c, b=10;\np = &a;\nr = &p;\nc = **r + b--;\n\nprintf(\"%d\", c);\n\n```",
  "alternativas": [
    "a) 7.",
    "b) 8.",
    "c) 9.",
    "d) 10.",
    "e) 11."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens de Programação",
  "subarea": "Paradigmas de Linguagens de Programação",
  "gabarito": "C",
  "atributo_rag": "fundamentos da computacao - linguagens de programacao - paradigmas de linguagens de programacao"
},

{
  "id": "2022-29",
  "edicao": 2022,
  "numero": 29,
  "enunciado": "Em relação à técnica de compressão corrida (Run-Length Encoding – RLE), analise as assertivas abaixo:\\\nI. Para dados alfanuméricos, tem desempenho inferior se comparada a técnicas como códigos de Huffman ou LZW.\\\nII. São bastante adequadas para bitmaps, os quais são largamente usados para representar figuras ou documentos escaneados.\\\nIII. Apresenta os melhores resultados quando existem longas sequências intercalados de bits 0 e 1 (ex: 010101010101010101 .......).\n\nQuais estão corretas?",
  "alternativas": [
    "a) Apenas I.",
    "b) Apenas II.",
    "c) Apenas III.",
    "d) Apenas I e II.",
    "e) Apenas II e III."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Organização de Arquivos e Dados",
  "subarea": "Compressão de Dados, Áudio, Imagem e Vídeo",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - organizacao de arquivos e dados - compressao de dados, audio, imagem e video"
},

{
  "id": "2022-30",
  "edicao": 2022,
  "numero": 30,
  "enunciado": "Analise as seguintes assertivas sobre tipos de dados:\\\nI. Tipos reais são utilizados para armazenar valores numéricos com parte fracionária.\\\nII. Tipos caracteres permitem armazenar um único caractere.\\\nIII. Tipos inteiros são utilizados para armazenar valores que pertencem ao conjunto dos números naturais (sem a parte fracionária).\n\nQuais estão corretas?",
  "alternativas": [
    "a) Apenas I.",
    "b) Apenas II.",
    "c) Apenas III.",
    "d) Apenas II e III.",
    "e) I, II e III."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Técnicas de Programação",
  "subarea": "Tipos de dados básicos e estruturados",
  "gabarito": "E",
  "atributo_rag": "fundamentos da computacao - tecnicas de programacao - tipos de dados basicos e estruturados"
},

{
  "id": "2022-32",
  "edicao": 2022,
  "numero": 32,
  "enunciado": "Um grafo não direcionado no qual todos os pares de vértices são adjacentes, isto é,\npossui arestas ligando todos os vértices entre si, é um grafo:",
  "alternativas": [
    "a) Desconexo.",
    "b) Completo.",
    "c) Ponderado.",
    "d) Livre.",
    "e) Hipergrafo."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Teoria dos Grafos",
  "subarea": "Conectividade",
  "gabarito": "B",
  "atributo_rag": "fundamentos da computacao - teoria dos grafos - conectividade"
},

{
  "id": "2022-33",
  "edicao": 2022,
  "numero": 33,
  "enunciado": "Sobre os testes de condições em linguagem de programação, é correto afirmar que:",
  "alternativas": [
    "a) Um teste de condição pode ser realizado através da instrução *while*.",
    "b) A componente else do *if* é obrigatório.",
    "c) *if-else* a condição é avaliada e, caso seja verdadeira, é executada a instrução associada ao else.",
    "d) *if-else* permite a existência de instruções que não são executadas em um programa.",
    "e) *if-else* não pode ser executado de forma encadeada."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Técnicas de Programação",
  "subarea": "Desenvolvimento de algoritmos",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - tecnicas de programacao - desenvolvimento de algoritmos"
},

{
  "id": "2022-34",
  "edicao": 2022,
  "numero": 34,
  "enunciado": "Analise as assertivas a seguir que comparam os métodos de alocação de espaço encadeado e indexado, usados na implementação de diretórios de arquivos:\\\nI. Assim como a alocação encadeada, a alocação indexada oferece uma solução para o problema de fragmentação externa.\\\nII. Assim como a alocação encadeada, a alocação indexada deve lidar com problemas de desempenho relacionados ao fato de que blocos de dados de cada arquivo estarem espalhados no disco.\\\nIII. A alocação indexada é mais eficiente que a alocação encadeada, porque os blocos de índices são contíguos e podem permanecer em cache memória.\n\nQuais estão corretas?",
  "alternativas": [
    "a) Apenas I.",
    "b) Apenas II.",
    "c) Apenas III.",
    "d) Apenas I e II.",
    "e) I, II e III."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Organização de Arquivos e Dados",
  "subarea": "Organização, Estrutura e Operação de Arquivos",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - organizacao de arquivos e dados - organizacao, estrutura e operacao de arquivos"
},

{
  "id": "2022-35",
  "edicao": 2022,
  "numero": 35,
  "enunciado": "Considere que um projetista deseja indexar um arquivo que contém registros com diferentes atributos numéricos. Ele deseja poder fazer buscas eficientes sobre registros baseado em valores exatos (e.g. 10), bem como por intervalos de valores (e.g. entre 10 e 20). Qual estrutura de indexação seria a mais apropriada?",
  "alternativas": [
    "a) Árvore B+.",
    "b) Árvore binária de pesquisa.",
    "c) Hash.",
    "d) Árvore AVL.",
    "e) Árvore digital de pesquisa."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Organização de Arquivos e Dados",
  "subarea": "Organização, Estrutura e Operação de Arquivos",
  "gabarito": "A",
  "atributo_rag": "fundamentos da computacao - organizacao de arquivos e dados - organizacao, estrutura e operacao de arquivos"
},

{
  "id": "2022-36",
  "edicao": 2022,
  "numero": 36,
  "enunciado": "Qual é a implementação no qual um grafo $G = (V,A)$ contendo n vértices é uma matriz n x n de bits, em que $A[i,j]$ é 1 (ou verdadeiro, no caso de booleanos) se e somente se existe um arco do vértice i para o vértice j.",
  "alternativas": [
    "a) Matriz de incidência.",
    "b) Lista de adjacência.",
    "c) Matriz de adjacência.",
    "d) Lista de incidência.",
    "e) Matriz quadrada completa."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Teoria dos Grafos",
  "subarea": "Algoritmos em grafos",
  "gabarito": "C",
  "atributo_rag": "fundamentos da computacao - teoria dos grafos - algoritmos em grafos"
},

{
  "id": "2022-37",
  "edicao": 2022,
  "numero": 37,
  "enunciado": "Qual é o algoritmo de busca em grafos no qual a busca inicia-se a partir de um nodo raiz e percorre cada caminho de forma a ir o mais longe possível antes de passar para outro caminho?",
  "alternativas": [
    "a) Topológica.",
    "b) Largura.",
    "c) Abrangência.",
    "d) Pós-ordem.",
    "e) Profundidade."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Teoria dos Grafos",
  "subarea": "Busca em Largura e Profundidade",
  "gabarito": "E",
  "atributo_rag": "fundamentos da computacao - teoria dos grafos - busca em largura e profundidade"
},

{
  "id": "2022-38",
  "edicao": 2022,
  "numero": 38,
  "enunciado": "Assinale V, se verdadeiro, ou F, se falso, em relação a uma estrutura de controle que permite que uma ação será repetida enquanto uma condição for verdadeira.\\\n( ) Seleção simples.\\\n( ) Seleção dupla.\\\n( ) Laço de repetição.\\\n( ) Múltipla escolha.\n\nA ordem correta de preenchimento dos parênteses, de cima para baixo, é:",
  "alternativas": [
    "a) F – F – V – F.",
    "b) V – F – F – V.",
    "c) F – V – F – V.",
    "d) V – F – V – F.",
    "e) F – V – V – V."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Técnicas de Programação",
  "subarea": "Desenvolvimento de algoritmos",
  "gabarito": "A",
  "atributo_rag": "fundamentos da computacao - tecnicas de programacao - desenvolvimento de algoritmos"
},

{
  "id": "2022-39",
  "edicao": 2022,
  "numero": 39,
  "enunciado": "Dado a gramática regular (G), determine qual é a expressão regular (r), tal que L(r) = L(G):\n$$\n\\begin{align*}\nS & \\rightarrow abS | S \\\\\nS & \\rightarrow a\n\\end{align*}$$",
  "alternativas": [
    "a) $r = (ab)^*a$",
    "b) $r = aba^*$",
    "c) $r = a^*(ba)$",
    "d) $r = (a+b)^*a^*$",
    "e) $r = (ab) + a$"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens Formais, Autômatos e Computabilidade",
  "subarea": "Linguagens Regulares, Livres-de-Contexto e Sensíveis-ao-Contexto",
  "gabarito": "A",
  "atributo_rag": "fundamentos da computacao - linguagens formais, automatos e computabilidade - linguagens regulares, livres-de-contexto e sensiveis-ao-contexto"
},

{
  "id": "2022-41",
  "edicao": 2022,
  "numero": 41,
  "enunciado": "Sobre o lema do bombeamento para as linguagens regulares, analise as assertivas a seguir:\\\\\nI. Se uma linguagem é Regular, então é aceita por um Autômato Finito Determinístico o qual possui um número finito e predefinido de n estados.\\\nII. Se o autômato reconhece uma entrada w de comprimento maior ou igual a n, obrigatoriamente o autômato assume algum estado q mais de uma vez, então existe um ciclo na função programa que passa por q.\\\nIII. A entrada w pode ser dividida em 3 subpalavras w = xyz tal que |xy| <= n, |y| >= 1 e onde y é a parte de w reconhecida pelo ciclo na função programa.\\\nIV. O Lema do bombeamento não pode ser utilizado para provar que uma determinada linguagem é Não Regular.\n\nQuais estão corretas?",
  "alternativas": [
    "a) Apenas I e II.",
    "b) Apenas III e IV.",
    "c) Apenas I, II e III.",
    "d) Apenas II, III e IV.",
    "e) I, II, III e IV."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens Formais, Autômatos e Computabilidade",
  "subarea": "Linguagens Regulares, Livres-de-Contexto e Sensíveis-ao-Contexto",
  "gabarito": "C",
  "atributo_rag": "fundamentos da computacao - linguagens formais, automatos e computabilidade - linguagens regulares, livres-de-contexto e sensiveis-ao-contexto"
},

{
  "id": "2022-42",
  "edicao": 2022,
  "numero": 42,
  "enunciado": "Uma expressão lógica do tipo soma de produtos está na forma canônica se cada um de seus mintermos (termos produto) contêm todas as variáveis, seja na forma direta ou na forma complementada. Assinale a alternativa que contém a expressão lógica, representada pela soma dos seus minitermos, cuja simplificação pela álgebra booleana fornece a expressão:\n$$\nx = A\\bar{B} + \\bar{B}C$$",
  "alternativas": [
    "a) $f(A, B, C) = \\Sigma m(1,3,5)$",
    "b) $f(A, B, C) = \\Sigma m(1,4,5)$",
    "c) $f(A, B, C) = \\Sigma m(2,3,5)$",
    "d) $f(A, B, C) = \\Sigma m(2,4,6)$",
    "e) $f(A, B, C) = \\Sigma m(2,5,6)$"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Circuitos Digitais",
  "subarea": "Minimização e Otimização de Funções Combinatórias",
  "gabarito": "B",
  "atributo_rag": "fundamentos da computacao - circuitos digitais - minimizacao e otimizacao de funcoes combinatorias"
},

{
  "id": "2022-44",
  "edicao": 2022,
  "numero": 44,
  "enunciado": "Considere uma memória cache com um tamanho de linha de 16 bytes e uma memória principal que requer 20 ns para transferir uma palavra de 8 bytes, para qualquer linha que seja escrita pelo menos uma vez, antes de ser retirada da cache. Qual é o número médio de vezes que a linha precisa ser escrita antes de ser retirada para que uma cache write-back seja mais eficiente do que uma cache write-through?",
  "alternativas": [
    "a) 4 vezes antes de ser trocada, então write-back é mais eficiente.",
    "b) 8 vezes antes de ser trocada, então write-back é mais eficiente.",
    "c) 12 vezes antes de ser trocada, então write-back é mais eficiente.",
    "d) 16 vezes antes de ser trocada, então write-back é mais eficiente.",
    "e) 32 vezes antes de ser trocada, então write-back é mais eficiente."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Arquitetura e Organização de Computadores",
  "subarea": "Organização de Computadores: Memórias, Unidades Centrais de Processamento, Entrada e Saída",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - arquitetura e organizacao de computadores - organizacao de computadores: memorias, unidades centrais de processamento, entrada e saida"
},

{
  "id": "2022-45",
  "edicao": 2022,
  "numero": 45,
  "enunciado": "Sistemas operacionais que utilizam o método de memória virtual usualmente reservam um espaço em memória secundária (ex. disco) denominado de “área de troca”, espaço este utilizado para realizar:",
  "alternativas": [
    "a) Caching.",
    "b) Framing.",
    "c) Pinning.",
    "d) Paging.",
    "e) Swapping."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Sistemas Operacionais",
  "subarea": "Gerenciamento de Memória: Memória Virtual, Paginação, Segmentação e “Swap”",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - sistemas operacionais - gerenciamento de memoria: memoria virtual, paginacao, segmentacao e “swap”"
},

{
  "id": "2022-46",
  "edicao": 2022,
  "numero": 46,
  "enunciado": "O programa (em linguagem C) abaixo executa em um sistema operacional da família\nUNIX. Considere que todas as rotinas invocadas no programa executam sem erro. Assinale a alternativa que indica o resultado impresso na tela pelo programa.\n```\n\nsigned int i;\nint main(void){\n   if ( fork() > 0 )\n      i++;\n   else\n      i++;\n      i++;\n   printf(\"%d \", i);\n}\n\n```",
  "alternativas": [
    "a) 1 1",
    "b) 2 2",
    "c) 3 3",
    "d) 4 4",
    "e) Indeterminado Indeterminado"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Sistemas Operacionais",
  "subarea": "Comunicação, Concorrência e Sincronização de Processos",
  "gabarito": "B",
  "atributo_rag": "fundamentos da computacao - sistemas operacionais - comunicacao, concorrencia e sincronizacao de processos"
},

{
  "id": "2022-47",
  "edicao": 2022,
  "numero": 47,
  "enunciado": "Um microcontrolador hipotético contém 3 tipos de memória: uma memória Flash,\npara armazenamento dos programas, uma memória RAM, para manipulação das variáveis de programa e uma memória EEPROM, para armazenamento de programas de longa permanência. O endereço para acessar uma posição da memória Flash é um número binário de 16 bits e, em cada endereço (posição de memória), são armazenados 16 bits. Com essas informações, analise as assertivas a seguir:\\\nI. A memória Flash possui uma capacidade de armazenamento de 128 kBytes.\\\nII. Considerando que a memória RAM possui 211 endereços e que o primeiro endereço da memória é o endereço 000, o último endereço da memória, representado em hexadecimal, é 7FF .16\\\nIII. As memórias Flash, RAM e EEPROM são exemplos de memórias não voláteis.\n\nQuais estão corretas?",
  "alternativas": [
    "a) Apenas I.",
    "b) Apenas II.",
    "c) Apenas III.",
    "d) Apenas I e II.",
    "e) I, II e III."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Circuitos Digitais",
  "subarea": "Componentes de Armazenamento",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - circuitos digitais - componentes de armazenamento"
},

{
  "id": "2022-48",
  "edicao": 2022,
  "numero": 48,
  "enunciado": "Um barramento do sistema consiste, normalmente, em cerca de 50 a centenas de linhas separadas. Cada linha recebe um significado ou função em particular. Embora existam muitos projetos de barramento diferentes, em qualquer barramento as linhas podem ser classificadas em grupos funcionais.\\\n Assinale a alternativa INCORRETA sobre barramento.",
  "alternativas": [
    "a) As linhas de dados oferecem um caminho para movimentação de dados entre os módulos do sistema. Essas linhas, coletivamente, são chamadas de barramento de dados.",
    "b) As linhas da memória servem para referenciar os dados que são armazenados na memória e fazem uma referência direta ao barramento que está em uso. Utilizado pelo acesso dos dados do disco ate a memória.",
    "c) As linhas de endereço são usadas para designar a origem ou o destino dos dados no barramento de dados. Além do mais, as linhas de endereço geralmente também são usadas para endereçar portas de E/S.",
    "d) As linhas de controle são usadas para controlar o acesso e o uso das linhas de dados e endereço.\nComo as linhas de dados e endereço são compartilhadas por todos os componentes, é preciso haver um meio de controlar seu uso.",
    "e) Todas as alternativas estão corretas."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Arquitetura e Organização de Computadores",
  "subarea": "Barramento, Comunicações, Interfaces e Periféricos",
  "gabarito": "B",
  "atributo_rag": "fundamentos da computacao - arquitetura e organizacao de computadores - barramento, comunicacoes, interfaces e perifericos"
},

{
  "id": "2022-49",
  "edicao": 2022,
  "numero": 49,
  "enunciado": "O paralelismo em nível de instruções existe quando as instruções de uma sequência são independentes e, assim, podem ser executadas em paralelo por sobreposição. Como um exemplo do conceito de paralelismo, considere dois pedaços de código (A e B) a seguir (JOUPPI, 1989):\n\n|Código A|Código B|\n|-|-|\n|`Load R1 ← R2`|`Add R3 ← R3, “1”`|\n|`Add R3 ← R3, “1”`|`Add R4 ← R3, R2`|\n|`Add R4 ← R4, R2`|`Store [R4] ← R0`|\n\nAssinale a alternativa INCORRETA a respeito do paralelismo.",
  "alternativas": [
    "a) O grau do paralelismo em nível de instruções é determinado pela frequência da dependência de dados verdadeira e das dependências procedurais no código.",
    "b) As três instruções no Código A são independentes e, na teoria, todas poderiam ser executadas em paralelo.",
    "c) As três instruções do Código B não podem ser executadas em paralelo, porque a segunda instrução usa o resultado da primeira e a terceira usa o resultado da segunda.",
    "d) O paralelismo de máquina é uma medida de desempenho, que é determinado pelo número de instruções que podem ser obtidas e executadas ao mesmo tempo de forma sequencial.",
    "e) O paralelismo em nível de instruções é também determinado pelo que Jouppi denomina como latência da operação."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Arquitetura e Organização de Computadores",
  "subarea": "Pipeline",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - arquitetura e organizacao de computadores - pipeline"
},

{
  "id": "2022-50",
  "edicao": 2022,
  "numero": 50,
  "enunciado": "Ao processar um arquivo mapeado em memória, a leitura de dados do arquivo em disco para a memória principal ocorre como resultado de uma:",
  "alternativas": [
    "a) Chamada de função (library call).",
    "b) Chamada de sistema (system call).",
    "c) Falta de página (page fault).",
    "d) Interrupção do disco (IRQ).",
    "e) Ligação simbólica (symbolic liking)."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Sistemas Operacionais",
  "subarea": "Gerenciamento de Memória: Memória Virtual, Paginação, Segmentação e “Swap”",
  "gabarito": "C",
  "atributo_rag": "fundamentos da computacao - sistemas operacionais - gerenciamento de memoria: memoria virtual, paginacao, segmentacao e “swap”"
},

{
  "id": "2023-21",
  "edicao": 2023,
  "numero": 21,
  "enunciado": "Sobre os conceitos de complexidade de algoritmos, é correto afirmar que:",
  "alternativas": [
    "a) O espaço requerido por um algoritmo sobre uma dada entrada pode ser medido pelo número de execuções de algumas operações.",
    "b) A complexidade de tempo usa como medida de desempenho a quantidade de memória necessária para a execução do algoritmo.",
    "c) A complexidade média é definida pelo crescimento da complexidade para entradas suficientemente grandes.",
    "d) A complexidade assintótica dá o valor esperado: a média dos esforços, levando em conta a probabilidade de ocorrência de cada entrada.",
    "e) A complexidade pessimista de um algoritmo fornece seu desempenho no pior caso: o pior desempenho que se pode esperar. Aqui, pode-se considerar os desempenhos sobre todas as entradas com tamanho n."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Análise de Algoritmos",
  "subarea": "Medidas de Complexidade, Análise Assintótica de Limites de Complexidade, Técnicas de Prova de Cotas Inferiores",
  "gabarito": "E",
  "atributo_rag": "fundamentos da computacao - analise de algoritmos - medidas de complexidade, analise assintotica de limites de complexidade, tecnicas de prova de cotas inferiores"
},

{
  "id": "2023-22",
  "edicao": 2023,
  "numero": 22,
  "enunciado": "Qual das seguintes afirmações é verdadeira sobre a análise de algoritmos recursivos?",
  "alternativas": [
    "a) A complexidade de tempo de um algoritmo recursivo é sempre mais rápida do que a de um algoritmo iterativo equivalente.",
    "b) A complexidade de espaço de um algoritmo recursivo é sempre menor do que a de um algoritmo iterativo equivalente.",
    "c) A análise de complexidade de um algoritmo recursivo é sempre mais fácil do que a de um algoritmo iterativo equivalente.",
    "d) Algoritmos recursivos nunca podem sofrer de problemas de estouro de pilha (stack overflow).",
    "e) A escolha adequada da estrutura de dados pode reduzir o tempo e o espaço necessários para a execução de algoritmos recursivos."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Análise de Algoritmos",
  "subarea": "Análise de Algoritmos Iterativos e Recursivos",
  "gabarito": "E",
  "atributo_rag": "fundamentos da computacao - analise de algoritmos - analise de algoritmos iterativos e recursivos"
},

{
  "id": "2023-23",
  "edicao": 2023,
  "numero": 23,
  "enunciado": "Considere o seguinte trecho de código:\n```\n\nfor (i = 1; i <= n; i++) {\n   for (j = 1; j <= m; j++) {\n      // instruções O(1)\n   }\n}\n\n```\nQual das seguintes afirmações é verdadeira sobre a complexidade assintótica desse trecho de código?",
  "alternativas": [
    "a) A complexidade é O(n) se m for uma constante, e O(m) se n for uma constante.",
    "b) A complexidade é O(n log m) se m for uma constante, e O(m log n) se n for uma constante.",
    "c) A complexidade é O(n + m) se n e m forem do mesmo tamanho.",
    "d) A complexidade é O(1) em todos os casos.",
    "e) A complexidade é O(nm) em todos os casos."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Análise de Algoritmos",
  "subarea": "Análise de Algoritmos Iterativos e Recursivos",
  "gabarito": "E",
  "atributo_rag": "fundamentos da computacao - analise de algoritmos - analise de algoritmos iterativos e recursivos"
},

{
  "id": "2023-24",
  "edicao": 2023,
  "numero": 24,
  "enunciado": "Sobre funções Hash, é correto afirmar que:",
  "alternativas": [
    "a) O método de divisão funciona em duas etapas. Na primeira etapa, multiplica-se a chave k por uma constante A na faixa 0<A<1 e extrai-se a parte fracionária de kA. Na segunda etapa, multiplica-se esse valor por m e toma-se o piso do resultado.",
    "b) Em endereçamento aberto, todos os elementos ficam na própria tabela de espelhamento. Isto é, cada entrada da tabela contém um elemento do conjunto dinâmico ou NIL. Ao procurar um elemento, examina-se sistematicamente as posições da tabela até encontrar o elemento desejado ou até confirmar que o elemento não está na tabela.",
    "c) No método de encadeamento não existe nenhuma lista e nenhum elemento fora da tabela.",
    "d) O hashing pode proporcionar excelente desempenho no pior caso, quando o conjunto de chaves é dinâmico, isto é, assim que as chaves são armazenadas na tabela, o conjunto de chaves muda automaticamente de tempos em tempos.",
    "e) No método de multiplicação, mapeia-se uma chave k para uma de m posições, tomando o resto da divisão de k por m."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Algoritmos e Estrutura de Dados",
  "subarea": "Tabelas Hash",
  "gabarito": "B",
  "atributo_rag": "fundamentos da computacao - algoritmos e estrutura de dados - tabelas hash"
},

{
  "id": "2023-25",
  "edicao": 2023,
  "numero": 25,
  "enunciado": "Sobre as árvores binárias de busca, é correto afirmar que:",
  "alternativas": [
    "a) Seja x um nó em uma árvore de busca binária. Se y é um nó na subárvore esquerda de x, então y.chave $\\ge$ x.chave. Se y é um nó na subárvore direita de x, então x.chave $\\le$ y.chave.",
    "b) A propriedade de árvore de busca que permite imprimir todas as chaves em sequência ordenada por meio de um simples algoritmo recursivo é denominada percurso de árvore em pré-ordem.",
    "c) Para excluir um nó z de uma árvore de busca binária T, se z tem apenas um filho, então simplesmente o removemos modificando seu pai de modo a substituir z por NIL como seu filho.",
    "d) Para excluir um nó z de uma árvore de busca binária T, se z tem dois filhos, então elevamos o primeiro filho para que ocupe a posição de z na árvore modificando o pai de z de modo a substituir z pelo filho de z.",
    "e) Para encontrar um nó em uma árvore de busca binária cuja chave é um mínimo, deve -se seguir os ponteiros de filhos da esquerda desde a raiz até encontrar um valor NIL."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Algoritmos e Estrutura de Dados",
  "subarea": "Árvores e suas Generalizações: Árvores Binárias, Árvores de Busca e Árvores Balanceadas",
  "gabarito": "E",
  "atributo_rag": "fundamentos da computacao - algoritmos e estrutura de dados - arvores e suas generalizacoes: arvores binarias, arvores de busca e arvores balanceadas"
},

{
  "id": "2023-26",
  "edicao": 2023,
  "numero": 26,
  "enunciado": "A ordenação ________________ determina, para cada elemento de entrada x, o número de elementos menores que x e usa essa informação para inserir o elemento x diretamente em sua posição no arranjo de saída. Por exemplo, se 17 elementos forem menores que x, então x pertence à posição de saída 18. Assinale a alternativa que preenche corretamente a lacuna do trecho acima.",
  "alternativas": [
    "a) mergesort",
    "b) quicksort",
    "c) por contagem",
    "d) por fila de prioridade",
    "e) por intercalação com sentinela"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Algoritmos e Estrutura de Dados",
  "subarea": "Algoritmos para Pesquisa e Ordenação",
  "gabarito": "C",
  "atributo_rag": "fundamentos da computacao - algoritmos e estrutura de dados - algoritmos para pesquisa e ordenacao"
},

{
  "id": "2023-27",
  "edicao": 2023,
  "numero": 27,
  "enunciado": "Quais são os valores em decimal do binário (8 bits) 10011001, considerando a representação sem sinal e em complemento de 2, respectivamente?",
  "alternativas": [
    "a) 153, -102",
    "b) 100, -101",
    "c) 153, -103",
    "d) 129, 103",
    "e) 1, -1"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Circuitos Digitais",
  "subarea": "Sistemas de Numeração e Códigos",
  "gabarito": "C",
  "atributo_rag": "fundamentos da computacao - circuitos digitais - sistemas de numeracao e codigos"
},

{
  "id": "2023-28",
  "edicao": 2023,
  "numero": 28,
  "enunciado": "Qual é o resultado da seguinte fórmula Infixo $A+B*(C-D*(E-F)-G*H)-I*3$ convertida para a notação polonesa?",
  "alternativas": [
    "a) $A+*(B*(C-(D*(E-(F-G*H-I*3)))))$",
    "b) $A+B*C-D*E-F-G*H-I*3+*-*-*-*+$",
    "c) $+*-*--*A -*ABCDEFGHI3$",
    "d) $ABCDEF-*-GH*-*+I3*-$",
    "e) $ABCDEFGHI3+*-*-*-*-$"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens Formais, Autômatos e Computabilidade",
  "subarea": "Gramáticas",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - linguagens formais, automatos e computabilidade - gramaticas"
},

{
  "id": "2023-29",
  "edicao": 2023,
  "numero": 29,
  "enunciado": "O computador tem um tempo de acesso à memória principal de 60 ns. Queremos reduzir esse tempo para 20 ns adicionando no cache. Qual a velocidade do cache (tempo de acesso) se pudermos esperar uma probabilidade de 90% de acerto?",
  "alternativas": [
    "a) 04 ns.",
    "b) 14 ns.",
    "c) 24 ns.",
    "d) 54 ns.",
    "e) 84 ns."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Arquitetura e Organização de Computadores",
  "subarea": "Organização de Memória",
  "gabarito": "C",
  "atributo_rag": "fundamentos da computacao - arquitetura e organizacao de computadores - organizacao de memoria"
},

{
  "id": "2023-30",
  "edicao": 2023,
  "numero": 30,
  "enunciado": "Considere um sistema numérico binário com 8 bits e o uso do complemento de 2\npara representação de números inteiros para a realização da operação $49_{10} - 120_{10}$\n . Com base nisso,analise as assertivas abaixo, assinalando V, se verdadeiras, ou F, se falsas.\\\n( ) O sistema numérico com essas características pode representar valores entre +255 e -256.\\\n( ) O resultado da operação será representado pelo valor $10111001_{2}$\\\n( ) Há um estouro de registro nessa operação quando feita nesse sistema.\\\n( ) A operação de subtração é realizada ao somar a representação de complemento de 2 de $120_{10}$ com a representação binária de $49_{10}.$\n\nA ordem correta de preenchimento dos parênteses, de cima para baixo, é:",
  "alternativas": [
    "a) V – F – F – V.",
    "b) V – V – F – F.",
    "c) V – F – V – F.",
    "d) F – F – V – V.",
    "e) F – V – F – V."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Circuitos Digitais",
  "subarea": "Aritmética Binária",
  "gabarito": "E",
  "atributo_rag": "fundamentos da computacao - circuitos digitais - aritmetica binaria"
},

{
  "id": "2023-33",
  "edicao": 2023,
  "numero": 33,
  "enunciado": "Considere o seguinte código em Linguagem C (Compilador Ansi C):\n```\n\nint a = 2, b = 4, c = -1;\nint *ptx, *pty, *ptz;\nptx = &a;\npty = &b;\nptz = &c;\n\nprintf (\"%d %d %d %d %d %d \\n\", a, b, c, *ptx, *pty, *ptz);\na = (*ptx) * (*pty);\nb = *ptz + 1;\n++c;\nprintf (\"%d %d %d %d %d %d \\n\", a, b, c, *ptx, *pty, *ptz);\n\n```\n\nAssinale a alternativa que corresponde à saída na tela.",
  "alternativas": [
    "a) 2 2 -1 2 4 -1\n8 -1 0 8 0 0",
    "b) 2 4 -1 2 2 -1\n2 0 -1 2 0 -1",
    "c) 2 2 -1 2 4 0\n8 0 -1 8 0 -1",
    "d) 2 4 -1 2 4 -1\n8 0 -1 8 0 -1",
    "e) 2 4 -1 2 4 -1\n8 0 0 8 0 0"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens de Programação",
  "subarea": "Paradigmas de Linguagens de Programação",
  "gabarito": "E",
  "atributo_rag": "fundamentos da computacao - linguagens de programacao - paradigmas de linguagens de programacao"
},

{
  "id": "2023-35",
  "edicao": 2023,
  "numero": 35,
  "enunciado": "Relacione a Coluna 1 à Coluna 2, associando cada Paradigma de Linguagem de\nProgramação à sua respectiva Linguagem de Programação.\\\n**Coluna 1**\\\n1.Programação Procedural.\\\n2. Programação Funcional.\\\n3. Programação de Tipos Abstratos de Dados.\\\n4. Programação Orientada a Objetos.\\\n5. Programação Declarativa.\\\n**Coluna 2**\\\n( ) CLIPS.\\\n( ) Smalltalk.\\\n( ) CLU.\\\n( ) C.\\\n( ) LISP.\n\nA ordem correta de preenchimento dos parênteses, de cima para baixo, é:",
  "alternativas": [
    "a) 1 – 2 – 3 – 4 – 5.",
    "b) 2 – 3 – 4 – 5 – 1.",
    "c) 3 – 4 – 5 – 1 – 2.",
    "d) 4 – 5 – 3 – 2 – 1.",
    "e) 5 – 4 – 3 – 1 – 2."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens de Programação",
  "subarea": "Paradigmas de Linguagens de Programação",
  "gabarito": "E",
  "atributo_rag": "fundamentos da computacao - linguagens de programacao - paradigmas de linguagens de programacao"
},

{
  "id": "2023-36",
  "edicao": 2023,
  "numero": 36,
  "enunciado": "Qual máquina de aceitação já seria capaz de reconhecer a linguagem a seguir?\n$L = \\{w \\in \\{a, b\\}* |$ w contém a mesma quantidade de a's e b's$\\}$",
  "alternativas": [
    "a) Autômato Finito.",
    "b) Autômato com Pilha Determinístico.",
    "c) Autômato com Pilha Não Determinístico.",
    "d) Máquina de Turing Decididora.",
    "e) Máquina de Turing Reconhecedora."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens Formais, Autômatos e Computabilidade",
  "subarea": "Autômatos de Pilha",
  "gabarito": "B",
  "atributo_rag": "fundamentos da computacao - linguagens formais, automatos e computabilidade - automatos de pilha"
},

{
  "id": "2023-37",
  "edicao": 2023,
  "numero": 37,
  "enunciado": "Qual é a Expressão Regular (ER) que denota a linguagem a seguir?\n$L = \\{w \\in \\{a, b\\}* | w $ não pode terminar com $ba$$\\}$",
  "alternativas": [
    "a) $\\neg ( (a \\cup b)^*ba )$",
    "b) $(a \\cup b)^*ba$",
    "c) $(a \\cup b)^* - ( (a \\cup b)^*ba )$",
    "d) $( (a \\cup b)^*(b \\cup aa) ) \\cup a \\cup \\lambda$",
    "e) A linguagem L não é regular e, portanto, não pode ser denotada por uma ER."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens Formais, Autômatos e Computabilidade",
  "subarea": "Linguagens Regulares, Livres-de-Contexto e Sensíveis-ao-Contexto",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - linguagens formais, automatos e computabilidade - linguagens regulares, livres-de-contexto e sensiveis-ao-contexto"
},

{
  "id": "2023-38",
  "edicao": 2023,
  "numero": 38,
  "enunciado": "Dada a linguagem L = {w \\in {a, b}* | *o terceiro último símbolo de w é a*}, analise as assertivas abaixo, assinalando V, se verdadeiras, ou F, se falsas.\\\n( ) O menor Autômato Finito Não Determinístico (AFND) que reconhece L tem 4 (quatro) estados.\\\n( ) O Autômato Finito Determinístico (AFD) que reconhece L tem, no mínimo, 8 (oito) estados.\\\n( ) A menor Gramática Regular (GR) que gera L tem 3 (três) não terminais.\\\n( ) O conjunto regular {a, b}*{a}{a, b}{a, b} denota L.\n\nA ordem correta de preenchimento dos parênteses, de cima para baixo, é:",
  "alternativas": [
    "a) F – F – V – V.",
    "b) V – V – V – V.",
    "c) F – V – F – V.",
    "d) V – V – F – F.",
    "e) V – F – V – F."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens Formais, Autômatos e Computabilidade",
  "subarea": "Autômatos de Estados Finitos Determinístico e não Determinístico",
  "gabarito": "B",
  "atributo_rag": "fundamentos da computacao - linguagens formais, automatos e computabilidade - automatos de estados finitos deterministico e nao deterministico"
},

{
  "id": "2023-39",
  "edicao": 2023,
  "numero": 39,
  "enunciado": "Nos arquivos ordenados, os registros são dispostos fisicamente no disco de acordo com os valores de um de seus campos: o campo de ordenação (chave). Analise as seguintes assertivas sobre arquivos ordenados:\\\nI. A leitura dos registros na ordem dos valores da chave de ordenação é mais eficiente se comparada à leitura desses registros em arquivos heap.\\\nII. Permite atender de forma eficiente condições de pesquisa sobre o campo de ordenação no formato <chave = valor> ou condição de intervalo (isto é, a chave estar no intervalo entre o valor1 e valor2).\\\nIII. Para acelerar o acesso a um registro baseado no valor de uma chave em arquivos ordenados, a melhor técnica de pesquisa é a técnica de hash.\n\nQuais estão corretas?",
  "alternativas": [
    "a) Apenas I.",
    "b) Apenas II.",
    "c) Apenas III.",
    "d) Apenas I e II.",
    "e) I, II e III."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Organização de Arquivos e Dados",
  "subarea": "Organização, Estrutura e Operação de Arquivos",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - organizacao de arquivos e dados - organizacao, estrutura e operacao de arquivos"
},

{
  "id": "2023-40",
  "edicao": 2023,
  "numero": 40,
  "enunciado": "Os sistemas operacionais mantêm várias informações sobre cada arquivo, chamadas de metadados. Assinale o atributo que NÃO é um metadado de arquivo gerenciado pelo sistema operacional.",
  "alternativas": [
    "a) Data da criação do arquivo.",
    "b) Tamanho do registro (ex.: número em bytes do registro).",
    "c) Tamanho atual do arquivo (ex.: número máximo em bytes do arquivo).",
    "d) Flag (indicador) de tipo de arquivo (ex.: sistema/normal).",
    "e) Nome dos diferentes campos lógicos representados nos registros dos arquivos (ex.: id, nome, data de nascimento, nome da mãe, RG, etc.)."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Sistemas Operacionais",
  "subarea": "Gerenciamento de Arquivos",
  "gabarito": "E",
  "atributo_rag": "fundamentos da computacao - sistemas operacionais - gerenciamento de arquivos"
},

{
  "id": "2023-41",
  "edicao": 2023,
  "numero": 41,
  "enunciado": "Um desenvolvedor de software armazenou registros representando tweets em um arquivo. Ele optou por utilizar uma árvore trie como índice desse arquivo para tornar eficientes alguns tipos de busca de tweets contendo palavras de determinada natureza. Sobre o uso de árvores trie, analise as assertivas abaixo e assinale V, se verdadeiras, ou F, se falsas.\\\n( ) São adequadas para encontrar de forma eficiente palavras exatas (por exemplo, as palavras\n“amor” e “beijo”).\\\n( ) São adequadas para encontrar de forma eficiente variações de palavras, tais como diminutivos\\\ne aumentativos (por exemplo, palavras que terminam com o sufixo “inho”, como “amorzinho”,\n“nenezinho”, “beijinho”).\n( ) São adequadas para encontrar de forma eficiente variações de palavras com o mesmo prefixo (por exemplo, as variações da palavra “amor”, como “amorzinho” e “amorzão”).\n\nA ordem correta de preenchimento dos parênteses, de cima para baixo, é:",
  "alternativas": [
    "a) F – V – V.",
    "b) F – F – V.",
    "c) V – V – V.",
    "d) V – F – F.",
    "e) V – F – V."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Algoritmos e Estrutura de Dados",
  "subarea": "Árvores e suas Generalizações: Árvores Binárias, Árvores de Busca e Árvores Balanceadas",
  "gabarito": "E",
  "atributo_rag": "fundamentos da computacao - algoritmos e estrutura de dados - arvores e suas generalizacoes: arvores binarias, arvores de busca e arvores balanceadas"
},

{
  "id": "2023-42",
  "edicao": 2023,
  "numero": 42,
  "enunciado": "Em um computador com suporte à memória virtual e paginação, quando ocorre um page fault, o sistema operacional, às vezes, precisa escolher uma página da memória principal (page frame) para dar lugar à página virtual que será carregada do disco como resultado do page fault. Dependendo do tipo de conteúdo presente na página selecionada para substituição, esse conteúdo precisa ser salvo no disco (page out) antes da substituição. Assinale a alternativa que indica uma região de memória típica de um processo, cujo conteúdo não exige salvamento prévio em casos de troca de páginas (page replacement).",
  "alternativas": [
    "a) Dados alocados dinamicamente (ex.: HEAP).",
    "b) Dados não inicializados (ex.: BSS).",
    "c) Dados inicializados (ex.: DATA).",
    "d) Código (ex.: TEXT).",
    "e) Pilha (ex.: STACK)."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Sistemas Operacionais",
  "subarea": "Gerenciamento de Memória: Memória Virtual, Paginação, Segmentação e “Swap”",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - sistemas operacionais - gerenciamento de memoria: memoria virtual, paginacao, segmentacao e “swap”"
},

{
  "id": "2023-43",
  "edicao": 2023,
  "numero": 43,
  "enunciado": "O aumento dos requisitos de paralelismo nas aplicações modernas exige mecanismos de bloqueio (locking) e sincronização cada vez mais eficientes. Nesse contexto, dois mecanismos muito usados são semáforos e spin locks. Sobre esses dois mecanismos, assinale a alternativa correta.",
  "alternativas": [
    "a) Spin locks são adequados para cenários de muita contenção entre os processos concorrentes.",
    "b) Semáforos são adequados para cenários de espera de curta duração para entrar na região crítica.",
    "c) Semáforos e spin locks são adequados, respectivamente, para cenários de baixa contenção e espera de longa duração para entrar na região crítica.",
    "d) Spin locks e semáforos são adequados para cenários de muita contenção e espera de curta duração para entrar na região crítica.",
    "e) Semáforos e spin locks são adequados, respectivamente, para cenários de muita contenção e espera de curta duração para entrar na região crítica."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Sistemas Operacionais",
  "subarea": "Comunicação, Concorrência e Sincronização de Processos",
  "gabarito": "E",
  "atributo_rag": "fundamentos da computacao - sistemas operacionais - comunicacao, concorrencia e sincronizacao de processos"
},

{
  "id": "2023-44",
  "edicao": 2023,
  "numero": 44,
  "enunciado": "Considere que o programa abaixo, escrito em Linguagem C, execute em um computador com suporte à memória virtual e segmentação paginada, tal como em sistemas baseados em Intel x86-64.\n```\n\n1       #include <stdio.h>\n2       main(){\n3       int w;\n4       printf(“%p”,&w);\n5       }\n\n```\nQuando a linha 4 é executada, o valor impresso na tela corresponde ao:",
  "alternativas": [
    "a) Endereço físico representando o segmento, a página e o offset onde se localiza a variável w.",
    "b) Endereço virtual associado ao endereço físico onde se localiza a variável w.",
    "c) Resultado do processamento realizado pela MMU (Memory Management Unit).",
    "d) Endereço da variável w no espaço de endereçamento físico do processo.",
    "e) Endereço da variável w no working set do processo."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Sistemas Operacionais",
  "subarea": "Gerenciamento de Memória: Memória Virtual, Paginação, Segmentação e “Swap”",
  "gabarito": "B",
  "atributo_rag": "fundamentos da computacao - sistemas operacionais - gerenciamento de memoria: memoria virtual, paginacao, segmentacao e “swap”"
},

{
  "id": "2023-45",
  "edicao": 2023,
  "numero": 45,
  "enunciado": "Qual é o tipo de dado que fornece uma maneira de definir e agrupar coleções de constantes nomeadas?",
  "alternativas": [
    "a) Ponto flutuante.",
    "b) Decimal.",
    "c) Enumeração.",
    "d) Booleano.",
    "e) Caracter."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens de Programação",
  "subarea": "Teoria dos Tipos: Sistemas de Tipos, Polimorfismo",
  "gabarito": "C",
  "atributo_rag": "fundamentos da computacao - linguagens de programacao - teoria dos tipos: sistemas de tipos, polimorfismo"
},

{
  "id": "2023-46",
  "edicao": 2023,
  "numero": 46,
  "enunciado": "Considere, por exemplo, que um programa precisa ordenar um vetor de objetos de dados numéricos de algum tipo e, para isso, ele usa um subprograma para o processo de ordenação. No momento em que um processo de ordenação é necessário, uma sentença como\n```sortInt(list, listLen)``` é colocada no programa. Essa chamada é uma abstração:",
  "alternativas": [
    "a) Do subprograma, no qual os únicos atributos essenciais são o nome do vetor a ser ordenado e o tipo de seus elementos.",
    "b) De código, no qual a chamada é dependente do algoritmo implementado no subprograma chamado.",
    "c) Do algoritmo que implementa o atributo essencial para o usuário, que precisa ver o nome e o protocolo do subprograma de ordenação.",
    "d) De tipo que inclui apenas a representação de dados de um tipo específico e os subprogramas que fornecem as operações para esse tipo.",
    "e) Do processo de ordenação real, cujo algoritmo não é especificado."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Técnicas de Programação",
  "subarea": "Modularidade e abstração",
  "gabarito": "E",
  "atributo_rag": "fundamentos da computacao - tecnicas de programacao - modularidade e abstracao"
},

{
  "id": "2023-47",
  "edicao": 2023,
  "numero": 47,
  "enunciado": "Nas linguagens de programação imperativas, o sinal + é usado para especificar a adição tanto de inteiros quanto de valores de ponto flutuante. Esse uso múltiplo de um operador é chamado de:",
  "alternativas": [
    "a) Conversão de tipos.",
    "b) Sobrecarga de operadores.",
    "c) Transparência referencial.",
    "d) Efeito colateral.",
    "e) Associatividade."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens de Programação",
  "subarea": "Teoria dos Tipos: Sistemas de Tipos, Polimorfismo",
  "gabarito": "B",
  "atributo_rag": "fundamentos da computacao - linguagens de programacao - teoria dos tipos: sistemas de tipos, polimorfismo"
},

{
  "id": "2023-48",
  "edicao": 2023,
  "numero": 48,
  "enunciado": "Uma família de ligações sucessivamente adjacentes, cada uma tendo uma extremidade adjacente à anterior e outra à subsequente (à exceção da primeira e da última) é um(a):",
  "alternativas": [
    "a) Circuito.",
    "b) Percurso.",
    "c) Caminho.",
    "d) Ciclo.",
    "e) Corda."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Teoria dos Grafos",
  "subarea": "Caminhos",
  "gabarito": "B",
  "atributo_rag": "fundamentos da computacao - teoria dos grafos - caminhos"
},

{
  "id": "2023-49",
  "edicao": 2023,
  "numero": 49,
  "enunciado": "Sobre os conceitos de grafos, é correto afirmar que:",
  "alternativas": [
    "a) A todo grafo não orientado G pode ser associado um grafo orientado G’ no qual cada aresta de G corresponderá, biunivocamente, a um par de arcos de sentidos opostos em G’.",
    "b) Uma ligação que envolver apenas um vértice é chamada subgrafo.",
    "c) Os elementos de V são chamados vértices e o valor n=|v| é o laço do grafo.",
    "d) Dois vértices que participam de uma ligação são ditos incidentes, termo também usado para duas ligações envolvendo um dado vértice.",
    "e) Diz-se que um grafo é orientado quando possui uma função de peso ou valor sobre as ligações entre os vértices."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Teoria dos Grafos",
  "subarea": "Grafos orientados e não-orientados",
  "gabarito": "A",
  "atributo_rag": "fundamentos da computacao - teoria dos grafos - grafos orientados e nao-orientados"
},

{
  "id": "2023-50",
  "edicao": 2023,
  "numero": 50,
  "enunciado": "A propriedade em que vértices de um subconjunto não apresentam relações de adjacência entre si é denominada de:",
  "alternativas": [
    "a) Biconexo.",
    "b) Independente.",
    "c) Instável.",
    "d) Complemento.",
    "e) Planar maximal."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Teoria dos Grafos",
  "subarea": "Coloração",
  "gabarito": "B",
  "atributo_rag": "fundamentos da computacao - teoria dos grafos - coloracao"
},

{
  "id": "2024-21",
  "edicao": 2024,
  "numero": 21,
  "enunciado": "Considere o problema de acessar os registros de um arquivo. Cada registro contém uma chave única que é utilizada para recuperar os registros do arquivo. Dada uma chave qualquer, o problema consiste em localizar o registro que contenha essa chave. O algoritmo examina os registros na ordem em que eles aparecem no arquivo, até que o registro procurado seja encontrado ou fique determinado que ele não se encontra no arquivo. Seja f uma função de complexidade tal que $f(n)$ é o número de registros consultado no arquivo, é correto afirmar que:",
  "alternativas": [
    "a) O caso médio é $f(n) = (n + 1)/2$",
    "b) O melhor caso é $f(n) = n - 1$",
    "c) O caso ótimo é $f(n) = 3n/2 - 3/2$",
    "d) O caso recorrente é $f(n) = 2(n - 1)$",
    "e) O pior caso é $f(n) = 1$"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Análise de Algoritmos",
  "subarea": "Medidas de Complexidade, Análise Assintótica de Limites de Complexidade, Técnicas de Prova de Cotas Inferiores",
  "gabarito": "A",
  "atributo_rag": "fundamentos da computacao - analise de algoritmos - medidas de complexidade, analise assintotica de limites de complexidade, tecnicas de prova de cotas inferiores"
},

{
  "id": "2024-22",
  "edicao": 2024,
  "numero": 22,
  "enunciado": "Qual é o objetivo da análise assintótica de algoritmos?",
  "alternativas": [
    "a) Analisar conjuntamente o pior caso e o caso médio de um algoritmo.",
    "b) Analisar o desempenho do algoritmo para entradas muito pequenas.",
    "c) Determinar o desempenho do algoritmo para todas as possíveis entradas.",
    "d) Analisar o desempenho do algoritmo para entradas médias.",
    "e) Analisar o comportamento do algoritmo à medida que o tamanho da entrada aumenta indefinidamente."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Análise de Algoritmos",
  "subarea": "Medidas de Complexidade, Análise Assintótica de Limites de Complexidade, Técnicas de Prova de Cotas Inferiores",
  "gabarito": "E",
  "atributo_rag": "fundamentos da computacao - analise de algoritmos - medidas de complexidade, analise assintotica de limites de complexidade, tecnicas de prova de cotas inferiores"
},

{
  "id": "2024-23",
  "edicao": 2024,
  "numero": 23,
  "enunciado": "Assinale a alternativa que apresenta a complexidade de tempo da busca em uma tabela hash, considerando a complexidade média e do pior caso, respectivamente.",
  "alternativas": [
    "a) $O(1)$ e $O(1)$.",
    "b) $O(1)$ e $O(n)$.",
    "c) $O(log n)$ e $O(log n)$.",
    "d) $O(log n)$ e $O(n)$.",
    "e) $O(n)$ e $O(2^n)$."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Análise de Algoritmos",
  "subarea": "Medidas de Complexidade, Análise Assintótica de Limites de Complexidade, Técnicas de Prova de Cotas Inferiores",
  "gabarito": "B",
  "atributo_rag": "fundamentos da computacao - analise de algoritmos - medidas de complexidade, analise assintotica de limites de complexidade, tecnicas de prova de cotas inferiores"
},

{
  "id": "2024-24",
  "edicao": 2024,
  "numero": 24,
  "enunciado": "Em uma estrutura de dados lista ______________________, cada elemento armazena um ou vários dados e um ponteiro para o próximo elemento, que permite o encadeamento e mantém a estrutura linear. Tem-se também um campo-chave através do qual uma determinada ordenação é mantida.\n\nAssinale a alternativa que preenche corretamente a lacuna do trecho acima.",
  "alternativas": [
    "a) duplamente encadeada ordenada",
    "b) circular não ordenada",
    "c) de prioridades",
    "d) duplamente encadeada não ordenada",
    "e) simplesmente encadeada ordenada"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Algoritmos e Estrutura de Dados",
  "subarea": "Estruturas de Dados Lineares e suas Generalizações: Listas Ordenadas, Listas Encadeadas, Pilhas e Filas",
  "gabarito": "E",
  "atributo_rag": "fundamentos da computacao - algoritmos e estrutura de dados - estruturas de dados lineares e suas generalizacoes: listas ordenadas, listas encadeadas, pilhas e filas"
},

{
  "id": "2024-25",
  "edicao": 2024,
  "numero": 25,
  "enunciado": "Sobre as instruções de repetição de uma linguagem de programação, assinale a alternativa correta.",
  "alternativas": [
    "a) Na instrução **while (condição) instrução**, a instrução é executada uma ou mais vezes e a condição é testada depois da instrução.",
    "b) O corpo do laço **do...while** é executado pelo menos uma vez, enquanto nos laços while e for o corpo do laço pode nunca ser executado (caso a condição seja falsa a priori).",
    "c) A instrução **if** adapta-se a situações em que o número de iterações é conhecido a priori.",
    "d) A instrução **break**, quando presente dentro de um laço de repetição, passa o laço para a próxima iteração.",
    "e) Na instrução **for (carga inicial; condição; pos-instrução) instrução**, a instrução é executada zero ou mais vezes e a condição é testada depois da instrução."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Técnicas de Programação",
  "subarea": "Comandos de uma Linguagem de programação",
  "gabarito": "B",
  "atributo_rag": "fundamentos da computacao - tecnicas de programacao - comandos de uma linguagem de programacao"
},

{
  "id": "2024-26",
  "edicao": 2024,
  "numero": 26,
  "enunciado": "No caminhamento ____________ de uma árvore T, a raiz de T é visitada em primeiro lugar, e então as subárvores enraizadas nos seus filhos são percorridas recursivamente. Se a árvore\né ordenada, então as subárvores são percorridas de acordo com a ordem dos filhos.\n\nAssinale a alternativa que preenche corretamente a lacuna do trecho acima.",
  "alternativas": [
    "a) simétrico",
    "b) em largura",
    "c) central",
    "d) pré-fixado",
    "e) pós-fixado"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Algoritmos e Estrutura de Dados",
  "subarea": "Árvores e suas Generalizações: Árvores Binárias, Árvores de Busca e Árvores Balanceadas",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - algoritmos e estrutura de dados - arvores e suas generalizacoes: arvores binarias, arvores de busca e arvores balanceadas"
},

{
  "id": "2024-27",
  "edicao": 2024,
  "numero": 27,
  "enunciado": "Considerando uma memória cache que usa mapeamento por conjunto associativo que contém 64 linhas divididas em 16 conjuntos, e uma memória principal que contém 4K blocos de\n128 palavras cada, quantos bits serão necessários para endereçar uma palavra e qual tamanh o,\ntambém em bits, dos campos endereço, tag, s, d e w?",
  "alternativas": [
    "a) Endereço total de 19 bits, com tag = 8 bits, s = 12 bits, d = 4 bits e w = 7 bits.",
    "b) Endereço total de 19 bits, com tag = 12 bits, s = 7 bits, d = 4 bits e w = 12 bits.",
    "c) Endereço total de 23 bits, com tag = 7 bits, s = 4 bits, d = 7 bits e w = 12 bits.",
    "d) Endereço total de 19 bits, com tag = 8 bits, s = 12 bits, d = 7 bits e w = 4 bits.",
    "e) Endereço total de 21 bits, com tag = 4 bits, s = 5 bits, d = 7 bits e w = 9 bits."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Arquitetura e Organização de Computadores",
  "subarea": "Organização de Memória",
  "gabarito": "A",
  "atributo_rag": "fundamentos da computacao - arquitetura e organizacao de computadores - organizacao de memoria"
},

{
  "id": "2024-28",
  "edicao": 2024,
  "numero": 28,
  "enunciado": "A ponte norte e a ponte sul são chipsets que compõem a estrutura de uma placa-mãe de um computador. Sobre esses dois chipsets, analise as assertivas abaixo:\\\nI. A ponte norte é responsável pela comunicação entre o processador e dispositivos de entrada/saída de baixa velocidade, enquanto a ponte sul conecta a memória RAM e a placa de vídeo.\\\nII. A ponte sul conecta o processador diretamente à memória RAM e à placa de vídeo, enquanto a ponte norte lida com dispositivos de armazenamento e periféricos de entrada/saída.\\\nIII. A ponte norte faz a interface entre o processador e componentes de alta velocidade como a memória RAM e a placa de vídeo, enquanto a ponte sul gerencia conexões com dispositivos de entrada/saída de menor velocidade.\\\nIV. A ponte norte e a ponte sul são substituíveis e podem ser usadas indistintamente em qualquer função dentro do sistema de barramento do computador.\n\nQuais estão corretas?",
  "alternativas": [
    "a) Apenas I.",
    "b) Apenas II.",
    "c) Apenas III.",
    "d) Apenas I e II.",
    "e) Apenas III e IV."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Arquitetura e Organização de Computadores",
  "subarea": "Organização de Computadores: Memórias, Unidades Centrais de Processamento, Entrada e Saída",
  "gabarito": "C",
  "atributo_rag": "fundamentos da computacao - arquitetura e organizacao de computadores - organizacao de computadores: memorias, unidades centrais de processamento, entrada e saida"
},

{
  "id": "2024-29",
  "edicao": 2024,
  "numero": 29,
  "enunciado": "Qual dos seguintes métodos permite a transferência de dados entre um dispositivo de entrada e saída e a memória principal sem o intermédio da CPU?",
  "alternativas": [
    "a) Polling.",
    "b) Interrupções.",
    "c) E/S mapeada em memória.",
    "d) Direct Memory Access (DMA).",
    "e) E/S programada."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Arquitetura e Organização de Computadores",
  "subarea": "Organização de Computadores: Memórias, Unidades Centrais de Processamento, Entrada e Saída",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - arquitetura e organizacao de computadores - organizacao de computadores: memorias, unidades centrais de processamento, entrada e saida"
},

{
  "id": "2024-30",
  "edicao": 2024,
  "numero": 30,
  "enunciado": "Dada a função $F(A,B,C) = A\\bar{C} + A\\bar{B}C + A(B + C)$, assinale a alternativa que contém a expressão lógica de $F(A,B,C)$, utilizando a notação canônica da soma de mintermos.",
  "alternativas": [
    "a) $\\Sigma m(5, 6, 7, 8)$",
    "b) $\\Sigma m(0, 1, 2, 3)$",
    "c) $\\Sigma m(4, 5, 6, 7)$",
    "d) $\\Sigma m(1, 2, 5, 6, 7)$",
    "e) $\\Sigma m(0, 3, 4, 5, 6, 7)$"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Circuitos Digitais",
  "subarea": "Representação e Manipulação de Circuitos Combinatórios",
  "gabarito": "C",
  "atributo_rag": "fundamentos da computacao - circuitos digitais - representacao e manipulacao de circuitos combinatorios"
},

{
  "id": "2024-31",
  "edicao": 2024,
  "numero": 31,
  "enunciado": "Dada a função $F(W, X, Y, Z)$ composta dos termos mínimos\n(minterm) = {4, 8, 9, 10, 13, 14} e dos termos não essenciais (don’t care) = {5, 6, 7}, simplifique essa função como produto de somas.",
  "alternativas": [
    "a) $(W+X)*( \\bar{W} + \\bar{X} + Y + Z)*( \\bar{Y} + \\bar{Z})$",
    "b) $(W+ \\bar{X}+ \\bar{Z})*(W+X+ \\bar{Z} )*(\\bar{W} + \\bar{X})*(\\bar{Y} + Z)$",
    "c) $(\\bar{W} + X)*(W+Y+ \\bar{Z})*(W+\\bar{Y}+Z)* *(W+\\bar{X}+ \\bar{Y})$",
    "d) $(W+X)*(\\bar{W} + \\bar{Y} + \\bar{Z})$",
    "e) $(W+X)*(\\bar{W} + \\bar{Y} + \\bar{Z})*(\\bar{W} + \\bar{X} + Y + Z)$"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Circuitos Digitais",
  "subarea": "Minimização e Otimização de Funções Combinatórias",
  "gabarito": "A",
  "atributo_rag": "fundamentos da computacao - circuitos digitais - minimizacao e otimizacao de funcoes combinatorias"
},

{
  "id": "2024-33",
  "edicao": 2024,
  "numero": 33,
  "enunciado": "Analise o código em Linguagem C (Compilador Ansi C) abaixo:\n```\nint main() {\n   int valor1 = 12;\n   int *valor2;\n   int cont = 0;\n      valor2 = &valor1;\n\n      do{\n         valor1 >>= 1;\n         cont++;\n      }while (*valor2>0);\n      printf (\"%d\",cont);\n}\n```\nA saída do programa na tela é o número:",
  "alternativas": [
    "a) 2.",
    "b) 3.",
    "c) 4.",
    "d) 5.",
    "e) 6."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens de Programação",
  "subarea": "Paradigmas de Linguagens de Programação",
  "gabarito": "C",
  "atributo_rag": "fundamentos da computacao - linguagens de programacao - paradigmas de linguagens de programacao"
},

{
  "id": "2024-34",
  "edicao": 2024,
  "numero": 34,
  "enunciado": "Analise o código em Linguagem C (Compilador Ansi C) abaixo:\n```\nint f_rec(char s[]) {\n   if (s[0] == '\\0') {\n      return 0;\n   }\n   return 1 + f_rec(s + 1);\n}\n\nint main() {\n   char str[] = \"Ola mundo!\";\n   int var = f_rec(str);\n   double resultado = var / 2;\n   printf(\"%f\\n\", resultado);\n   return 0;\n}\n```\nConsiderando o código apresentado, assinale a alternativa correta.",
  "alternativas": [
    "a) A saída é o número de caracteres de “str” dividido por 2, mostrado como um número de ponto flutuante.",
    "b) A saída é o número de caracteres de “str” dividido por 2, mostrado como um inteiro.",
    "c) O código tem um erro de tipos porque a função f_rec não pode aceitar um char array.",
    "d) O código tem um erro de tipos porque var é um inteiro, mas é usado em uma operação de divisão com double.",
    "e) O código tem um erro de tipos porque a função printf está usando o especificador de formato errado."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens de Programação",
  "subarea": "Paradigmas de Linguagens de Programação",
  "gabarito": "A",
  "atributo_rag": "fundamentos da computacao - linguagens de programacao - paradigmas de linguagens de programacao"
},

{
  "id": "2024-36",
  "edicao": 2024,
  "numero": 36,
  "enunciado": "Qual das seguintes linguagens pode ser gerada por uma gramática regular?",
  "alternativas": [
    "a) {w \\in {a, b}* | o número de **a’s** em w é maior que o número de **b’s**}.",
    "b) {w \\in {a, b}* | o número de **a’s** em w é o dobro do número de **b’s**}.",
    "c) {w \\in {a, b}* | o número de **a’s** em w é divisível por 3 e o número de **b’s** é ímpar}.",
    "d) {w \\in {a, b}* | w contém o mesmo número de **a’s** e **b’s**}.",
    "e) {w \\in {a, b}* | w contém números diferentes de **a’s** e **b’s**}."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens Formais, Autômatos e Computabilidade",
  "subarea": "Linguagens Regulares, Livres-de-Contexto e Sensíveis-ao-Contexto",
  "gabarito": "C",
  "atributo_rag": "fundamentos da computacao - linguagens formais, automatos e computabilidade - linguagens regulares, livres-de-contexto e sensiveis-ao-contexto"
},

{
  "id": "2024-37",
  "edicao": 2024,
  "numero": 37,
  "enunciado": "Sobre as linguagens formais, os autômatos e a computabilidade, analise as assertivas abaixo:\\\nI. Um autômato finito não determinístico pode ter transições vazias ($\\epsilon$-transições), enquanto um autômato finito determinístico não pode.\\\nII. As Máquinas de Turing são sempre determinísticas.\\\nIII. O autômato com pilha aceita a classe de linguagens regulares.\\\nIV. Os problemas NP-completos são um subconjunto dos problemas NP.\nQuais estão corretas?",
  "alternativas": [
    "a) Apenas I.",
    "b) Apenas IV.",
    "c) Apenas I e II.",
    "d) Apenas II e III.",
    "e) Apenas III e IV."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens Formais, Autômatos e Computabilidade",
  "subarea": "Autômatos de Estados Finitos Determinístico e não Determinístico",
  "gabarito": "E",
  "atributo_rag": "fundamentos da computacao - linguagens formais, automatos e computabilidade - automatos de estados finitos deterministico e nao deterministico"
},

{
  "id": "2024-38",
  "edicao": 2024,
  "numero": 38,
  "enunciado": "O __________________, de __________________, demonstra limitações dos sistemas formais e a impossibilidade de provar certas afirmações dentro deles. Já o\n__________________, de __________________, pergunta se um determinado programa irá\neventualmente parar ou entrar em um loop infinito para uma entrada dada. Ambos os resultados destacam a existência de limites fundamentais para o que podemos provar em sistemas formais ou calcular em sistemas computacionais.\n\nAssinale a alternativa que preenche, correta e respectivamente, as lacunas do trecho acima.",
  "alternativas": [
    "a) Teorema da Incompletude – Alan Turing – Problema da Parada – Kurt Gödel",
    "b) Teorema da Incompletude – Kurt Gödel – Problema da Parada – Alan Turing",
    "c) Problema da Parada – Alan Turing – Teorema da Incompletude – Kurt Gödel",
    "d) Problema da Parada – Kurt Gödel – Teorema da Incompletude – Alonzo Church",
    "e) Teorema da Incompletude – Alonzo Church – Problema da Parada – Alan Turing"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens Formais, Autômatos e Computabilidade",
  "subarea": "Problemas Indecidíveis",
  "gabarito": "B",
  "atributo_rag": "fundamentos da computacao - linguagens formais, automatos e computabilidade - problemas indecidiveis"
},

{
  "id": "2024-39",
  "edicao": 2024,
  "numero": 39,
  "enunciado": "Considerando o conceito de arquivos e registros, assinale a alternativa correta sobre a estrutura de armazenamento e recuperação de informações em memória secundária.",
  "alternativas": [
    "a) Um arquivo é um conjunto de dados de diferentes tipos, e cada item individual de informação dentro de um arquivo é chamado de byte.",
    "b) Um programa não pode ser considerado um arquivo, pois ele é executável e não segue a mesma estrutura de arquivos de dados.",
    "c) Na memória secundária, o sistema operacional armazena informações em grupos, chamados blocos, para aumentar a eficiência na transferência de dados entre a memória secundária e a memória principal.",
    "d) A estrutura de armazenamento em memória secundária não utiliza o conceito de arquivos e registros, mas sim páginas e segmentos.",
    "e) Na memória secundária, os dados são armazenados exclusivamente em formato não hierárquico,\no que impede a organização dos arquivos em pastas ou diretórios."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Organização de Arquivos e Dados",
  "subarea": "Organização, Estrutura e Operação de Arquivos",
  "gabarito": "C",
  "atributo_rag": "fundamentos da computacao - organizacao de arquivos e dados - organizacao, estrutura e operacao de arquivos"
},

{
  "id": "2024-40",
  "edicao": 2024,
  "numero": 40,
  "enunciado": "Considerando a compressão de dados, assinale a alternativa correta.",
  "alternativas": [
    "a) A compressão de dados pode ser alcançada atribuindo descrições curtas aos resultados mais frequentes da fonte de dados e necessariamente descrições mais longas aos resultados menos frequentes.",
    "b) A compressão de dados pode ser alcançada atribuindo descrições de comprimento uniforme a todos os resultados da fonte de dados.",
    "c) A desigualdade de Kraft afirma que os comprimentos dos códigos não precisam seguir qualquer padrão específico.",
    "d) A codificação de Huffman é uma técnica fundamental em compressão de dados que minimiza o tamanho da mensagem codificada, porém tem perda de informação.",
    "e) A compressão de dados sempre resulta em uma perda de qualidade, independentemente do algoritmo utilizado."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Organização de Arquivos e Dados",
  "subarea": "Compressão de Dados, Áudio, Imagem e Vídeo",
  "gabarito": "A",
  "atributo_rag": "fundamentos da computacao - organizacao de arquivos e dados - compressao de dados, audio, imagem e video"
},

{
  "id": "2024-41",
  "edicao": 2024,
  "numero": 41,
  "enunciado": "Considerando o papel de um esquema de classificação em sistemas de gestão de registros, analise as assertivas abaixo e assinale a alternativa correta.\\\nI. O esquema apenas determina a identidade dos arquivos em sistemas baseados em papel.\\\nII. Esquemas de classificação são irrelevantes para a conformidade regulatória e legal em sistemas de gestão de registros.\\\nIII. O esquema determina a identidade e o lugar de cada arquivo, tanto em sistemas baseados em papel quanto em sistemas de registros eletrônicos, e em sistemas híbridos onde ambos existem.\\\nIV. A classificação em sistemas de gestão de registros é realizada apenas no momento da criaçã o do registro e nunca é revisada ou atualizada posteriormente.\nV. Todos os sistemas de gestão de registros utilizam exclusivamente métodos manuais para a classificação de documentos, garantindo assim maior precisão e controle.",
  "alternativas": [
    "a) Todas as assertivas estão corretas.",
    "b) Todas as assertivas estão incorretas.",
    "c) Apenas a assertiva III está correta.",
    "d) Apenas a assertiva V está correta.",
    "e) Apenas as assertivas II e IV estão corretas."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Organização de Arquivos e Dados",
  "subarea": "Organização, Estrutura e Operação de Arquivos",
  "gabarito": "C",
  "atributo_rag": "fundamentos da computacao - organizacao de arquivos e dados - organizacao, estrutura e operacao de arquivos"
},

{
  "id": "2024-42",
  "edicao": 2024,
  "numero": 42,
  "enunciado": "No sistema operacional, o gerenciamento de E/S é implementado em várias camadas.\nUm dispositivo de E/S notifica que realizou uma operação se comunicando diretamente com a camada de ___________________, usualmente via APIC, a qual informa a camada de\n___________________ sobre o resultado da operação. Quando o sistema operacional precisa programar o dispositivo de E/S para realizar uma operação, a camada de ___________________ se comunica diretamente com o dispositivo.\n\nAssinale a alternativa que preenche, correta e respectivamente, as lacunas do trecho acima.",
  "alternativas": [
    "a) controladores de dispositivo – chamada de sistemas – tratadores de interrupção",
    "b) tratadores de interrupção – controladores de dispositivo – chamada de sistemas",
    "c) software independente de dispositivo – tratadores de interrupção – controladores de dispositivo",
    "d) controladores de dispositivo – software independente de dispositivo – chamada de sistemas",
    "e) tratadores de interrupção – controladores de dispositivo – controladores de dispositivo"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Sistemas Operacionais",
  "subarea": "Gerenciamento de Dispositivos de Entrada/Saída",
  "gabarito": "E",
  "atributo_rag": "fundamentos da computacao - sistemas operacionais - gerenciamento de dispositivos de entrada/saida"
},

{
  "id": "2024-43",
  "edicao": 2024,
  "numero": 43,
  "enunciado": "Analise a execução a seguir considerando que todos os arquivos de cabeçalho necessários estão inclusos no tempo de compilação e que o programa executa ininterruptamente do início até o seu término.\n```\nint lbm = 0;\n\nvoid * func(void *i){ lbm = lbm + 1; }\n\nint main (void){\n   int i;\n   pthread_t t[10];\n\n   for(i=0;i<10;i++){\n      pthread_create(&t[i], NULL, func, NULL);\n\n   for(i=0;i<10;i++){\n      pthread_join(t[i], NULL);\n\n   printf(“%d”, lbm);\n}\n```\n\nAssinale a alternativa que melhor representa o resultado da execução do programa acima.",
  "alternativas": [
    "a) lbm = 1",
    "b) lbm = 9",
    "c) lbm \\leq 10",
    "d) lbm = 10",
    "e) lbm \\geq 10"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Técnicas de Programação",
  "subarea": "Desenvolvimento de algoritmos",
  "gabarito": "C",
  "atributo_rag": "fundamentos da computacao - tecnicas de programacao - desenvolvimento de algoritmos"
},

{
  "id": "2024-44",
  "edicao": 2024,
  "numero": 44,
  "enunciado": "Um computador precisa ter seu disco atual, formatado com uma única partição,\nsubstituído por outro disco. Antes de realizar a troca, foi realizada uma análise do tamanho dos arquivos armazenados no disco atual, cujo resultado indicou que 98% dos arquivos possuem tamanho entre 1.000 bytes e 2.030 bytes (mediana de 1.515 bytes). Assinale a alternativa que lista os parâmetros de formação do novo disco e que resulte no menor desperdício de espaço físico e menor probabilidade de fragmentação do disco.",
  "alternativas": [
    "a) Tamanho de bloco = 1.024 bytes e sistema de arquivos baseado em alocação encadeada.",
    "b) Tamanho de bloco = 1.024 bytes e sistema de arquivos baseado em alocação contígua.",
    "c) Tamanho de bloco = 1.024 bytes e sistema de arquivos baseado em alocação indexada.",
    "d) Tamanho de bloco = 2.048 bytes e sistema de arquivos baseado em alocação encadeada.",
    "e) Tamanho de bloco = 2.048 bytes e sistema de arquivos baseado em alocação contígua."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Sistemas Operacionais",
  "subarea": "Gerenciamento de Arquivos",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - sistemas operacionais - gerenciamento de arquivos"
},

{
  "id": "2024-45",
  "edicao": 2024,
  "numero": 45,
  "enunciado": "Sobre os tipos de dados básicos, assinale a alternativa correta.",
  "alternativas": [
    "a) As variáveis do tipo inteiro são utilizadas para armazenar valores que pertencem ao conjunto de números naturais (sem parte fracionária) positivos e negativos.",
    "b) O tipo caractere permite armazenar strings ou conjuntos de caracteres em uma variável do tipo caracter.",
    "c) Por padrão, uma variável do tipo inteiro admite somente valores positivos. Caso se deseje que a variável contenha valores negativos, é necessário utilizar o comando da linguagem de programação para incluir sinal.",
    "d) As variáveis do tipo vetor são utilizadas para armazenar valores numéricos com parte fracionária.",
    "e) O conjunto de operações disponível para o tipo caractere inclui soma, subtração, multiplicação, divisão inteira e resto da divisão."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens de Programação",
  "subarea": "Teoria dos Tipos: Sistemas de Tipos, Polimorfismo",
  "gabarito": "A",
  "atributo_rag": "fundamentos da computacao - linguagens de programacao - teoria dos tipos: sistemas de tipos, polimorfismo"
},

{
  "id": "2024-46",
  "edicao": 2024,
  "numero": 46,
  "enunciado": "Analise as assertivas abaixo sobre estruturas em linguagens de programação:\\\nI. Uma estrutura é um conjunto de uma ou mais variáveis agrupadas sob um único nome, de forma a facilitar a sua referência.\\\nII. A declaração de uma estrutura corresponde unicamente à definição de um novo tipo (isto é , da sua estrutura), e não à declaração de variáveis do tipo da estrutura.\\\nIII. Uma estrutura pode conter, na sua definição, variáveis simples, vetores, ponteiros ou mesmo outras estruturas.\\\nIV. As estruturas permitem agrupar diversos componentes em uma única variável, que podem ser definidos com tipos distintos.\n\nQuais estão corretas?",
  "alternativas": [
    "a) Apenas I e II.",
    "b) Apenas III e IV.",
    "c) Apenas I, II e III.",
    "d) Apenas II, III e IV.",
    "e) I, II, III e IV."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Linguagens de Programação",
  "subarea": "Paradigmas de Linguagens de Programação",
  "gabarito": "E",
  "atributo_rag": "fundamentos da computacao - linguagens de programacao - paradigmas de linguagens de programacao"
},

{
  "id": "2024-47",
  "edicao": 2024,
  "numero": 47,
  "enunciado": "Analise o texto a seguir, que descreve um programa que solicita um salário ao usuário e mostra o imposto a pagar:\n- Se o salário for negativo ou zero, mostre o erro respectivo.\n- Se o salário for maior que 1000, paga 10% de imposto, se não paga apenas 5%.\nPara resolver o problema descrito acima, qual instrução deve ser utilizada?",
  "alternativas": [
    "a) Laço encadeado.",
    "b) Atribuição composta.",
    "c) Laço infinito.",
    "d) Condicional encadeada.",
    "e) Atribuição simples."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Técnicas de Programação",
  "subarea": "Comandos de uma Linguagem de programação",
  "gabarito": "D",
  "atributo_rag": "fundamentos da computacao - tecnicas de programacao - comandos de uma linguagem de programacao"
},

{
  "id": "2024-48",
  "edicao": 2024,
  "numero": 48,
  "enunciado": "Um mapa de cidade pode ser modelado como um grafo cujos vértices são cruzamentos ou finais de ruas e cujas arestas podem ser trechos de ruas sem cruzamento. Esse grafo tem arestas não dirigidas, representando ruas de dois sentidos, e arestas dirigidas, correspondendo a trechos de um único sentido. Assim, um grafo que representa as ruas de uma cidade é um:",
  "alternativas": [
    "a) Dígrafo.",
    "b) Grafo completo.",
    "c) Grafo misto.",
    "d) Bígrafo.",
    "e) Grafo simétrico."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Teoria dos Grafos",
  "subarea": "Grafos orientados e não-orientados",
  "gabarito": "C",
  "atributo_rag": "fundamentos da computacao - teoria dos grafos - grafos orientados e nao-orientados"
},

{
  "id": "2024-49",
  "edicao": 2024,
  "numero": 49,
  "enunciado": "A definição de um grafo agrupa arestas como uma coleção, não como um conjunto,\npermitindo que duas arestas não dirigidas tenham os mesmos pontos finais e que duas arestas dirigidas tenham a mesma origem e o mesmo destino. Tais arestas são chamadas de:",
  "alternativas": [
    "a) Paralelas.",
    "b) Laços.",
    "c) Adjacentes.",
    "d) Incidentes.",
    "e) Finais."
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Teoria dos Grafos",
  "subarea": "Grafos orientados e não-orientados",
  "gabarito": "A",
  "atributo_rag": "fundamentos da computacao - teoria dos grafos - grafos orientados e nao-orientados"
},

{
  "id": "2024-50",
  "edicao": 2024,
  "numero": 50,
  "enunciado": "Um _______ é um caminho em que os vértices de início e fim são os mesmos.\n\nAssinale a alternativa que preenche corretamente a lacuna do trecho acima.",
  "alternativas": [
    "a) arco",
    "b) ciclo",
    "c) caminho simples",
    "d) laço",
    "e) k-cubo"
  ],
  "area_conhecimento": "Fundamentos da Computação",
  "area": "Teoria dos Grafos",
  "subarea": "Grafos orientados e não-orientados",
  "gabarito": "B",
  "atributo_rag": "fundamentos da computacao - teoria dos grafos - grafos orientados e nao-orientados"
}
]
